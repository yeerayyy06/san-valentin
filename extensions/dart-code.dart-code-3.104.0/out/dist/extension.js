/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8505:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 8928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var balanced = __webpack_require__(8505);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}



/***/ }),

/***/ 6489:
/***/ ((module) => {

"use strict";


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
const mask = (source, mask, output, offset, length) => {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
};

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
const unmask = (buffer, mask) => {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  const length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = { mask, unmask };


/***/ }),

/***/ 2627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


try {
  module.exports = __webpack_require__(8169)(__dirname);
} catch (e) {
  module.exports = __webpack_require__(6489);
}


/***/ }),

/***/ 8169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

if (typeof process.addon === 'function') { // if the platform supports native resolving prefer that
  module.exports = process.addon.bind(process)
} else { // else use the runtime version here
  module.exports = __webpack_require__(1381)
}


/***/ }),

/***/ 1381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(9896)
var path = __webpack_require__(6928)
var os = __webpack_require__(857)

// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
var runtimeRequire =  true ? require : 0 // eslint-disable-line

var vars = (process.config && process.config.variables) || {}
var prebuildsOnly = !!process.env.PREBUILDS_ONLY
var abi = process.versions.modules // TODO: support old node where this is undef
var runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')

var arch = process.env.npm_config_arch || os.arch()
var platform = process.env.npm_config_platform || os.platform()
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc')
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''
var uv = (process.versions.uv || '').split('.')[0]

module.exports = load

function load (dir) {
  return runtimeRequire(load.resolve(dir))
}

load.resolve = load.path = function (dir) {
  dir = path.resolve(dir || '.')

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_')
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD']
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)
    if (release) return release

    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)
    if (debug) return debug
  }

  var prebuild = resolve(dir)
  if (prebuild) return prebuild

  var nearby = resolve(path.dirname(process.execPath))
  if (nearby) return nearby

  var target = [
    'platform=' + platform,
    'arch=' + arch,
    'runtime=' + runtime,
    'abi=' + abi,
    'uv=' + uv,
    armv ? 'armv=' + armv : '',
    'libc=' + libc,
    'node=' + process.versions.node,
    process.versions.electron ? 'electron=' + process.versions.electron : '',
     true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ')

  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n')

  function resolve (dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]
    if (!tuple) return

    // Find most specific flavor first
    var prebuilds = path.join(dir, 'prebuilds', tuple.name)
    var parsed = readdirSync(prebuilds).map(parseTags)
    var candidates = parsed.filter(matchTags(runtime, abi))
    var winner = candidates.sort(compareTags(runtime))[0]
    if (winner) return path.join(prebuilds, winner.file)
  }
}

function readdirSync (dir) {
  try {
    return fs.readdirSync(dir)
  } catch (err) {
    return []
  }
}

function getFirst (dir, filter) {
  var files = readdirSync(dir).filter(filter)
  return files[0] && path.join(dir, files[0])
}

function matchBuild (name) {
  return /\.node$/.test(name)
}

function parseTuple (name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-')
  if (arr.length !== 2) return

  var platform = arr[0]
  var architectures = arr[1].split('+')

  if (!platform) return
  if (!architectures.length) return
  if (!architectures.every(Boolean)) return

  return { name, platform, architectures }
}

function matchTuple (platform, arch) {
  return function (tuple) {
    if (tuple == null) return false
    if (tuple.platform !== platform) return false
    return tuple.architectures.includes(arch)
  }
}

function compareTuples (a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length
}

function parseTags (file) {
  var arr = file.split('.')
  var extension = arr.pop()
  var tags = { file: file, specificity: 0 }

  if (extension !== 'node') return

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i]

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag
    } else if (tag === 'napi') {
      tags.napi = true
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3)
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2)
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4)
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag
    } else {
      continue
    }

    tags.specificity++
  }

  return tags
}

function matchTags (runtime, abi) {
  return function (tags) {
    if (tags == null) return false
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false
    if (tags.abi !== abi && !tags.napi) return false
    if (tags.uv && tags.uv !== uv) return false
    if (tags.armv && tags.armv !== armv) return false
    if (tags.libc && tags.libc !== libc) return false

    return true
  }
}

function runtimeAgnostic (tags) {
  return tags.runtime === 'node' && tags.napi
}

function compareTags (runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1
    } else {
      return 0
    }
  }
}

function isNwjs () {
  return !!(process.versions && process.versions.nw)
}

function isElectron () {
  if (process.versions && process.versions.electron) return true
  if (process.env.ELECTRON_RUN_AS_NODE) return true
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'
}

function isAlpine (platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release')
}

// Exposed for unit tests
// TODO: move to lib
load.parseTags = parseTags
load.matchTags = matchTags
load.compareTags = compareTags
load.parseTuple = parseTuple
load.matchTuple = matchTuple
load.compareTuples = compareTuples


/***/ }),

/***/ 3904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    }
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    }

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    }
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    }
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    }
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    }
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    }
    return false
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(8587)
const { safeRe: re, t } = __webpack_require__(9718)
const cmp = __webpack_require__(2111)
const debug = __webpack_require__(7272)
const SemVer = __webpack_require__(3908)
const Range = __webpack_require__(8311)


/***/ }),

/***/ 8311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First reduce all whitespace as much as possible so we do not have to rely
    // on potentially slow regexes like \s*. This is then stored and used for
    // future error messages as well.
    this.raw = range
      .trim()
      .split(/\s+/)
      .join(' ')

    // First, split on ||
    this.set = this.raw
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => comps.join(' ').trim())
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts =
      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
      (this.options.loose && FLAG_LOOSE)
    const memoKey = memoOpts + ':' + range
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)

    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)
    debug('tilde trim', range)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)
    debug('caret trim', range)

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}

module.exports = Range

const LRU = __webpack_require__(8794)
const cache = new LRU()

const parseOptions = __webpack_require__(8587)
const Comparator = __webpack_require__(3904)
const debug = __webpack_require__(7272)
const SemVer = __webpack_require__(3908)
const {
  safeRe: re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(9718)
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(6874)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceTilde(c, options))
    .join(' ')
}

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) => {
  return comp
    .trim()
    .split(/\s+/)
    .map((c) => replaceCaret(c, options))
    .join(' ')
}

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp
    .split(/\s+/)
    .map((c) => replaceXRange(c, options))
    .join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp
    .trim()
    .replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp
    .trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return `${from} ${to}`.trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ 3908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(7272)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(6874)
const { safeRe: re, t } = __webpack_require__(9718)

const parseOptions = __webpack_require__(8587)
const { compareIdentifiers } = __webpack_require__(1123)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('build compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier, identifierBase) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier, identifierBase)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier, identifierBase)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier, identifierBase)
        this.inc('pre', identifier, identifierBase)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier, identifierBase)
        }
        this.inc('pre', identifier, identifierBase)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre': {
        const base = Number(identifierBase) ? 1 : 0

        if (!identifier && identifierBase === false) {
          throw new Error('invalid increment argument: identifier is empty')
        }

        if (this.prerelease.length === 0) {
          this.prerelease = [base]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            if (identifier === this.prerelease.join('.') && identifierBase === false) {
              throw new Error('invalid increment argument: identifier already exists')
            }
            this.prerelease.push(base)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          let prerelease = [identifier, base]
          if (identifierBase === false) {
            prerelease = [identifier]
          }
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = prerelease
            }
          } else {
            this.prerelease = prerelease
          }
        }
        break
      }
      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.raw = this.format()
    if (this.build.length) {
      this.raw += `+${this.build.join('.')}`
    }
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ 7414:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(144)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ 2111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(4641)
const neq = __webpack_require__(3999)
const gt = __webpack_require__(5580)
const gte = __webpack_require__(4089)
const lt = __webpack_require__(7059)
const lte = __webpack_require__(5200)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ 6170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const parse = __webpack_require__(144)
const { safeRe: re, t } = __webpack_require__(9718)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]
    let next
    while ((next = coerceRtlRegex.exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    coerceRtlRegex.lastIndex = -1
  }

  if (match === null) {
    return null
  }

  const major = match[2]
  const minor = match[3] || '0'
  const patch = match[4] || '0'
  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''
  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''

  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
}
module.exports = coerce


/***/ }),

/***/ 909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ 1763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ 560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ 1832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(144)

const diff = (version1, version2) => {
  const v1 = parse(version1, null, true)
  const v2 = parse(version2, null, true)
  const comparison = v1.compare(v2)

  if (comparison === 0) {
    return null
  }

  const v1Higher = comparison > 0
  const highVersion = v1Higher ? v1 : v2
  const lowVersion = v1Higher ? v2 : v1
  const highHasPre = !!highVersion.prerelease.length
  const lowHasPre = !!lowVersion.prerelease.length

  if (lowHasPre && !highHasPre) {
    // Going from prerelease -> no prerelease requires some special casing

    // If the low version has only a major, then it will always be a major
    // Some examples:
    // 1.0.0-1 -> 1.0.0
    // 1.0.0-1 -> 1.1.1
    // 1.0.0-1 -> 2.0.0
    if (!lowVersion.patch && !lowVersion.minor) {
      return 'major'
    }

    // Otherwise it can be determined by checking the high version

    if (highVersion.patch) {
      // anything higher than a patch bump would result in the wrong version
      return 'patch'
    }

    if (highVersion.minor) {
      // anything higher than a minor bump would result in the wrong version
      return 'minor'
    }

    // bumping major/minor/patch all have same result
    return 'major'
  }

  // add the `pre` prefix if we are going to a prerelease version
  const prefix = highHasPre ? 'pre' : ''

  if (v1.major !== v2.major) {
    return prefix + 'major'
  }

  if (v1.minor !== v2.minor) {
    return prefix + 'minor'
  }

  if (v1.patch !== v2.patch) {
    return prefix + 'patch'
  }

  // high and low are preleases
  return 'prerelease'
}

module.exports = diff


/***/ }),

/***/ 4641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ 5580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ 4089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ 3007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)

const inc = (version, release, options, identifier, identifierBase) => {
  if (typeof (options) === 'string') {
    identifierBase = identifier
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier, identifierBase).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ 7059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ 5200:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ 2938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ 6254:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ 3999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ 144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const parse = (version, options, throwErrors = false) => {
  if (version instanceof SemVer) {
    return version
  }
  try {
    return new SemVer(version, options)
  } catch (er) {
    if (!throwErrors) {
      return null
    }
    throw er
  }
}

module.exports = parse


/***/ }),

/***/ 4493:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ 1729:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(144)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ 9970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(560)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ 4277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(909)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ 7638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(8311)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ 3927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(909)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ 6953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(144)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ 9589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(9718)
const constants = __webpack_require__(6874)
const SemVer = __webpack_require__(3908)
const identifiers = __webpack_require__(1123)
const parse = __webpack_require__(144)
const valid = __webpack_require__(6953)
const clean = __webpack_require__(7414)
const inc = __webpack_require__(3007)
const diff = __webpack_require__(1832)
const major = __webpack_require__(2938)
const minor = __webpack_require__(6254)
const patch = __webpack_require__(4493)
const prerelease = __webpack_require__(1729)
const compare = __webpack_require__(560)
const rcompare = __webpack_require__(9970)
const compareLoose = __webpack_require__(1763)
const compareBuild = __webpack_require__(909)
const sort = __webpack_require__(3927)
const rsort = __webpack_require__(4277)
const gt = __webpack_require__(5580)
const lt = __webpack_require__(7059)
const eq = __webpack_require__(4641)
const neq = __webpack_require__(3999)
const gte = __webpack_require__(4089)
const lte = __webpack_require__(5200)
const cmp = __webpack_require__(2111)
const coerce = __webpack_require__(6170)
const Comparator = __webpack_require__(3904)
const Range = __webpack_require__(8311)
const satisfies = __webpack_require__(7638)
const toComparators = __webpack_require__(7631)
const maxSatisfying = __webpack_require__(9628)
const minSatisfying = __webpack_require__(270)
const minVersion = __webpack_require__(1261)
const validRange = __webpack_require__(3874)
const outside = __webpack_require__(7075)
const gtr = __webpack_require__(5571)
const ltr = __webpack_require__(5342)
const intersects = __webpack_require__(6780)
const simplifyRange = __webpack_require__(2525)
const subset = __webpack_require__(5032)
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: constants.RELEASE_TYPES,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ 6874:
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

const RELEASE_TYPES = [
  'major',
  'premajor',
  'minor',
  'preminor',
  'patch',
  'prepatch',
  'prerelease',
]

module.exports = {
  MAX_LENGTH,
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_SAFE_INTEGER,
  RELEASE_TYPES,
  SEMVER_SPEC_VERSION,
  FLAG_INCLUDE_PRERELEASE: 0b001,
  FLAG_LOOSE: 0b010,
}


/***/ }),

/***/ 7272:
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ 1123:
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ 8794:
/***/ ((module) => {

class LRUCache {
  constructor () {
    this.max = 1000
    this.map = new Map()
  }

  get (key) {
    const value = this.map.get(key)
    if (value === undefined) {
      return undefined
    } else {
      // Remove the key from the map and add it to the end
      this.map.delete(key)
      this.map.set(key, value)
      return value
    }
  }

  delete (key) {
    return this.map.delete(key)
  }

  set (key, value) {
    const deleted = this.delete(key)

    if (!deleted && value !== undefined) {
      // If cache is full, delete the least recently used item
      if (this.map.size >= this.max) {
        const firstKey = this.map.keys().next().value
        this.delete(firstKey)
      }

      this.map.set(key, value)
    }

    return this
  }
}

module.exports = LRUCache


/***/ }),

/***/ 8587:
/***/ ((module) => {

// parse out just the options we care about
const looseOption = Object.freeze({ loose: true })
const emptyOpts = Object.freeze({ })
const parseOptions = options => {
  if (!options) {
    return emptyOpts
  }

  if (typeof options !== 'object') {
    return looseOption
  }

  return options
}
module.exports = parseOptions


/***/ }),

/***/ 9718:
/***/ ((module, exports, __webpack_require__) => {

const {
  MAX_SAFE_COMPONENT_LENGTH,
  MAX_SAFE_BUILD_LENGTH,
  MAX_LENGTH,
} = __webpack_require__(6874)
const debug = __webpack_require__(7272)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const safeRe = exports.safeRe = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const LETTERDASHNUMBER = '[a-zA-Z0-9-]'

// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
  ['\\s', 1],
  ['\\d', MAX_LENGTH],
  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
]

const makeSafeRegex = (value) => {
  for (const [token, max] of safeRegexReplacements) {
    value = value
      .split(`${token}*`).join(`${token}{0,${max}}`)
      .split(`${token}+`).join(`${token}{1,${max}}`)
  }
  return value
}

const createToken = (name, value, isGlobal) => {
  const safe = makeSafeRegex(value)
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '\\d+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`)
createToken('COERCEFULL', src[t.COERCEPLAIN] +
              `(?:${src[t.PRERELEASE]})?` +
              `(?:${src[t.BUILD]})?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)
createToken('COERCERTLFULL', src[t.COERCEFULL], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ 5571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(7075)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ 6780:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(8311)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2, options)
}
module.exports = intersects


/***/ }),

/***/ 5342:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(7075)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ 9628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const Range = __webpack_require__(8311)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ 270:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const Range = __webpack_require__(8311)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ 1261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const Range = __webpack_require__(8311)
const gt = __webpack_require__(5580)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ 7075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(3908)
const Comparator = __webpack_require__(3904)
const { ANY } = Comparator
const Range = __webpack_require__(8311)
const satisfies = __webpack_require__(7638)
const gt = __webpack_require__(5580)
const lt = __webpack_require__(7059)
const lte = __webpack_require__(5200)
const gte = __webpack_require__(4089)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ 2525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(7638)
const compare = __webpack_require__(560)
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ 5032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(8311)
const Comparator = __webpack_require__(3904)
const { ANY } = Comparator
const satisfies = __webpack_require__(7638)
const compare = __webpack_require__(560)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]
const minimumVersion = [new Comparator('>=0.0.0')]

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = minimumVersionWithPreRelease
    } else {
      sub = minimumVersion
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = minimumVersion
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ 7631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(8311)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ 3874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(8311)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ 2423:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAnalyzerArgs = getAnalyzerArgs;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const extension_utils_1 = __webpack_require__(6584);
const utils_1 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
function getAnalyzerArgs(logger, sdks, dartCapabilities, isLsp) {
    const analyzerPath = config_1.config.analyzerPath || (dartCapabilities.supportsLanguageServerCommand
        ? "language-server"
        : path.join(sdks.dart, constants_1.analyzerSnapshotPath));
    // If the ssh host is set, then we are running the analyzer on a remote machine, that same analyzer
    // might not exist on the local machine.
    if (!config_1.config.analyzerSshHost && analyzerPath !== "language-server" && !fs.existsSync(analyzerPath)) {
        const msg = "Could not find a Dart Analysis Server at " + analyzerPath;
        void vs.window.showErrorMessage(msg);
        logger.error(msg);
        throw new Error(msg);
    }
    return buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp);
}
function buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp) {
    let analyzerArgs = [];
    // Optionally start the VM service for the analyzer.
    const vmServicePort = config_1.config.analyzerVmServicePort;
    if (vmServicePort) {
        analyzerArgs.push(`--enable-vm-service=${vmServicePort}`);
        // When using LSP, printing the VM Service URI will break the protocol and
        // stop the client from working, so it needs to be hidden.
        analyzerArgs.push(`-DSILENT_OBSERVATORY=true`);
        analyzerArgs.push(`-DSILENT_VM_SERVICE=true`);
        analyzerArgs.push(`--disable-service-auth-codes`);
        analyzerArgs.push(`--no-dds`);
        if (dartCapabilities.supportsNoServeDevTools)
            analyzerArgs.push("--no-serve-devtools");
    }
    // Allow arbitrary VM args to be passed to the analysis server.
    if (config_1.config.analyzerVmAdditionalArgs)
        analyzerArgs = analyzerArgs.concat(config_1.config.analyzerVmAdditionalArgs);
    analyzerArgs.push(analyzerPath);
    if (analyzerPath === "language-server") {
        if (!isLsp)
            analyzerArgs.push("--protocol=analyzer");
        else
            analyzerArgs.push("--protocol=lsp");
    }
    else {
        if (isLsp)
            analyzerArgs.push("--lsp");
    }
    // Optionally start the analyzer's diagnostic web server on the given port.
    if (config_1.config.analyzerDiagnosticsPort)
        analyzerArgs.push(`--port=${config_1.config.analyzerDiagnosticsPort}`);
    // Add info about the extension that will be collected for crash reports etc.
    const clientID = utils_1.isRunningLocally ? "VS-Code" : "VS-Code-Remote";
    analyzerArgs.push(`--client-id=${clientID}`);
    analyzerArgs.push(`--client-version=${extension_utils_1.extensionVersion}`);
    // The analysis server supports a verbose instrumentation log file.
    if (config_1.config.analyzerInstrumentationLogFile)
        analyzerArgs.push(`--instrumentation-log-file=${config_1.config.analyzerInstrumentationLogFile}`);
    // Allow arbitrary args to be passed to the analysis server.
    if (config_1.config.analyzerAdditionalArgs)
        analyzerArgs = analyzerArgs.concat(config_1.config.analyzerAdditionalArgs);
    return analyzerArgs;
}


/***/ }),

/***/ 5476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DasAnalyzerClient = exports.DasAnalyzer = exports.AnalyzerCapabilities = void 0;
exports.getSymbolKindForElementKind = getSymbolKindForElementKind;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const analyzer_1 = __webpack_require__(5244);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const constants_2 = __webpack_require__(5706);
const status_bar_1 = __webpack_require__(719);
const config_1 = __webpack_require__(7678);
const utils_2 = __webpack_require__(279);
const misc_1 = __webpack_require__(1166);
const processes_1 = __webpack_require__(8141);
const analyzer_2 = __webpack_require__(2423);
const analyzer_gen_1 = __webpack_require__(9670);
const file_tracker_das_1 = __webpack_require__(7583);
class AnalyzerCapabilities {
    static get empty() { return new AnalyzerCapabilities("0.0.0"); }
    version;
    constructor(analyzerVersion) {
        this.version = analyzerVersion;
    }
    get hasCompleteStatementFix() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.2"); }
    get supportsPriorityFilesOutsideAnalysisRoots() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.2"); }
    get supportsDiagnostics() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.1"); }
    get supportsClosingLabels() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.4"); }
    get supportsCustomFolding() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.3"); }
    // 1.26.0 is stable Flutter at time of writing. Unclear what version had Outline, but
    // we don't need to support older.
    get supportsFlutterOutline() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsGetDeclerations() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.7"); }
    get supportsGetDeclerationsForFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.19.0"); }
    get supportsGetSignature() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.5"); }
    get supportsMoveFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.0"); }
    get supportsAvailableSuggestions() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsIncludedImports() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.1"); }
}
exports.AnalyzerCapabilities = AnalyzerCapabilities;
class DasAnalyzer extends analyzer_1.Analyzer {
    client;
    fileTracker;
    statusItem = (0, status_bar_1.getLanguageStatusItem)("dart.analysisServer", constants_2.ANALYSIS_FILTERS);
    constructor(logger, analytics, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.setupStatusItem();
        this.client = new DasAnalyzerClient(this.logger, sdks, dartCapabilities);
        this.fileTracker = new file_tracker_das_1.DasFileTracker(logger, this.client, wsContext);
        this.disposables.push(this.client);
        this.disposables.push(this.fileTracker);
        const connectedEvent = this.client.registerForServerConnected((sc) => {
            this.statusItem.text = "Dart Analysis Server";
            this.onReadyCompleter.resolve();
            connectedEvent.dispose();
        });
        this.client.registerForServerStatus((params) => {
            if (params.analysis) {
                this.statusItem.busy = params.analysis.isAnalyzing;
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.analysis.isAnalyzing });
            }
        });
    }
    setupStatusItem() {
        const statusItem = this.statusItem;
        statusItem.text = "Dart Analysis Server Starting…";
        statusItem.command = {
            command: "dart.restartAnalysisServer",
            title: "restart",
            tooltip: "Restarts the Dart Analysis Server",
        };
    }
    getDiagnosticServerPort() {
        return this.client.diagnosticGetServerPort();
    }
    async forceReanalyze() {
        await this.client.analysisReanalyze();
    }
}
exports.DasAnalyzer = DasAnalyzer;
class DasAnalyzerClient extends analyzer_gen_1.AnalyzerGen {
    lastDiagnostics;
    launchArgs;
    version;
    isAnalyzing = false;
    currentAnalysisCompleter;
    capabilities = AnalyzerCapabilities.empty;
    constructor(logger, sdks, dartCapabilities) {
        super(logger, config_1.config.maxLogLineLength);
        this.launchArgs = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, false);
        // Hook error subscriptions so we can try and get diagnostic info if this happens.
        this.registerForServerError((e) => this.requestDiagnosticsUpdate());
        this.registerForRequestError((e) => this.requestDiagnosticsUpdate());
        // Register for version.
        this.registerForServerConnected((e) => { this.version = e.version; this.capabilities.version = this.version; });
        const fullDartVmPath = path.join(sdks.dart, constants_1.dartVMPath);
        let binaryPath = fullDartVmPath;
        let processArgs = this.launchArgs.slice();
        // Since we communicate with the analysis server over STDOUT/STDIN, it is trivial for us
        // to support launching it on a remote machine over SSH. This can be useful if the codebase
        // is being modified remotely over SSHFS, and running the analysis server locally would
        // result in excessive file reading over SSHFS.
        if (config_1.config.analyzerSshHost) {
            binaryPath = "ssh";
            processArgs.unshift(fullDartVmPath);
            processArgs = [
                // SSH quiet mode, which prevents SSH from interfering with the STDOUT/STDIN communication
                // with the analysis server.
                "-q",
                config_1.config.analyzerSshHost,
                (0, utils_2.escapeShell)(processArgs),
            ];
        }
        this.createProcess(undefined, binaryPath, processArgs, { toolEnv: (0, processes_1.getToolEnv)() });
        this.process?.on("exit", (code, signal) => {
            this.handleAnalyzerTerminated(!!code);
        });
        this.registerForServerStatus((n) => {
            if (n.analysis) {
                if (n.analysis.isAnalyzing) {
                    this.isAnalyzing = true;
                }
                else {
                    this.isAnalyzing = false;
                    if (this.currentAnalysisCompleter) {
                        this.currentAnalysisCompleter.resolve();
                        this.currentAnalysisCompleter = undefined;
                    }
                }
            }
        });
        void this.serverSetSubscriptions({
            subscriptions: ["STATUS"],
        });
        void this.sendRequest("server.setClientCapabilities", {
            requests: ["openUrlRequest", "showMessageRequest"],
        });
    }
    resolvedPromise = Promise.resolve();
    get currentAnalysis() {
        if (!this.isAnalyzing)
            return this.resolvedPromise;
        if (!this.currentAnalysisCompleter)
            this.currentAnalysisCompleter = new utils_1.PromiseCompleter();
        return this.currentAnalysisCompleter.promise;
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            this.handleAnalyzerTerminated(true);
            throw e;
        }
    }
    handleAnalyzerTerminated(withError) {
        const serverHasStarted = !!this.version;
        if (withError)
            (0, misc_1.reportAnalyzerTerminatedWithError)(!serverHasStarted);
        void this.notify(this.serverTerminatedSubscriptions, undefined);
    }
    async handleRequest(method, params) {
        switch (method) {
            case "server.showMessageRequest":
                return this.handleShowMessageRequest(params);
            case "server.openUrlRequest":
                return this.handleOpenUrl(params);
            default:
                throw new Error(`Unknown request ${method}`);
        }
    }
    handleOpenUrl(params) {
        void vs.env.openExternal(vs.Uri.parse(params.url));
        return;
    }
    async handleShowMessageRequest(params) {
        const actionStrings = params.actions.map((s) => s.label);
        const userChoiceString = await vs.window.showInformationMessage(params.message, ...actionStrings);
        return {
            action: userChoiceString,
        };
    }
    shouldHandleMessage(message) {
        // This will include things like Observatory output and some analyzer logging code.
        return !message.startsWith("--- ")
            && !message.startsWith("+++ ")
            && !message.startsWith("Observatory listening on")
            && !message.startsWith("The Dart VM service is listening on")
            && !message.startsWith("Observatory server");
    }
    async requestDiagnosticsUpdate() {
        this.lastDiagnostics = undefined;
        if (!this.capabilities.supportsDiagnostics)
            return;
        this.lastDiagnostics = (await this.diagnosticGetDiagnostics()).contexts;
    }
    getLastDiagnostics() {
        return this.lastDiagnostics;
    }
    getAnalyzerLaunchArgs() {
        return this.launchArgs;
    }
    forceNotificationsFor(file) {
        // Send a dummy edit (https://github.com/dart-lang/sdk/issues/30238)
        const files = {};
        files[file] = {
            edits: [{ offset: 0, length: 0, replacement: "", id: "" }],
            type: "change",
        };
        void this.analysisUpdateContent({ files });
    }
    // Wraps completionGetSuggestions to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    completionGetSuggestionsResults(request) {
        return this.requestWithStreamedResults(() => this.completionGetSuggestions(request), this.registerForCompletionResults);
    }
    // Wraps searchFindElementReferences to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindElementReferencesResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindElementReferences(request), this.registerForSearchResults);
    }
    // Wraps searchFindTopLevelDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindTopLevelDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindTopLevelDeclarations(request), this.registerForSearchResults);
    }
    // Wraps searchFindMemberDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindMemberDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindMemberDeclarations(request), this.registerForSearchResults);
    }
    // We need to subscribe before we send the request to avoid races in registering
    // for results (see https://github.com/Dart-Code/Dart-Code/issues/471).
    // Since we don't have the ID yet, we'll have to buffer them for the duration
    // and check inside the buffer when we get the ID back.
    requestWithStreamedResults(sendRequest, registerForResults) {
        return new Promise((resolve, reject) => {
            const buffer = []; // Buffer to store results that come in before we're ready.
            let searchResultsID; // ID that'll be set once we get it back.
            const disposable = registerForResults.bind(this)((notification) => {
                // If we know our ID and this is it, and it's the last result, then resolve.
                if (searchResultsID && notification.id === searchResultsID && notification.isLast) {
                    disposable.dispose();
                    resolve(notification);
                }
                else if (!searchResultsID && notification.isLast) // Otherwise if we didn't know our ID and this might be what we want, stash it.
                    buffer.push(notification);
            });
            // Now we have the above handler set up, send the actual request.
            sendRequest.bind(this)().then((resp) => {
                if (!resp.id) {
                    disposable.dispose();
                    reject();
                }
                // When the ID comes back, stash it...
                searchResultsID = resp.id;
                // And also check the buffer.
                const result = buffer.find((b) => b.id === searchResultsID);
                if (result) {
                    disposable.dispose();
                    resolve(result);
                }
            }, () => reject());
        });
    }
    serverTerminatedSubscriptions = [];
    registerForServerTerminated(subscriber) {
        return this.subscribe(this.serverTerminatedSubscriptions, subscriber);
    }
}
exports.DasAnalyzerClient = DasAnalyzerClient;
function getSymbolKindForElementKind(logger, kind) {
    switch (kind) {
        case "CLASS":
        case "CLASS_TYPE_ALIAS":
        case "MIXIN":
            return vs.SymbolKind.Class;
        case "COMPILATION_UNIT":
        case "EXTENSION":
            return vs.SymbolKind.Module;
        case "CONSTRUCTOR":
        case "CONSTRUCTOR_INVOCATION":
            return vs.SymbolKind.Constructor;
        case "ENUM":
            return vs.SymbolKind.Enum;
        case "ENUM_CONSTANT":
            return vs.SymbolKind.EnumMember;
        case "FIELD":
            return vs.SymbolKind.Field;
        case "FILE":
            return vs.SymbolKind.File;
        case "FUNCTION":
        case "FUNCTION_INVOCATION":
        case "FUNCTION_TYPE_ALIAS":
            return vs.SymbolKind.Function;
        case "GETTER":
            return vs.SymbolKind.Property;
        case "LABEL":
            return vs.SymbolKind.Module;
        case "LIBRARY":
            return vs.SymbolKind.Namespace;
        case "LOCAL_VARIABLE":
            return vs.SymbolKind.Variable;
        case "METHOD":
            return vs.SymbolKind.Method;
        case "PARAMETER":
        case "PREFIX":
            return vs.SymbolKind.Variable;
        case "SETTER":
            return vs.SymbolKind.Property;
        case "TOP_LEVEL_VARIABLE":
        case "TYPE_PARAMETER":
            return vs.SymbolKind.Variable;
        case "UNIT_TEST_GROUP":
            return vs.SymbolKind.Module;
        case "UNIT_TEST_TEST":
            return vs.SymbolKind.Method;
        case "UNKNOWN":
            return vs.SymbolKind.Object;
        default:
            logger.error(`Unknown kind: ${kind}`, enums_1.LogCategory.Analyzer);
            return vs.SymbolKind.Object;
    }
}


/***/ }),

/***/ 9670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* eslint-disable */
// This file was generated by Dart-Code-Class-Builder
// and should not be hand-edited!
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerGen = void 0;
const stdio_service_1 = __webpack_require__(7724);
class AnalyzerGen extends stdio_service_1.StdIOService {
    constructor(logger, maxLogLineLength) {
        super(logger, maxLogLineLength);
    }
    buildRequest(id, method, params) {
        return Object.assign(super.buildRequest(id, method, params), { clientRequestTime: Date.now() });
    }
    serverConnectedSubscriptions = [];
    serverErrorSubscriptions = [];
    serverStatusSubscriptions = [];
    analysisAnalyzedFilesSubscriptions = [];
    analysisClosingLabelsSubscriptions = [];
    analysisErrorsSubscriptions = [];
    analysisFlushResultsSubscriptions = [];
    analysisFoldingSubscriptions = [];
    analysisHighlightsSubscriptions = [];
    analysisImplementedSubscriptions = [];
    analysisInvalidateSubscriptions = [];
    analysisNavigationSubscriptions = [];
    analysisOccurrencesSubscriptions = [];
    analysisOutlineSubscriptions = [];
    analysisOverridesSubscriptions = [];
    completionResultsSubscriptions = [];
    completionAvailableSuggestionsSubscriptions = [];
    completionExistingImportsSubscriptions = [];
    searchResultsSubscriptions = [];
    executionLaunchDataSubscriptions = [];
    flutterOutlineSubscriptions = [];
    async handleNotification(evt) {
        switch (evt.event) {
            case "server.connected":
                await this.notify(this.serverConnectedSubscriptions, evt.params);
                break;
            case "server.error":
                await this.notify(this.serverErrorSubscriptions, evt.params);
                break;
            case "server.status":
                await this.notify(this.serverStatusSubscriptions, evt.params);
                break;
            case "analysis.analyzedFiles":
                await this.notify(this.analysisAnalyzedFilesSubscriptions, evt.params);
                break;
            case "analysis.closingLabels":
                await this.notify(this.analysisClosingLabelsSubscriptions, evt.params);
                break;
            case "analysis.errors":
                await this.notify(this.analysisErrorsSubscriptions, evt.params);
                break;
            case "analysis.flushResults":
                await this.notify(this.analysisFlushResultsSubscriptions, evt.params);
                break;
            case "analysis.folding":
                await this.notify(this.analysisFoldingSubscriptions, evt.params);
                break;
            case "analysis.highlights":
                await this.notify(this.analysisHighlightsSubscriptions, evt.params);
                break;
            case "analysis.implemented":
                await this.notify(this.analysisImplementedSubscriptions, evt.params);
                break;
            case "analysis.invalidate":
                await this.notify(this.analysisInvalidateSubscriptions, evt.params);
                break;
            case "analysis.navigation":
                await this.notify(this.analysisNavigationSubscriptions, evt.params);
                break;
            case "analysis.occurrences":
                await this.notify(this.analysisOccurrencesSubscriptions, evt.params);
                break;
            case "analysis.outline":
                await this.notify(this.analysisOutlineSubscriptions, evt.params);
                break;
            case "analysis.overrides":
                await this.notify(this.analysisOverridesSubscriptions, evt.params);
                break;
            case "completion.results":
                await this.notify(this.completionResultsSubscriptions, evt.params);
                break;
            case "completion.availableSuggestions":
                await this.notify(this.completionAvailableSuggestionsSubscriptions, evt.params);
                break;
            case "completion.existingImports":
                await this.notify(this.completionExistingImportsSubscriptions, evt.params);
                break;
            case "search.results":
                await this.notify(this.searchResultsSubscriptions, evt.params);
                break;
            case "execution.launchData":
                await this.notify(this.executionLaunchDataSubscriptions, evt.params);
                break;
            case "flutter.outline":
                await this.notify(this.flutterOutlineSubscriptions, evt.params);
                break;
        }
    }
    /**
    Reports that the server is running. This notification is
    issued once after the server has started running but before
    any requests are processed to let the client know that it
    started correctly.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerConnected(subscriber) {
        return this.subscribe(this.serverConnectedSubscriptions, subscriber);
    }
    /**
    Reports that an unexpected error has occurred while
    executing the server. This notification is not used for
    problems with specific requests (which are returned as part
    of the response) but is used for exceptions that occur while
    performing other tasks, such as analysis or preparing
    notifications.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerError(subscriber) {
        return this.subscribe(this.serverErrorSubscriptions, subscriber);
    }
    /**
    Reports the current status of the server. Parameters are
    omitted if there has been no change in the status
    represented by that parameter.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "STATUS" in
    the list of services passed in a server.setSubscriptions
    request.
    */
    registerForServerStatus(subscriber) {
        return this.subscribe(this.serverStatusSubscriptions, subscriber);
    }
    /**
    Reports the paths of the files that are being analyzed.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "ANALYZED_FILES" in the list
    of services passed in an analysis.setGeneralSubscriptions request.
    */
    registerForAnalysisAnalyzedFiles(subscriber) {
        return this.subscribe(this.analysisAnalyzedFilesSubscriptions, subscriber);
    }
    /**
    Reports closing labels relevant to a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "CLOSING_LABELS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisClosingLabels(subscriber) {
        return this.subscribe(this.analysisClosingLabelsSubscriptions, subscriber);
    }
    /**
    Reports the errors associated with a given file. The set of
    errors included in the notification is always a complete
    list that supersedes any previously reported errors.
    */
    registerForAnalysisErrors(subscriber) {
        return this.subscribe(this.analysisErrorsSubscriptions, subscriber);
    }
    /**
    Reports that any analysis results that were previously
    associated with the given files should be considered to be
    invalid because those files are no longer being analyzed,
    either because the analysis root that contained it is no
    longer being analyzed or because the file no longer exists.
    If a file is included in this notification and at some later
    time a notification with results for the file is received,
    clients should assume that the file is once again being
    analyzed and the information should be processed.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForAnalysisFlushResults(subscriber) {
        return this.subscribe(this.analysisFlushResultsSubscriptions, subscriber);
    }
    /**
    Reports the folding regions associated with a given
    file. Folding regions can be nested, but will not be
    overlapping. Nesting occurs when a foldable element, such as
    a method, is nested inside another foldable element such as
    a class.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "FOLDING" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisFolding(subscriber) {
        return this.subscribe(this.analysisFoldingSubscriptions, subscriber);
    }
    /**
    Reports the highlight regions associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "HIGHLIGHTS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisHighlights(subscriber) {
        return this.subscribe(this.analysisHighlightsSubscriptions, subscriber);
    }
    /**
    Reports the classes that are implemented or extended and
    class members that are implemented or overridden in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "IMPLEMENTED" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisImplemented(subscriber) {
        return this.subscribe(this.analysisImplementedSubscriptions, subscriber);
    }
    /**
    Reports that the navigation information associated with a region of a
    single file has become invalid and should be re-requested.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "INVALIDATE" in the list of
    services passed in an analysis.setSubscriptions request.
    */
    registerForAnalysisInvalidate(subscriber) {
        return this.subscribe(this.analysisInvalidateSubscriptions, subscriber);
    }
    /**
    Reports the navigation targets associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "NAVIGATION"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisNavigation(subscriber) {
        return this.subscribe(this.analysisNavigationSubscriptions, subscriber);
    }
    /**
    Reports the occurrences of references to elements within a
    single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OCCURRENCES"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisOccurrences(subscriber) {
        return this.subscribe(this.analysisOccurrencesSubscriptions, subscriber);
    }
    /**
    Reports the outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOutline(subscriber) {
        return this.subscribe(this.analysisOutlineSubscriptions, subscriber);
    }
    /**
    Reports the overriding members in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OVERRIDES" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOverrides(subscriber) {
        return this.subscribe(this.analysisOverridesSubscriptions, subscriber);
    }
    /**
    Reports the completion suggestions that should be presented
    to the user. The set of suggestions included in the
    notification is always a complete list that supersedes any
    previously reported suggestions.
    */
    registerForCompletionResults(subscriber) {
        return this.subscribe(this.completionResultsSubscriptions, subscriber);
    }
    /**
    Reports the pre-computed, candidate completions from symbols defined
    in a corresponding library. This notification may be sent multiple times.
    When a notification is processed, clients should replace any previous
    information about the libraries in the list of changedLibraries, discard
    any information about the libraries in the list of removedLibraries, and
    preserve any previously received information about any libraries that are
    not included in either list.
    */
    registerForCompletionAvailableSuggestions(subscriber) {
        return this.subscribe(this.completionAvailableSuggestionsSubscriptions, subscriber);
    }
    /**
    Reports existing imports in a library. This notification may be sent
    multiple times for a library. When a notification is processed, clients
    should replace any previous information for the library.
    */
    registerForCompletionExistingImports(subscriber) {
        return this.subscribe(this.completionExistingImportsSubscriptions, subscriber);
    }
    /**
    Reports some or all of the results of performing a requested
    search. Unlike other notifications, this notification
    contains search results that should be added to any
    previously received search results associated with the same
    search id.
    */
    registerForSearchResults(subscriber) {
        return this.subscribe(this.searchResultsSubscriptions, subscriber);
    }
    /**
    Reports information needed to allow a single file to be launched.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "LAUNCH_DATA" in the list of services
    passed in an execution.setSubscriptions request.
    */
    registerForExecutionLaunchData(subscriber) {
        return this.subscribe(this.executionLaunchDataSubscriptions, subscriber);
    }
    /**
    Reports the Flutter outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an flutter.setSubscriptions
    request.
    */
    registerForFlutterOutline(subscriber) {
        return this.subscribe(this.flutterOutlineSubscriptions, subscriber);
    }
    /**
    Return the version number of the analysis server.
    */
    serverGetVersion() {
        return this.sendRequest("server.getVersion");
    }
    /**
    Cleanly shutdown the analysis server. Requests that are
    received after this request will not be processed. Requests
    that were received before this request, but for which a
    response has not yet been sent, will not be responded to. No
    further responses or notifications will be sent after the
    response to this request has been sent.
    */
    serverShutdown() {
        return this.sendRequest("server.shutdown");
    }
    /**
    Subscribe for services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not
    valid services. If there is an error, then the current
    subscriptions will remain unchanged.
    */
    serverSetSubscriptions(request) {
        return this.sendRequest("server.setSubscriptions", request);
    }
    /**
    Return the errors associated with the given file. If the
    errors for the given file have not yet been computed, or the
    most recently computed errors for the given file are out of
    date, then the response for this request will be delayed
    until they have been computed. If some or all of the errors
    for the file cannot be computed, then the subset of the
    errors that can be computed will be returned and the
    response will contain an error to indicate why the errors
    could not be computed. If the content of the file changes after this
    request was received but before a response could be sent, then an
    error of type CONTENT_MODIFIED will be generated.
    This request is intended to be used by clients that cannot
    asynchronously apply updated error information. Clients that
    can apply error information as it becomes available
    should use the information provided by the 'analysis.errors'
    notification.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_ERRORS_INVALID_FILE will be generated.
    */
    analysisGetErrors(request) {
        return this.sendRequest("analysis.getErrors", request);
    }
    /**
    Return the hover information associate with the given
    location. If some or all of the hover information is not
    available at the time this request is processed the
    information will be omitted from the response.
    */
    analysisGetHover(request) {
        return this.sendRequest("analysis.getHover", request);
    }
    /**
    Return a description of all of the elements referenced in a given region
    of a given file that come from imported libraries.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    GET_IMPORTED_ELEMENTS_INVALID_FILE will be generated.
    */
    analysisGetImportedElements(request) {
        return this.sendRequest("analysis.getImportedElements", request);
    }
    /**
    Return library dependency information for use in client-side indexing
    and package URI resolution.
    Clients that are only using the libraries field should consider using the
    analyzedFiles notification instead.
    */
    analysisGetLibraryDependencies() {
        return this.sendRequest("analysis.getLibraryDependencies");
    }
    /**
    Return the navigation information associated with the given region of
    the given file. If the navigation information for the given file has
    not yet been computed, or the most recently computed navigation
    information for the given file is out of date, then the response for
    this request will be delayed until it has been computed. If the
    content of the file changes after this request was received but before
    a response could be sent, then an error of type
    CONTENT_MODIFIED will be generated.
    If a navigation region overlaps (but extends either before or after)
    the given region of the file it will be included in the result. This
    means that it is theoretically possible to get the same navigation
    region in response to multiple requests. Clients can avoid this by
    always choosing a region that starts at the beginning of a line and
    ends at the end of a (possibly different) line in the file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_NAVIGATION_INVALID_FILE will be generated.
    */
    analysisGetNavigation(request) {
        return this.sendRequest("analysis.getNavigation", request);
    }
    /**
    Return the transitive closure of reachable sources for a given file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_REACHABLE_SOURCES_INVALID_FILE will be generated.
    */
    analysisGetReachableSources(request) {
        return this.sendRequest("analysis.getReachableSources", request);
    }
    /**
    Return the signature information associated with the given
    location in the given file. If the signature information
    for the given file has not yet been computed, or the most
    recently computed signature information for the given file
    is out of date, then the response for this request will be
    delayed until it has been computed.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_SIGNATURE_INVALID_FILE will be generated.
    If the location given is not inside the argument list for a
    function (including method and constructor) invocation, then
    an error of type GET_SIGNATURE_INVALID_OFFSET will
    be generated. If the location is inside an argument list but
    the function is not defined or cannot be determined (such as
    a method invocation where the target has type 'dynamic')
    then an error of type GET_SIGNATURE_UNKNOWN_FUNCTION
    will be generated.
    */
    analysisGetSignature(request) {
        return this.sendRequest("analysis.getSignature", request);
    }
    /**
    Force re-reading of all potentially changed files, re-resolving of all
    referenced URIs, and corresponding re-analysis of everything affected in
    the current analysis roots.
    */
    analysisReanalyze() {
        return this.sendRequest("analysis.reanalyze");
    }
    /**
    Sets the root paths used to determine which files to analyze. The set
    of files to be analyzed are all of the files in one of the root paths
    that are not either explicitly or implicitly excluded. A file is
    explicitly excluded if it is in one of the excluded paths. A file is
    implicitly excluded if it is in a subdirectory of one of the root
    paths where the name of the subdirectory starts with a period (that
    is, a hidden directory).
    Note that this request determines the set of requested
    analysis roots. The actual set of analysis roots at any
    given time is the intersection of this set with the set of
    files and directories actually present on the
    filesystem. When the filesystem changes, the actual set of
    analysis roots is automatically updated, but the set of
    requested analysis roots is unchanged. This means that if
    the client sets an analysis root before the root becomes
    visible to server in the filesystem, there is no error; once
    the server sees the root in the filesystem it will start
    analyzing it. Similarly, server will stop analyzing files
    that are removed from the file system but they will remain
    in the set of requested roots.
    If an included path represents a file, then server will look
    in the directory containing the file for a pubspec.yaml
    file. If none is found, then the parents of the directory
    will be searched until such a file is found or the root of
    the file system is reached. If such a file is found, it will
    be used to resolve package: URI’s within the file.
    */
    analysisSetAnalysisRoots(request) {
        return this.sendRequest("analysis.setAnalysisRoots", request);
    }
    /**
    Subscribe for general services (that is, services that are not
    specific to individual files). All previous subscriptions are replaced
    by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    analysisSetGeneralSubscriptions(request) {
        return this.sendRequest("analysis.setGeneralSubscriptions", request);
    }
    /**
    Set the priority files to the files in the given list. A
    priority file is a file that is given priority when
    scheduling which analysis work to do first. The list
    typically contains those files that are visible to the user
    and those for which analysis results will have the biggest
    impact on the user experience. The order of the files within
    the list is significant: the first file will be given higher
    priority than the second, the second higher priority than
    the third, and so on.
    Note that this request determines the set of requested
    priority files. The actual set of priority files is the
    intersection of the requested set of priority files with the
    set of files currently subject to analysis. (See
    analysis.setSubscriptions for a description of files that
    are subject to analysis.)
    If a requested priority file is a directory it is ignored,
    but remains in the set of requested priority files so that
    if it later becomes a file it can be included in the set of
    actual priority files.
    */
    analysisSetPriorityFiles(request) {
        return this.sendRequest("analysis.setPriorityFiles", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    analysisSetSubscriptions(request) {
        return this.sendRequest("analysis.setSubscriptions", request);
    }
    /**
    Update the content of one or more files. Files that were
    previously updated but not included in this update remain
    unchanged. This effectively represents an overlay of the
    filesystem. The files whose content is overridden are
    therefore seen by server as being files with the given
    content, even if the files do not exist on the filesystem or
    if the file path represents the path to a directory on the
    filesystem.
    */
    analysisUpdateContent(request) {
        return this.sendRequest("analysis.updateContent", request);
    }
    /**
    Deprecated: all of the options can be set by users in
    an analysis options file.
    Update the options controlling analysis based on the given
    set of options. Any options that are not included in the
    analysis options will not be changed. If there are options
    in the analysis options that are not valid, they will be
    silently ignored.
    */
    analysisUpdateOptions(request) {
        return this.sendRequest("analysis.updateOptions", request);
    }
    /**
    Request that completion suggestions for the given offset in
    the given file be returned.
    */
    completionGetSuggestions(request) {
        return this.sendRequest("completion.getSuggestions", request);
    }
    /**
    Subscribe for completion services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    completionSetSubscriptions(request) {
        return this.sendRequest("completion.setSubscriptions", request);
    }
    /**
    The client can make this request to express interest in certain
    libraries to receive completion suggestions from based on the client path.
    If this request is received before the client has used
    'completion.setSubscriptions' to subscribe to the AVAILABLE_SUGGESTION_SETS
    service, then an error of type NOT_SUBSCRIBED_TO_AVAILABLE_SUGGESTION_SETS
    will be generated. All previous paths are replaced by the given set of paths.
    */
    completionRegisterLibraryPaths(request) {
        return this.sendRequest("completion.registerLibraryPaths", request);
    }
    /**
    Clients must make this request when the user has selected a completion
    suggestion from an AvailableSuggestionSet. Analysis server will respond with
    the text to insert as well as any SourceChange that needs to be applied
    in case the completion requires an additional import to be added. It is an error
    if the id is no longer valid, for instance if the library has been removed after
    the completion suggestion is accepted.
    */
    completionGetSuggestionDetails(request) {
        return this.sendRequest("completion.getSuggestionDetails", request);
    }
    /**
    Perform a search for references to the element defined or
    referenced at the given offset in the given file.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindElementReferences(request) {
        return this.sendRequest("search.findElementReferences", request);
    }
    /**
    Perform a search for declarations of members whose name is
    equal to the given name.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberDeclarations(request) {
        return this.sendRequest("search.findMemberDeclarations", request);
    }
    /**
    Perform a search for references to members whose name is
    equal to the given name. This search does not check to see
    that there is a member defined with the given name, so it is
    able to find references to undefined members as well.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberReferences(request) {
        return this.sendRequest("search.findMemberReferences", request);
    }
    /**
    Perform a search for declarations of top-level elements
    (classes, typedefs, getters, setters, functions and fields)
    whose name matches the given pattern.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindTopLevelDeclarations(request) {
        return this.sendRequest("search.findTopLevelDeclarations", request);
    }
    /**
    Return top-level and class member declarations.
    */
    searchGetElementDeclarations(request) {
        return this.sendRequest("search.getElementDeclarations", request);
    }
    /**
    Return the type hierarchy of the class declared or
    referenced at the given location.
    */
    searchGetTypeHierarchy(request) {
        return this.sendRequest("search.getTypeHierarchy", request);
    }
    /**
    Format the contents of a single file. The currently selected region of
    text is passed in so that the selection can be preserved across the
    formatting operation. The updated selection will be as close to
    matching the original as possible, but whitespace at the beginning or
    end of the selected region will be ignored. If preserving selection
    information is not required, zero (0) can be specified for both the
    selection offset and selection length.
    If a request is made for a file which does not exist, or which is not
    currently subject to analysis (e.g. because it is not associated with
    any analysis root specified to analysis.setAnalysisRoots), an error of
    type FORMAT_INVALID_FILE will be generated. If the source
    contains syntax errors, an error of type FORMAT_WITH_ERRORS
    will be generated.
    */
    editFormat(request) {
        return this.sendRequest("edit.format", request);
    }
    /**
    Return the set of assists that are available at the given
    location. An assist is distinguished from a refactoring
    primarily by the fact that it affects a single file and does
    not require user input in order to be performed.
    */
    editGetAssists(request) {
        return this.sendRequest("edit.getAssists", request);
    }
    /**
    Get a list of the kinds of refactorings that are valid for
    the given selection in the given file.
    */
    editGetAvailableRefactorings(request) {
        return this.sendRequest("edit.getAvailableRefactorings", request);
    }
    /**
    Return the set of fixes that are available for the errors at
    a given offset in a given file.
    */
    editGetFixes(request) {
        return this.sendRequest("edit.getFixes", request);
    }
    /**
    Get the changes required to convert the postfix template at the given
    location into the template's expanded form.
    */
    editGetPostfixCompletion(request) {
        return this.sendRequest("edit.getPostfixCompletion", request);
    }
    /**
    Get the changes required to perform a refactoring.
    If another refactoring request is received during the processing
    of this one, an error of type REFACTORING_REQUEST_CANCELLED
    will be generated.
    */
    editGetRefactoring(request) {
        return this.sendRequest("edit.getRefactoring", request);
    }
    /**
    Get the changes required to convert the partial statement at the given
    location into a syntactically valid statement. If the current statement
    is already valid the change will insert a newline plus appropriate
    indentation at the end of the line containing the offset.
    If a change that makes the statement valid cannot be determined (perhaps
    because it has not yet been implemented) the statement will be considered
    already valid and the appropriate change returned.
    */
    editGetStatementCompletion(request) {
        return this.sendRequest("edit.getStatementCompletion", request);
    }
    /**
    Determine if the request postfix completion template is applicable at
    the given location in the given file.
    */
    editIsPostfixCompletionApplicable(request) {
        return this.sendRequest("edit.isPostfixCompletionApplicable", request);
    }
    /**
    Return a list of all postfix templates currently available.
    */
    editListPostfixCompletionTemplates() {
        return this.sendRequest("edit.listPostfixCompletionTemplates");
    }
    /**
    Return a list of edits that would need to be applied in order to ensure
    that all of the elements in the specified list of imported elements are
    accessible within the library.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    IMPORT_ELEMENTS_INVALID_FILE will be generated.
    */
    editImportElements(request) {
        return this.sendRequest("edit.importElements", request);
    }
    /**
    Sort all of the directives, unit and class members
    of the given Dart file.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    SORT_MEMBERS_INVALID_FILE will be generated.
    If the Dart file has scan or parse errors,
    SORT_MEMBERS_PARSE_ERRORS will be generated.
    */
    editSortMembers(request) {
        return this.sendRequest("edit.sortMembers", request);
    }
    /**
    Organizes all of the directives - removes unused imports and sorts
    directives of the given Dart file according to the
    Dart Style
    Guide.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    FILE_NOT_ANALYZED will be generated.
    If directives of the Dart file cannot be organized, for example
    because it has scan or parse errors, or by other reasons,
    ORGANIZE_DIRECTIVES_ERROR will be generated. The message
    will provide details about the reason.
    */
    editOrganizeDirectives(request) {
        return this.sendRequest("edit.organizeDirectives", request);
    }
    /**
    Create an execution context for the executable file with the given
    path. The context that is created will persist until
    execution.deleteContext is used to delete it. Clients, therefore, are
    responsible for managing the lifetime of execution contexts.
    */
    executionCreateContext(request) {
        return this.sendRequest("execution.createContext", request);
    }
    /**
    Delete the execution context with the given identifier. The context id
    is no longer valid after this command. The server is allowed to re-use
    ids when they are no longer valid.
    */
    executionDeleteContext(request) {
        return this.sendRequest("execution.deleteContext", request);
    }
    /**
    Request completion suggestions for the given runtime context.
    It might take one or two requests of this type to get completion
    suggestions. The first request should have only "code", "offset",
    and "variables", but not "expressions". If there are sub-expressions that
    can have different runtime types, and are considered to be safe to
    evaluate at runtime (e.g. getters), so using their actual runtime types
    can improve completion results, the server will not include the
    "suggestions" field in the response, and instead will return the
    "expressions" field. The client will use debug API to get current runtime
    types for these sub-expressions and send another request, this time with
    "expressions". If there are no interesting sub-expressions to get
    runtime types for, or when the "expressions" field is provided by the
    client, the server will return "suggestions" in the response.
    */
    executionGetSuggestions(request) {
        return this.sendRequest("execution.getSuggestions", request);
    }
    /**
    Map a URI from the execution context to the file that it corresponds
    to, or map a file to the URI that it corresponds to in the execution
    context.
    Exactly one of the file and uri fields must be provided. If both
    fields are provided, then an error of type INVALID_PARAMETER
    will be generated. Similarly, if neither field is provided, then an
    error of type INVALID_PARAMETER will be generated.
    If the file field is provided and the value is not the path of a file
    (either the file does not exist or the path references something other
    than a file), then an error of type INVALID_PARAMETER will
    be generated.
    If the uri field is provided and the value is not a valid URI or if
    the URI references something that is not a file (either a file that
    does not exist or something other than a file), then an error of type
    INVALID_PARAMETER will be generated.
    If the contextRoot used to create the execution context does not
    exist, then an error of type INVALID_EXECUTION_CONTEXT will
    be generated.
    */
    executionMapUri(request) {
        return this.sendRequest("execution.mapUri", request);
    }
    /**
    Deprecated: the analysis server no longer fires
    LAUNCH_DATA events.
    Subscribe for services. All previous subscriptions are replaced by the
    given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    executionSetSubscriptions(request) {
        return this.sendRequest("execution.setSubscriptions", request);
    }
    /**
    Return server diagnostics.
    */
    diagnosticGetDiagnostics() {
        return this.sendRequest("diagnostic.getDiagnostics");
    }
    /**
    Return the port of the diagnostic web server. If the server is not running
    this call will start the server. If unable to start the diagnostic web
    server,
    this call will return an error of DEBUG_PORT_COULD_NOT_BE_OPENED.
    */
    diagnosticGetServerPort() {
        return this.sendRequest("diagnostic.getServerPort");
    }
    /**
    Query whether analytics is enabled.
    This flag controls whether the analysis server sends any analytics data to
    the cloud. If disabled, the analysis server does not send any analytics
    data, and any data sent to it by clients (from sendEvent and
    sendTiming) will be ignored.
    The value of this flag can be changed by other tools outside of the
    analysis server's process. When you query the flag, you get the value of
    the flag at a given moment. Clients should not use the value returned to
    decide whether or not to send the sendEvent and
    sendTiming requests. Those requests should be used
    unconditionally and server will determine whether or not it is appropriate
    to forward the information to the cloud at the time each request is
    received.
    */
    analyticsIsEnabled() {
        return this.sendRequest("analytics.isEnabled");
    }
    /**
    Enable or disable the sending of analytics data. Note that there are other
    ways for users to change this setting, so clients cannot assume that they
    have complete control over this setting. In particular, there is no
    guarantee that the result returned by the isEnabled request will
    match the last value set via this request.
    */
    analyticsEnable(request) {
        return this.sendRequest("analytics.enable", request);
    }
    /**
    Send information about client events.
    Ask the analysis server to include the fact that an action was performed
    in the client as part of the analytics data being sent. The data will only
    be included if the sending of analytics data is enabled at the time the
    request is processed. The action that was performed is indicated by the
    value of the action field.
    The value of the action field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendEvent(request) {
        return this.sendRequest("analytics.sendEvent", request);
    }
    /**
    Send timing information for client events (e.g. code completions).
    Ask the analysis server to include the fact that a timed event occurred as
    part of the analytics data being sent. The data will only be included if
    the sending of analytics data is enabled at the time the request is
    processed.
    The value of the event field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendTiming(request) {
        return this.sendRequest("analytics.sendTiming", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    flutterSetSubscriptions(request) {
        return this.sendRequest("flutter.setSubscriptions", request);
    }
}
exports.AnalyzerGen = AnalyzerGen;


/***/ }),

/***/ 135:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzer = void 0;
const path = __importStar(__webpack_require__(6928));
const stream = __importStar(__webpack_require__(2203));
const vs = __importStar(__webpack_require__(1398));
const ls = __importStar(__webpack_require__(99));
const node_1 = __webpack_require__(2339);
const custom_protocol_1 = __webpack_require__(815);
const analyzer_1 = __webpack_require__(5244);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const fs_1 = __webpack_require__(2587);
const constants_2 = __webpack_require__(5706);
const dart_text_document_content_provider_1 = __webpack_require__(136);
const extension_utils_1 = __webpack_require__(6584);
const interactive_refactors_1 = __webpack_require__(2679);
const lsp_common_capabilities_1 = __webpack_require__(8683);
const lsp_uri_converters_1 = __webpack_require__(4601);
const status_bar_1 = __webpack_require__(719);
const utils_1 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const user_prompts_1 = __webpack_require__(3411);
const misc_1 = __webpack_require__(1166);
const processes_1 = __webpack_require__(8141);
const diagnostics_1 = __webpack_require__(5883);
const analyzer_2 = __webpack_require__(2423);
const analyzer_lsp_snippet_text_edits_1 = __webpack_require__(4533);
const file_tracker_lsp_1 = __webpack_require__(4896);
class LspAnalyzer extends analyzer_1.Analyzer {
    dartCapabilities;
    dtd;
    client;
    fileTracker;
    snippetTextEdits;
    refactors;
    dartTextDocumentContentProvider;
    statusItem = (0, status_bar_1.getLanguageStatusItem)("dart.analysisServer", constants_2.ANALYSIS_FILTERS);
    constructor(logger, sdks, dartCapabilities, wsContext, dtd) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.dartCapabilities = dartCapabilities;
        this.dtd = dtd;
        this.setupStatusItem();
        this.snippetTextEdits = new analyzer_lsp_snippet_text_edits_1.SnippetTextEditFeature(dartCapabilities);
        this.refactors = new interactive_refactors_1.InteractiveRefactors(logger, dartCapabilities);
        this.client = this.createClient(this.logger, sdks, dartCapabilities, wsContext, this.buildMiddleware());
        if (this.dartCapabilities.supportsMacroGeneratedFiles) {
            // Just because it's enabled doesn't mean the server actually supports it.
            this.dartTextDocumentContentProvider = new dart_text_document_content_provider_1.DartTextDocumentContentProviderFeature(logger, this.client, dartCapabilities);
            this.client.registerFeature(this.dartTextDocumentContentProvider.feature);
            this.disposables.push(this.dartTextDocumentContentProvider);
        }
        this.fileTracker = new file_tracker_lsp_1.LspFileTracker(logger, this.client, wsContext);
        this.client.registerFeature(new lsp_common_capabilities_1.CommonCapabilitiesFeature().feature);
        this.client.registerFeature(this.snippetTextEdits.feature);
        this.client.registerFeature(this.refactors.feature);
        this.disposables.push({ dispose: () => this.client.stop() });
        this.disposables.push(this.fileTracker);
        this.disposables.push(this.snippetTextEdits);
        this.disposables.push(this.refactors);
        void this.client.start().then(() => {
            this.statusItem.text = "Dart Analysis Server";
            // Reminder: These onNotification calls only hold ONE handler!
            // https://github.com/microsoft/vscode-languageserver-node/issues/174
            // TODO: Remove this once Dart/Flutter stable LSP servers are using $/progress.
            this.client.onNotification(custom_protocol_1.AnalyzerStatusNotification.type, (params) => {
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.isAnalyzing });
            });
            this.client.onNotification(custom_protocol_1.OpenUriNotification.type, (params) => {
                const uri = vs.Uri.parse(params.uri);
                switch (uri.scheme) {
                    case "file":
                        void vs.window.showTextDocument(uri);
                        break;
                    case "http":
                    case "https":
                        void utils_1.envUtils.openInBrowser(uri.toString());
                        break;
                    default:
                        console.error(`Unable to open URI ${uri} as requested by LSP server. Unknown scheme.`);
                }
            });
            this.onReadyCompleter.resolve();
            // If we have DTD, send it to the server.
            if (config_1.config.previewDtdLspIntegration && dtd !== null) {
                // TODO(dantup): Switch from a preview flag to using a server-provided capability. That capability is not
                //  yet available because we want to do more testing behind the preview flag first.
                const registerExperimentalHandlers = !!config_1.config.experimentalDtdHandlers;
                dtd?.dtdUri
                    .then((uri) => uri ? this.client.sendRequest(custom_protocol_1.ConnectToDtdRequest.type, { uri, registerExperimentalHandlers }) : undefined)
                    .catch((e) => this.logger.error(`Failed to call connectToDtd. Does this version of the SDK support it? ${e}`));
            }
        });
    }
    setupStatusItem() {
        const statusItem = this.statusItem;
        statusItem.text = "Dart Language Server Starting…";
        statusItem.command = {
            command: "dart.restartAnalysisServer",
            title: "restart",
            tooltip: "Restarts the Dart Language Server",
        };
    }
    buildMiddleware() {
        // Why need this 🤷‍♂️?
        function isLanguageValuePair(input) {
            return "language" in input && typeof input.language === "string" && "value" in input && typeof input.value === "string";
        }
        function cleanDocString(input) {
            if (input instanceof vs.MarkdownString)
                return (0, extension_utils_1.createMarkdownString)((0, extension_utils_1.cleanDartdoc)(input.value));
            else if (typeof input === "string")
                return (0, extension_utils_1.cleanDartdoc)(input);
            else if (isLanguageValuePair(input))
                return { language: input.language, value: (0, extension_utils_1.cleanDartdoc)(input.value) };
            else
                return input;
        }
        /// Whether or not to trigger completion again when completing on this item. This is used
        /// for convenience, eg. when completing the "import '';" snippet people expect completion
        /// to immediately reopen.
        function shouldTriggerCompletionAgain(item) {
            const label = typeof item.label === "string" ? item.label : item.label.label;
            if (label === "import '';")
                return true;
            // When completing on named args, re-trigger for the value.
            if (label.trimRight().endsWith(":"))
                return true;
            if (item.kind === vs.CompletionItemKind.Folder) {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                return label.endsWith("/");
            }
            return false;
        }
        const signatureHelpValidPattern = new RegExp("\\(\\${?[01]");
        /// Whether or not to trigger signature help on this item. This is used because if a user doesn't
        /// type the ( manually (but it's inserted as part of the completion) then the parameter hints do
        /// not show up.
        function shouldTriggerSignatureHelp(item) {
            let insertText;
            if (item.insertText) {
                if (typeof item.insertText === "string")
                    insertText = item.insertText;
                else
                    insertText = item.insertText.value;
            }
            else {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                insertText = label;
            }
            if (insertText && signatureHelpValidPattern.test(insertText))
                return true;
            return false;
        }
        const refactors = this.refactors;
        const snippetTextEdits = this.snippetTextEdits;
        const startTimer = (message) => {
            const startTime = process.hrtime();
            return {
                end: (endMessage) => {
                    const timeTaken = process.hrtime(startTime);
                    const timeTakenMs = Math.round(timeTaken[0] * 1000 + timeTaken[1] / 1000000);
                    this.logger.info(`[ ${timeTakenMs} ms ] ${message} ${endMessage}`.trim(), enums_1.LogCategory.AnalyzerTiming);
                },
            };
        };
        let isFirstAnalysisCompletion = true;
        return {
            handleWorkDoneProgress: (token, params, next) => {
                // TODO: Handle nested/overlapped progresses.
                if (token === "ANALYZING") {
                    if (params.kind === "begin") {
                        this.statusItem.busy = true;
                        this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: true, suppressProgress: true });
                    }
                    else if (params.kind === "end") {
                        if (isFirstAnalysisCompletion) {
                            isFirstAnalysisCompletion = false;
                            void (0, user_prompts_1.checkForLargeNumberOfTodos)(this.client.diagnostics);
                        }
                        this.statusItem.busy = false;
                        this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: false, suppressProgress: true });
                    }
                }
                next(token, params);
            },
            handleDiagnostics(uri, diagnostics, next) {
                for (const diagnostic of diagnostics) {
                    const errorCode = (0, diagnostics_1.getDiagnosticErrorCode)(diagnostic);
                    if (errorCode === "file_names") {
                        diagnostic.message += "\nYou may need to close the file and restart VS Code after renaming a file by only casing.";
                    }
                }
                next(uri, diagnostics);
            },
            provideCompletionItem: async (document, position, context, token, next) => {
                const range = document.getWordRangeAtPosition(position);
                const prefix = range ? document.getText(range) : undefined;
                const timer = startTimer(`Completion: ${prefix ?? ""}`);
                const results = await next(document, position, context, token);
                let items;
                let isIncomplete = false;
                // Handle either a CompletionItem[] or CompletionList.
                if (!results) {
                    items = [];
                }
                else if ("isIncomplete" in results) {
                    items = results.items;
                    isIncomplete = results.isIncomplete ?? false;
                }
                else {
                    items = results;
                }
                timer.end(`${items.length} results ${isIncomplete ? "(incomplete)" : ""} ${token.isCancellationRequested ? "(cancelled)" : ""}`);
                if (!items.length)
                    return;
                const parameterHintsEnabled = !!vs.workspace.getConfiguration("editor").get("parameterHints.enabled");
                for (const item of items) {
                    if (!item || !item.label) {
                        console.warn(`Got completion item with no label: ${JSON.stringify(item)}\n\nItem count: ${items.length}\nDocument: ${document.uri}\nPosition: ${position.line}:${position.character}`);
                    }
                    if (shouldTriggerCompletionAgain(item)) {
                        item.command = {
                            command: "editor.action.triggerSuggest",
                            title: "Suggest",
                        };
                    }
                    else if (parameterHintsEnabled && shouldTriggerSignatureHelp(item)) {
                        item.command = {
                            command: "editor.action.triggerParameterHints",
                            title: "Suggest",
                        };
                    }
                }
                return results;
            },
            async provideInlayHints(document, viewPort, token, next) {
                const hints = await next(document, viewPort, token);
                if (hints) {
                    for (const hint of hints) {
                        const pos = hint.position;
                        let isValid = pos.character >= 0;
                        const labelParts = Array.isArray(hint.label) ? hint.label : [];
                        for (const labelPart of labelParts) {
                            if (labelPart.location && (labelPart.location.range.start.character < 0 || labelPart.location.range.end.character < 0))
                                isValid = false;
                        }
                        if (!isValid)
                            console.warn(`Got invalid InlayHint from server: ${document.uri}, ${viewPort.start.line}:${viewPort.start.character}-${viewPort.end.line}:${viewPort.end.character} ${JSON.stringify(hint)}`);
                    }
                }
                return hints;
            },
            resolveCompletionItem: (item, token, next) => {
                if (item.documentation)
                    item.documentation = cleanDocString(item.documentation);
                return next(item, token);
            },
            provideHover: async (document, position, token, next) => {
                const item = await next(document, position, token);
                if (item?.contents)
                    item.contents = item.contents.map((s) => cleanDocString(s));
                return item;
            },
            async provideCodeActions(document, range, context, token, next) {
                const documentVersion = document.version;
                const res = await next(document, range, context, token) || [];
                snippetTextEdits.rewriteSnippetTextEditsToCommands(documentVersion, res);
                refactors.rewriteCommands(res);
                return res;
            },
            executeCommand: async (command, args, next) => {
                const validateCommand = command === "refactor.perform"
                    ? "refactor.validate"
                    : command === "dart.refactor.perform"
                        ? "dart.refactor.validate"
                        : undefined;
                if (validateCommand) {
                    // Handle both the old way (6 args as a list) and the new way (a single arg that's a map).
                    const mapArgsIndex = 0;
                    const listArgsKindIndex = 0;
                    const listArgsOptionsIndex = 5;
                    const isValidListArgs = args.length === 6;
                    const isValidMapsArgs = args.length === 1 && args[mapArgsIndex]?.path !== undefined;
                    if (args && (isValidListArgs || isValidMapsArgs)) {
                        const refactorFailedErrorCode = -32011;
                        const mapArgs = args[mapArgsIndex];
                        const refactorKind = isValidListArgs ? args[listArgsKindIndex] : mapArgs.kind;
                        // Intercept EXTRACT_METHOD and EXTRACT_WIDGET to prompt the user for a name, but first call the validation
                        // so we don't ask for a name if it will fail for a reason like a closure with an argument.
                        const willPrompt = refactorKind === "EXTRACT_METHOD" || refactorKind === "EXTRACT_WIDGET";
                        if (willPrompt) {
                            if (this.dartCapabilities.supportsRefactorValidate) {
                                try {
                                    const validateResult = await next(validateCommand, args);
                                    if (validateResult.valid === false) {
                                        void vs.window.showErrorMessage(validateResult.message);
                                        return;
                                    }
                                }
                                catch (e) {
                                    // If an error occurs, we'll just continue as if validation passed.
                                    this.logger.error(e);
                                }
                            }
                            let name;
                            switch (refactorKind) {
                                case "EXTRACT_METHOD":
                                    name = await vs.window.showInputBox({
                                        prompt: "Enter a name for the method",
                                        validateInput: (s) => constants_1.validMethodNameRegex.test(s) ? undefined : "Enter a valid method name",
                                        value: "newMethod",
                                    });
                                    if (!name)
                                        return;
                                    break;
                                case "EXTRACT_WIDGET":
                                    name = await vs.window.showInputBox({
                                        prompt: "Enter a name for the widget",
                                        validateInput: (s) => constants_1.validClassNameRegex.test(s) ? undefined : "Enter a valid widget name",
                                        value: "NewWidget",
                                    });
                                    if (!name)
                                        return;
                                    break;
                            }
                            if (name) {
                                if (isValidListArgs)
                                    args[listArgsOptionsIndex] = Object.assign({}, args[listArgsOptionsIndex], { name });
                                else
                                    args[0].options = Object.assign({}, args[0].options, { name });
                            }
                        }
                        // The server may return errors for things like invalid names, so
                        // capture the errors and present the error better if it's a refactor
                        // error.
                        try {
                            return await next(command, args);
                        }
                        catch (e) {
                            if (e?.code === refactorFailedErrorCode) {
                                void vs.window.showErrorMessage(e.message);
                                return;
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                }
                return next(command, args);
            },
            workspace: {
                configuration: async (params, token, next) => {
                    const results = await next(params, token);
                    if (Array.isArray(results)) {
                        for (const result of results) {
                            // Replace any instance of enableSnippets with the value of enableServerSnippets.
                            result.enableSnippets = config_1.config.enableServerSnippets && this.dartCapabilities.supportsServerSnippets;
                            // Flatten showTodos to a boolean if array not supported.
                            if (Array.isArray(result.showTodos) && !this.dartCapabilities.supportsShowTodoArray) {
                                result.showTodos = result.showTodos.length !== 0;
                            }
                            // Set default documentation and maxCompletionItems based on whether we're running locally or not.
                            // When running locally, payload size is less of an issue so we include full docs and a large list.
                            if (utils_1.isRunningLocally) {
                                result.maxCompletionItems = result.maxCompletionItems ?? 100000;
                                result.documentation = result.documentation ?? "full";
                            }
                            else {
                                result.maxCompletionItems = result.maxCompletionItems ?? 1000;
                                result.documentation = result.documentation ?? "none";
                            }
                        }
                    }
                    return results;
                },
            },
        };
    }
    async getDiagnosticServerPort() {
        return this.client.sendRequest(custom_protocol_1.DiagnosticServerRequest.type);
    }
    async forceReanalyze() {
        try {
            return await this.client.sendRequest(custom_protocol_1.ReanalyzeRequest.type);
        }
        catch (e) {
            void vs.window.showErrorMessage("Reanalyze is not supported by this version of the Dart SDK's LSP server.");
        }
    }
    async getSuper(params) {
        return this.client.sendRequest(custom_protocol_1.SuperRequest.type, params);
    }
    async getImports(params) {
        return this.client.sendRequest(custom_protocol_1.ImportsRequest.type, params);
    }
    async getAugmented(params) {
        return this.client.sendRequest(custom_protocol_1.AugmentedRequest.type, params);
    }
    async getAugmentation(params) {
        return this.client.sendRequest(custom_protocol_1.AugmentationRequest.type, params);
    }
    async completeStatement(params) {
        return this.client.sendRequest(custom_protocol_1.CompleteStatementRequest.type, params);
    }
    createClient(logger, sdks, dartCapabilities, wsContext, middleware) {
        const converters = new lsp_uri_converters_1.LspUriConverters(!!config_1.config.normalizeFileCasing);
        const clientOptions = {
            initializationOptions: {
                allowOpenUri: true,
                appHost: vs.env.appHost,
                closingLabels: config_1.config.closingLabels,
                completionBudgetMilliseconds: config_1.config.completionBudgetMilliseconds,
                flutterOutline: wsContext.hasAnyFlutterProjects,
                hostKind: utils_1.hostKind,
                onlyAnalyzeProjectsWithOpenFiles: config_1.config.onlyAnalyzeProjectsWithOpenFiles,
                outline: true,
                // For legacy SDKs, removed from server in https://dart-review.googlesource.com/c/sdk/+/349742
                // Can be removed in future when the SDKs that needed the flag is a small enough portion that
                // it's ok for them to not get the surveys.
                previewSurveys: true,
                remoteName: vs.env.remoteName,
                suggestFromUnimportedLibraries: config_1.config.autoImportCompletions,
                useInEditorDartFixPrompt: true,
            },
            markdown: {
                supportHtml: true,
            },
            middleware,
            outputChannelName: "LSP",
            revealOutputChannelOn: ls.RevealOutputChannelOn.Never,
            uriConverters: {
                // Don't just use "converters" here because LSP doesn't bind "this".
                code2Protocol: (uri) => converters.code2Protocol(uri),
                protocol2Code: (file) => converters.protocol2Code(file),
            },
        };
        const client = new node_1.LanguageClient("dartAnalysisLSP", "Dart Analysis Server", async () => {
            const streamInfo = await this.spawnServer(logger, sdks, dartCapabilities);
            const jsonEncoder = ls.RAL().applicationJson.encoder;
            return {
                detached: streamInfo.detached,
                reader: new node_1.StreamMessageReader(streamInfo.reader),
                writer: new node_1.StreamMessageWriter(streamInfo.writer, {
                    contentTypeEncoder: {
                        encode: (msg, options) => {
                            msg.clientRequestTime = Date.now();
                            return jsonEncoder.encode(msg, options);
                        },
                        name: "withTiming",
                    },
                }),
            };
        }, clientOptions);
        // HACK: Override the asCodeActionResult result to use our own custom asWorkspaceEdit so we can carry
        //       insertTextFormat from the protocol through to the middleware to handle snippets.
        //       This can be removed when we have a better way to do this.
        //       https://github.com/microsoft/vscode-languageserver-node/issues/1000
        const p2c = client._p2c; // eslint-disable-line no-underscore-dangle
        const originalAsWorkspaceEdit = p2c.asWorkspaceEdit; // eslint-disable-line @typescript-eslint/ban-types
        const originalAsCodeAction = p2c.asCodeAction; // eslint-disable-line @typescript-eslint/ban-types
        async function asWorkspaceEdit(item, token) {
            const result = (await originalAsWorkspaceEdit(item, token));
            if (!result)
                return;
            const snippetTypes = new Set();
            // Figure out which are Snippets.
            for (const change of item?.documentChanges ?? []) {
                if (ls.TextDocumentEdit.is(change)) {
                    const uri = vs.Uri.parse(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (edit.insertTextFormat === ls.InsertTextFormat.Snippet) {
                            snippetTypes.add(`${(0, fs_1.fsPath)(uri)}:${edit.newText}:${edit.range.start.line}:${edit.range.start.character}`);
                        }
                    }
                }
            }
            for (const uriString of Object.keys(item?.changes ?? {})) {
                const uri = vs.Uri.parse(uriString);
                for (const edit of item.changes[uriString]) {
                    if (edit.insertTextFormat === ls.InsertTextFormat.Snippet) {
                        snippetTypes.add(`${(0, fs_1.fsPath)(uri)}:${edit.newText}:${edit.range.start.line}:${edit.range.start.character}`);
                    }
                }
            }
            if (snippetTypes.size > 0) {
                for (const changeset of result.entries()) {
                    const uri = changeset[0];
                    const changes = changeset[1];
                    for (const change of changes) {
                        if (snippetTypes.has(`${(0, fs_1.fsPath)(uri)}:${change.newText}:${change.range.start.line}:${change.range.start.character}`)) {
                            change.insertTextFormat = ls.InsertTextFormat.Snippet;
                        }
                    }
                }
            }
            return result;
        }
        async function asCodeAction(item, token) {
            const result = (await originalAsCodeAction(item, token));
            if (item?.edit !== undefined) {
                result.edit = await asWorkspaceEdit(item.edit, token);
            }
            return result;
        }
        function asCodeActionResult(items, token) {
            return Promise.all(items.map(async (item) => {
                if (ls.Command.is(item)) {
                    return p2c.asCommand(item);
                }
                else {
                    return asCodeAction(item, token);
                }
            }));
        }
        p2c.asWorkspaceEdit = asWorkspaceEdit;
        p2c.asCodeAction = asCodeAction;
        p2c.asCodeActionResult = asCodeActionResult;
        return client;
    }
    spawnServer(logger, sdks, dartCapabilities) {
        // TODO: Replace with constructing an Analyzer that passes LSP flag (but still reads config
        // from paths etc) and provide it's process.
        const vmPath = path.join(sdks.dart, constants_1.dartVMPath);
        const args = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, true);
        logger.info(`Spawning ${vmPath} with args ${JSON.stringify(args)}`);
        const process = (0, processes_1.safeToolSpawn)(undefined, vmPath, args);
        // Ensure we terminate the process when shutting down even if the graceful shutdown
        // doesn't work. Wait a short period to give the graceful shutdown change.
        this.disposables.push({ dispose: () => { setTimeout(() => process.kill(), 100); } });
        logger.info(`    PID: ${process.pid}`);
        const reader = process.stdout.pipe(new LoggingTransform(logger, "<=="));
        const writer = new LoggingTransform(logger, "==>");
        writer.pipe(process.stdin);
        process.stderr.on("data", (data) => logger.error(data.toString()));
        process.on("exit", (code, signal) => {
            if (code)
                (0, misc_1.reportAnalyzerTerminatedWithError)();
        });
        return Promise.resolve({ reader, writer });
    }
}
exports.LspAnalyzer = LspAnalyzer;
class LoggingTransform extends stream.Transform {
    logger;
    prefix;
    constructor(logger, prefix, opts) {
        super(opts);
        this.logger = logger;
        this.prefix = prefix;
    }
    _transform(chunk, encoding, callback) {
        this.logger.info(`${this.prefix} ${chunk}`);
        this.push(chunk, encoding);
        callback();
    }
}


/***/ }),

/***/ 4533:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetTextEditFeature = void 0;
const vs = __importStar(__webpack_require__(1398));
const ls = __importStar(__webpack_require__(99));
const utils_1 = __webpack_require__(949);
const config_1 = __webpack_require__(7678);
class SnippetTextEditFeature {
    dartCapabilities;
    disposables = [];
    constructor(dartCapabilities) {
        this.dartCapabilities = dartCapabilities;
        this.disposables.push(vs.commands.registerCommand("_dart.applySnippetTextEdit", this.applySnippetTextEdit, this));
    }
    get feature() {
        const supportsSnippetTextEdits = this.dartCapabilities.supportsSnippetTextEdits;
        const snippetTextEditsEnabled = config_1.config.lspSnippetTextEdits;
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                capabilities.experimental = capabilities.experimental ?? {};
                if (supportsSnippetTextEdits && snippetTextEditsEnabled) {
                    capabilities.experimental.snippetTextEdit = true;
                }
            },
            getState() {
                return { kind: "static" };
            },
            initialize() { },
        };
    }
    rewriteSnippetTextEditsToCommands(documentVersion, res) {
        if (!res)
            return;
        for (const action of res) {
            if ("edit" in action) {
                const edit = action.edit;
                if (edit) {
                    const entries = edit.entries();
                    if (entries.length === 1 && entries[0][1].length === 1) {
                        const uri = entries[0][0];
                        const textEdit = entries[0][1][0];
                        // HACK: Check the injected insertTextFormat added in the asWorkspaceEdit overrides.
                        const hasSnippet = textEdit.insertTextFormat === ls.InsertTextFormat.Snippet;
                        // HACK: Work around the server producing 0th choice tabstops that are not valid until a
                        // server fix lands.
                        // https://github.com/Dart-Code/Dart-Code/issues/3996
                        if (hasSnippet
                            // Has a 0th choice snippet.
                            && textEdit.newText.includes("${0|")
                            && textEdit.newText.includes("|}")
                            // Does not have a 1st snippet.
                            && !textEdit.newText.includes("${1")
                            && !textEdit.newText.includes("$1")) {
                            // "Upgrade" choice from tabstop 0 to tabstop 1.
                            textEdit.newText = textEdit.newText.replace("${0|", "${1|");
                        }
                        if (hasSnippet) {
                            action.edit = undefined;
                            action.command = {
                                arguments: [documentVersion, uri, textEdit],
                                command: "_dart.applySnippetTextEdit",
                                title: "Apply edit",
                            };
                        }
                    }
                }
            }
        }
    }
    async applySnippetTextEdit(documentVersion, uri, edit) {
        const doc = await vs.workspace.openTextDocument(uri);
        const editor = await vs.window.showTextDocument(doc);
        if (doc.version !== documentVersion)
            void vs.window.showErrorMessage(`Unable to apply snippet, document was modified`);
        const leadingIndentCharacters = doc.lineAt(edit.range.start.line).firstNonWhitespaceCharacterIndex;
        const newText = this.compensateForVsCodeIndenting(edit.newText, leadingIndentCharacters);
        const snippet = new vs.SnippetString(newText);
        await editor.insertSnippet(snippet, edit.range);
    }
    compensateForVsCodeIndenting(newText, leadingIndentCharacters) {
        const indent = " ".repeat(leadingIndentCharacters);
        const indentPattern = new RegExp(`\n${indent}`, "g");
        return newText.replace(indentPattern, "\n");
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.SnippetTextEditFeature = SnippetTextEditFeature;


/***/ }),

/***/ 562:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(1398);
const enums_1 = __webpack_require__(3962);
const utils_1 = __webpack_require__(949);
const extension_utils_1 = __webpack_require__(6584);
const config_1 = __webpack_require__(7678);
const utils_2 = __webpack_require__(279);
const maxErrorReportCount = 3;
const sendFakeErrorAtStartup = false;
let errorCount = 0;
class AnalyzerStatusReporter {
    logger;
    analyzer;
    workspaceContext;
    analytics;
    analysisInProgress = false;
    analyzingPromise;
    constructor(logger, analyzer, workspaceContext, analytics) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.workspaceContext = workspaceContext;
        this.analytics = analytics;
        // TODO: Should these go in disposables?
        // If so, do we need to worry about server cleaning them up if it disposes first?
        analyzer.registerForServerStatus((n) => this.handleServerStatus(n));
        analyzer.registerForServerError((e) => this.handleServerError(e));
        analyzer.registerForRequestError((e) => this.handleRequestError(e));
        analyzer.registerForServerTerminated(() => this.handleServerTerminated());
        if (sendFakeErrorAtStartup) {
            setTimeout(() => {
                this.handleServerError({
                    isFatal: false,
                    message: "This is a fake error for testing the error reporting!",
                    stackTrace: new Error().stack || "",
                }, "testError");
            }, 5000);
        }
    }
    handleServerStatus(status) {
        if (!status.analysis)
            return;
        this.analysisInProgress = status.analysis.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 500);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
    handleServerTerminated() {
        this.analysisInProgress = false;
        if (this.analyzingPromise) {
            this.analyzingPromise.resolve();
            this.analyzingPromise = undefined;
        }
    }
    handleRequestError(error) {
        // Map this request error to a server error to reuse the shared code.
        this.handleServerError({
            isFatal: false,
            message: error.message,
            stackTrace: error.stackTrace || "",
        }, error.method);
    }
    handleServerError(error, method) {
        // Always log to the console.
        this.logger.error(error.message, enums_1.LogCategory.Analyzer);
        if (error.stackTrace)
            this.logger.error(error.stackTrace, enums_1.LogCategory.Analyzer);
        errorCount++;
        // Offer to report the error.
        if (config_1.config.notifyAnalyzerErrors && errorCount <= maxErrorReportCount) {
            const showLog = "Show log";
            void vscode_1.window.showErrorMessage(`Exception from the Dart analysis server: ${error.message}`, showLog).then((res) => {
                if (res === showLog)
                    void this.showErrorLog(error, method);
            });
        }
    }
    async showErrorLog(error, method) {
        const sdkVersion = this.workspaceContext.sdks.dartVersion;
        const flutterSdkVersion = this.workspaceContext.sdks.flutterVersion;
        const analyzerArgs = this.analyzer.getAnalyzerLaunchArgs();
        const data = `
${method ? "### Request\n\nServer was responding to request: `" + method + "`\n" : ""}
### Versions

- ${vscode_1.env.appName} v${vscode_1.version}
- Dart Code v${extension_utils_1.extensionVersion}
- ${flutterSdkVersion ? `Flutter SDK v${flutterSdkVersion}` : `Dart SDK v${sdkVersion}`}

### Analyzer Info

The analyzer was launched using the arguments:

${analyzerArgs.map((a) => `- ${a}`).join("\n")}

### Exception${error.isFatal ? " (fatal)" : ""}

${error.message}

${error.stackTrace.trim()}
`;
        await (0, utils_2.openLogContents)("md", data);
    }
}
exports.AnalyzerStatusReporter = AnalyzerStatusReporter;


/***/ }),

/***/ 377:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeHandler = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const util = __importStar(__webpack_require__(279));
class FileChangeHandler {
    analyzer;
    disposables = [];
    filesWarnedAbout = new Set();
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables.push(vs.workspace.onDidOpenTextDocument((td) => this.onDidOpenTextDocument(td)), vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)), vs.workspace.onDidCloseTextDocument((td) => this.onDidCloseTextDocument(td)));
        // Handle already-open files.
        vs.workspace.textDocuments.forEach((td) => this.onDidOpenTextDocument(td));
    }
    onDidOpenTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            content: document.getText(),
            type: "add",
        };
        void this.analyzer.analysisUpdateContent({ files });
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const files = {};
        files[(0, fs_1.fsPath)(e.document.uri)] = {
            edits: e.contentChanges.map((c) => this.convertChange(e.document, c)),
            type: "change",
        };
        void this.analyzer.analysisUpdateContent({ files });
    }
    onDidCloseTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            type: "remove",
        };
        void this.analyzer.analysisUpdateContent({ files });
    }
    convertChange(document, change) {
        return {
            id: "",
            length: change.rangeLength,
            offset: change.rangeOffset,
            replacement: change.text,
        };
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeHandler = FileChangeHandler;


/***/ }),

/***/ 2488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeWarnings = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const util = __importStar(__webpack_require__(279));
class FileChangeWarnings {
    disposables = [];
    filesWarnedAbout = new Set();
    constructor() {
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)));
    }
    onDidChangeTextDocument(e) {
        if (!util.isDartFile((0, fs_1.fsPath)(e.document.uri)))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const filePath = (0, fs_1.fsPath)(e.document.uri);
        if (vs.workspace.workspaceFolders
            && vs.workspace.workspaceFolders.length // Only prompt if we actually have workspace folders open
            && !util.isWithinWorkspace(filePath)
            && !this.filesWarnedAbout.has(filePath)) {
            const isInPubCache = filePath.includes(`${path.sep}hosted${path.sep}pub.dartlang.org${path.sep}`);
            const shouldWarn = isInPubCache
                ? config_1.config.warnWhenEditingFilesInPubCache
                : config_1.config.warnWhenEditingFilesOutsideWorkspace;
            const promptText = isInPubCache
                ? "You are modifying a file in the Pub cache!"
                : "You are modifying a file outside of your open folders";
            const dontShowAgainSetter = isInPubCache
                ? () => config_1.config.setWarnWhenEditingFilesInPubCache(false)
                : () => config_1.config.setWarnWhenEditingFilesOutsideWorkspace(false);
            const dontShowAgainAction = "Don't Warn Me";
            if (shouldWarn) {
                void vs.window.showWarningMessage(promptText, constants_1.moreInfoAction, dontShowAgainAction)
                    .then(async (action) => {
                    if (action === constants_1.moreInfoAction) {
                        await utils_2.envUtils.openInBrowser(constants_1.modifyingFilesOutsideWorkspaceInfoUrl);
                    }
                    else if (action === dontShowAgainAction)
                        void dontShowAgainSetter();
                });
                this.filesWarnedAbout.add(filePath);
            }
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeWarnings = FileChangeWarnings;


/***/ }),

/***/ 7583:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DasFileTracker = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const document_cache_1 = __webpack_require__(2524);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const project_1 = __webpack_require__(5143);
const util = __importStar(__webpack_require__(279));
class DasFileTracker {
    logger;
    analyzer;
    wsContext;
    disposables = [];
    navigations = new document_cache_1.DocumentCache();
    outlines = new document_cache_1.DocumentCache();
    flutterOutlines = new document_cache_1.DocumentCache();
    occurrences = new document_cache_1.DocumentCache();
    folding = new document_cache_1.DocumentCache();
    pubRunTestSupport = new document_cache_1.DocumentCache();
    lastPriorityFiles = [];
    lastSubscribedFiles = [];
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        // Reset these, since they're state from the last analysis server
        // (when we change SDK and thus change this).
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        this.disposables.push(vscode_1.workspace.onDidOpenTextDocument(async (td) => {
            await this.updateSubscriptions();
        }));
        this.disposables.push(vscode_1.workspace.onDidCloseTextDocument(async (td) => {
            const uri = td.uri;
            this.navigations.delete(uri);
            this.outlines.delete(uri);
            this.flutterOutlines.delete(uri);
            this.occurrences.delete(uri);
            this.folding.delete(uri);
            this.pubRunTestSupport.delete(uri);
            await this.updateSubscriptions();
        }));
        this.disposables.push(vscode_1.window.onDidChangeVisibleTextEditors((e) => this.updatePriorityFiles()));
        this.disposables.push(this.analyzer.registerForAnalysisNavigation((n) => this.navigations.set(vscode_1.Uri.file(n.file), n)));
        this.disposables.push(this.analyzer.registerForAnalysisOutline((o) => this.outlines.set(vscode_1.Uri.file(o.file), o.outline)));
        this.disposables.push(this.analyzer.registerForFlutterOutline((o) => this.flutterOutlines.set(vscode_1.Uri.file(o.file), o.outline)));
        this.disposables.push(this.analyzer.registerForAnalysisOccurrences((o) => this.occurrences.set(vscode_1.Uri.file(o.file), o.occurrences)));
        this.disposables.push(this.analyzer.registerForAnalysisFolding((f) => this.folding.set(vscode_1.Uri.file(f.file), f.regions)));
        // It's possible that after the server gives us the version, we may send different subscriptions (eg.
        // based on capabilities, like supporting priority files outside of the workspace root) so we may need
        // to send again.
        this.disposables.push(this.analyzer.registerForServerConnected((s) => this.updateSubscriptions(true)));
        // Handle already-open files.
        void this.updatePriorityFiles();
        void this.updateSubscriptions();
        this.watchPubspec();
    }
    async updatePriorityFiles() {
        const visibleFiles = this.validPathsFor(vscode_1.window.visibleTextEditors.map((editor) => editor.document));
        if (!this.pathsHaveChanged(this.lastPriorityFiles, visibleFiles))
            return;
        // Keep track of files to compare next time.
        this.lastPriorityFiles = visibleFiles;
        // Set priority files.
        try {
            await this.analyzer.analysisSetPriorityFiles({ files: visibleFiles });
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    async updateSubscriptions(force = false) {
        const openFiles = this.validPathsFor(vscode_1.workspace.textDocuments);
        if (!force && !this.pathsHaveChanged(this.lastSubscribedFiles, openFiles))
            return;
        // Keep track of files to compare next time.
        this.lastSubscribedFiles = openFiles;
        // Set subscriptions.
        try {
            await this.analyzer.analysisSetSubscriptions({
                subscriptions: {
                    CLOSING_LABELS: this.analyzer.capabilities.supportsClosingLabels ? openFiles : undefined,
                    // TODO(dantup): Why are we checking this here? This class is DAS-specific?
                    FOLDING: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                    NAVIGATION: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                    OCCURRENCES: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                    OUTLINE: openFiles,
                },
            });
        }
        catch (e) {
            this.logger.error(e);
        }
        // Set subscriptions.
        if (this.wsContext.hasAnyFlutterProjects && this.analyzer.capabilities.supportsFlutterOutline) {
            try {
                await this.analyzer.flutterSetSubscriptions({
                    subscriptions: {
                        OUTLINE: openFiles,
                    },
                });
            }
            catch (e) {
                this.logger.error(e);
            }
        }
    }
    pathsHaveChanged(last, current) {
        return last.length !== current.length
            || last.some((f, i) => f !== current[i]);
    }
    validPathsFor(paths) {
        const isAnalyzeable = this.analyzer.capabilities.supportsPriorityFilesOutsideAnalysisRoots
            ? util.isAnalyzable
            : util.isAnalyzableAndInWorkspace;
        return paths
            .filter((doc) => !doc.isClosed && isAnalyzeable(doc))
            .map((doc) => (0, fs_1.fsPath)(doc.uri))
            .sort((path1, path2) => path1.localeCompare(path2));
    }
    getNavigationTargets(file, offset) {
        // Synthesize an AnalysisGetNavigationResponse based on our existing knowledge about navigation links in the file.
        const notification = this.navigations.get(vscode_1.Uri.file(file));
        const region = notification?.regions?.find((region) => this.offsetWithinNavigationRegion(region, offset));
        if (!region || !notification)
            return undefined;
        return {
            files: notification.files,
            regions: [region],
            targets: notification.targets,
        };
    }
    offsetWithinNavigationRegion(region, offset) {
        return offset >= region.offset && offset < region.offset + region.length;
    }
    getOutlineFor(uri) {
        return this.outlines.get(uri);
    }
    async waitForOutlineWithLength(uri, length, token) {
        return (0, promises_1.waitFor)(() => {
            const outline = this.outlines.get(uri);
            return outline?.length === length ? outline : undefined;
        }, 50, 5000, token);
    }
    getFlutterOutlineFor(uri) {
        return this.flutterOutlines.get(uri);
    }
    async waitForFlutterOutlineWithLength(uri, length, token) {
        return (0, promises_1.waitFor)(() => {
            const outline = this.flutterOutlines.get(uri);
            return outline?.length === length ? outline : undefined;
        }, 50, 5000, token);
    }
    getOccurrencesFor(uri) {
        return this.occurrences.get(uri);
    }
    supportsPubRunTest(uri) {
        // TODO: Both FileTrackers have a copy of this!
        const path = (0, fs_1.fsPath)(uri);
        if (!util.isRunnableTestFile(path))
            return false;
        if (!this.pubRunTestSupport.has(uri)) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(path);
            this.pubRunTestSupport.set(uri, !!(projectRoot && util.projectCanUsePackageTest(projectRoot, this.wsContext.config)));
        }
        return this.pubRunTestSupport.get(uri);
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => this.pubRunTestSupport.clear();
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    getFoldingRegionsFor(uri) {
        return this.folding.get(uri);
    }
    getLastPriorityFiles() {
        return this.lastPriorityFiles.slice();
    }
    getLastSubscribedFiles() {
        return this.lastSubscribedFiles.slice();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DasFileTracker = DasFileTracker;


/***/ }),

/***/ 4896:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFileTracker = void 0;
const vscode_1 = __webpack_require__(1398);
const custom_protocol_1 = __webpack_require__(815);
const events_1 = __webpack_require__(9495);
const utils_1 = __webpack_require__(949);
const document_cache_1 = __webpack_require__(2524);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const utils_2 = __webpack_require__(1894);
const project_1 = __webpack_require__(5143);
const util = __importStar(__webpack_require__(279));
class LspFileTracker {
    logger;
    analyzer;
    wsContext;
    disposables = [];
    outlines = new document_cache_1.DocumentCache();
    flutterOutlines = new document_cache_1.DocumentCache();
    pubRunTestSupport = new document_cache_1.DocumentCache();
    onOutlineEmitter = new events_1.EventEmitter();
    onOutline = this.onOutlineEmitter.event;
    onFlutterOutlineEmitter = new events_1.EventEmitter();
    onFlutterOutline = this.onFlutterOutlineEmitter.event;
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        void analyzer.start().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishOutlineNotification.type, (n) => {
                const uri = vscode_1.Uri.parse(n.uri);
                this.outlines.set(uri, n.outline);
                this.onOutlineEmitter.fire(n);
            });
            this.analyzer.onNotification(custom_protocol_1.PublishFlutterOutlineNotification.type, (n) => {
                const uri = vscode_1.Uri.parse(n.uri);
                this.flutterOutlines.set(uri, n.outline);
                this.onFlutterOutlineEmitter.fire(n);
            });
        });
        this.watchPubspec();
    }
    getOutlineFor(uri) {
        return this.outlines.get(uri);
    }
    async waitForOutline(document, token) {
        return (0, promises_1.waitFor)(() => this.outlines.get(document.uri), 50, 5000, token);
    }
    // TODO: Change this to withVersion when server sends versions.
    async waitForOutlineWithLength(document, length, token) {
        return (0, promises_1.waitFor)(() => {
            const outline = this.outlines.get(document.uri);
            return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
        }, 50, 5000, token);
    }
    getFlutterOutlineFor(uri) {
        return this.flutterOutlines.get(uri);
    }
    // TODO: Change this to withVersion when server sends versions.
    async waitForFlutterOutlineWithLength(document, length, token) {
        return (0, promises_1.waitFor)(() => {
            const outline = this.flutterOutlines.get(document.uri);
            return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
        }, 50, 5000, token);
    }
    supportsPackageTest(uri) {
        // Handle explicit flags.
        if (this.wsContext.config.supportsPackageTest === true)
            return true;
        else if (this.wsContext.config.supportsPackageTest === false)
            return false;
        // TODO: Both FileTrackers have a copy of this!
        const filePath = (0, fs_1.fsPath)(uri);
        if (!util.isRunnableTestFile(filePath))
            return false;
        if (!this.pubRunTestSupport.has(uri)) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(filePath);
            this.pubRunTestSupport.set(uri, !!(projectRoot && util.projectCanUsePackageTest(projectRoot, this.wsContext.config)));
        }
        return this.pubRunTestSupport.get(uri);
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => this.pubRunTestSupport.clear();
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFileTracker = LspFileTracker;


/***/ }),

/***/ 5922:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloneSdkResult = exports.AddSdkToPathResult = exports.DebugAdapterExceptionSettingTrackerFactory = exports.Analytics = exports.AnalyticsEvent = void 0;
const fs = __importStar(__webpack_require__(9896));
const https = __importStar(__webpack_require__(5692));
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const workspace_1 = __webpack_require__(5851);
const extension_utils_1 = __webpack_require__(6584);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
// Set to true for analytics to be sent to the debug endpoint (non-logging) for validation.
// This is only required for debugging analytics and needn't be sent for standard Dart Code development (dev hits are already filtered with isDevelopment).
const debugMode = false;
/// Analytics require that we send a value for uid or cid, but when running in the VS Code
// dev host we don't have either.
const sendAnalyticsFromExtensionDevHost = false;
// Machine ID is not set for extension dev host unless the boolean above is set to true (which
// is usually done for testing purposes).
const machineId = vscode_1.env.machineId !== "someValue.machineId"
    ? vscode_1.env.machineId
    : (sendAnalyticsFromExtensionDevHost ? "35009a79-1a05-49d7-dede-dededededede" : undefined);
const sessionId = (0, fs_1.getRandomInt)(0x1000, 0x100000).toString(16);
const sessionStartMs = new Date().getTime();
var AnalyticsEvent;
(function (AnalyticsEvent) {
    AnalyticsEvent[AnalyticsEvent["Extension_Activated"] = 0] = "Extension_Activated";
    AnalyticsEvent[AnalyticsEvent["Extension_Restart"] = 1] = "Extension_Restart";
    AnalyticsEvent[AnalyticsEvent["SdkDetectionFailure"] = 2] = "SdkDetectionFailure";
    AnalyticsEvent[AnalyticsEvent["Debugger_Activated"] = 3] = "Debugger_Activated";
    AnalyticsEvent[AnalyticsEvent["DevTools_Opened"] = 4] = "DevTools_Opened";
    AnalyticsEvent[AnalyticsEvent["FlutterSurvey_Shown"] = 5] = "FlutterSurvey_Shown";
    AnalyticsEvent[AnalyticsEvent["FlutterSurvey_Clicked"] = 6] = "FlutterSurvey_Clicked";
    AnalyticsEvent[AnalyticsEvent["FlutterSurvey_Dismissed"] = 7] = "FlutterSurvey_Dismissed";
    AnalyticsEvent[AnalyticsEvent["FlutterOutline_Activated"] = 8] = "FlutterOutline_Activated";
    AnalyticsEvent[AnalyticsEvent["Command_AddSdkToPath"] = 9] = "Command_AddSdkToPath";
    AnalyticsEvent[AnalyticsEvent["ExtensionRecommendation_Shown"] = 10] = "ExtensionRecommendation_Shown";
    AnalyticsEvent[AnalyticsEvent["ExtensionRecommendation_Accepted"] = 11] = "ExtensionRecommendation_Accepted";
    AnalyticsEvent[AnalyticsEvent["ExtensionRecommendation_Rejected"] = 12] = "ExtensionRecommendation_Rejected";
    AnalyticsEvent[AnalyticsEvent["Command_CloneSdk"] = 13] = "Command_CloneSdk";
    AnalyticsEvent[AnalyticsEvent["Command_DartNewProject"] = 14] = "Command_DartNewProject";
    AnalyticsEvent[AnalyticsEvent["Command_FlutterNewProject"] = 15] = "Command_FlutterNewProject";
    AnalyticsEvent[AnalyticsEvent["Command_FlutterDoctor"] = 16] = "Command_FlutterDoctor";
    AnalyticsEvent[AnalyticsEvent["Command_AddDependency"] = 17] = "Command_AddDependency";
    AnalyticsEvent[AnalyticsEvent["Command_RestartAnalyzer"] = 18] = "Command_RestartAnalyzer";
    AnalyticsEvent[AnalyticsEvent["Command_ForceReanalyze"] = 19] = "Command_ForceReanalyze";
    AnalyticsEvent[AnalyticsEvent["Error_FlutterDaemonTimeout"] = 20] = "Error_FlutterDaemonTimeout";
})(AnalyticsEvent || (exports.AnalyticsEvent = AnalyticsEvent = {}));
class GoogleAnalyticsTelemetrySender {
    logger;
    handleError;
    constructor(logger, handleError) {
        this.logger = logger;
        this.handleError = handleError;
    }
    sendEventData(eventName, data) {
        if (!data)
            return;
        this.send(data).catch((e) => this.handleError(e));
    }
    sendErrorData(error, data) {
        // No errors are collected.
    }
    async send(data) {
        const analyticsData = {
            // Everything listed here should be in the 'telemetry.json' file in the extension root.
            client_id: machineId, // eslint-disable-line camelcase
            events: [{
                    name: data.event,
                    params: {
                        addSdkToPathResult: data.addSdkToPathResult,
                        cloneSdkResult: data.cloneSdkResult,
                        commandSource: data.commandSource,
                        data: data.data,
                        debuggerAdapterType: data.debuggerAdapterType,
                        debuggerExceptionBreakMode: data.debuggerExceptionBreakMode,
                        debuggerPreference: data.debuggerPreference,
                        debuggerRunType: data.debuggerRunType,
                        debuggerType: data.debuggerType,
                        // GA4 doesn't record any users unless there is non-zero engagement time.
                        // eslint-disable-next-line camelcase
                        engagement_time_msec: new Date().getTime() - sessionStartMs,
                        // eslint-disable-next-line camelcase
                        session_id: sessionId,
                    },
                }],
            user_properties: this.buildUserProperties(data), // eslint-disable-line camelcase
        };
        if (debugMode)
            this.logger.info("Sending analytic: " + JSON.stringify(analyticsData));
        const options = {
            headers: {
                "Content-Type": "application/json",
            },
            hostname: "www.google-analytics.com",
            method: "POST",
            path: (debugMode ? "/debug/mp/collect" : "/mp/collect")
                // Not really secret, is it...
                + "?api_secret=Y7bcxwkTQ-ekVL0ys4htBA&measurement_id=G-WXNLFN7DDJ",
            port: 443,
        };
        await new Promise((resolve, reject) => {
            const req = https.request(options, (resp) => {
                if (debugMode) {
                    const chunks = [];
                    resp.on("data", (b) => chunks.push(b.toString()));
                    resp.on("end", () => {
                        const json = chunks.join("");
                        try {
                            const gaDebugResp = JSON.parse(json);
                            if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === true)
                                this.logger.info("Sent OK!");
                            else if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === false)
                                this.logger.warn(json);
                            else
                                this.logger.warn(`Unexpected GA debug response: ${json}`);
                        }
                        catch (e) {
                            this.logger.warn(`Error in GA debug response: ${e?.message ?? e} ${json}`);
                        }
                    });
                }
                if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                    this.logger.info(`Failed to send analytics ${resp && resp.statusCode}: ${resp && resp.statusMessage}`);
                }
                resolve();
            });
            req.write(JSON.stringify(analyticsData));
            req.on("error", (e) => {
                reject(e);
            });
            req.end();
        });
    }
    buildUserProperties(data) {
        const dataMap = data;
        const userProperties = {};
        function add(name, value) {
            if (value)
                userProperties[name] = { value };
        }
        add("analyzerProtocol", data.analyzerProtocol);
        add("appName", data.appName ?? "Unknown");
        add("closingLabels", data.closingLabels);
        add("appVersionRaw", dataMap["common.extversion"]);
        add("appVersion", (0, workspace_1.simplifyVersion)(dataMap["common.extversion"]));
        add("codeVersionRaw", dataMap["common.vscodeversion"]);
        add("codeVersion", (0, workspace_1.simplifyVersion)(dataMap["common.vscodeversion"]));
        add("dartVersionRaw", data.dartVersion);
        add("dartVersion", (0, workspace_1.simplifyVersion)(data.dartVersion));
        add("flutterVersionRaw", data.flutterVersion);
        add("flutterVersion", (0, workspace_1.simplifyVersion)(data.flutterVersion));
        add("extensionName", dataMap["common.extname"]);
        add("flutterExtension", data.flutterExtension);
        add("flutterHotReloadOnSave", data.flutterHotReloadOnSave);
        add("flutterUiGuides", data.flutterUiGuides);
        add("formatter", data.formatter);
        add("extensionKind", data.extensionKind);
        add("platform", data.platform);
        add("hostKind", data.hostKind ?? "desktop");
        add("showTodos", data.showTodos);
        add("userLanguage", data.language);
        add("workspaceType", data.workspaceType);
        return userProperties;
    }
}
class Analytics {
    logger;
    disposables = [];
    sdkVersion;
    flutterSdkVersion;
    formatter;
    // If analytics fail or we see an opt-out for Dart/Flutter, disable for the rest of this session.
    disableAnalyticsForSession = false;
    // Some things we only want to log the first use per session to get an idea of
    // number of sessions using.
    hasLoggedFlutterOutline = false;
    telemetryLogger;
    exceptionBreakTrackerFactory;
    workspaceContext;
    constructor(logger) {
        this.logger = logger;
        this.formatter = this.getFormatterSetting();
        this.exceptionBreakTrackerFactory = new DebugAdapterExceptionSettingTrackerFactory();
        this.disposables.push(vscode_1.debug.registerDebugAdapterTrackerFactory("dart", this.exceptionBreakTrackerFactory));
        // If the API isn't supported (Theia) then we'll just not set anything up.
        if (!vscode_1.env.createTelemetryLogger) {
            this.logger.info(`createTelemetryLogger is unsupported`);
            return;
        }
        // Similarly, if the user has opted out of Dart/Flutter's telemetry, we should assume they might
        // (reasonably) expect that covers this extension, so don't set anything up in that case either.
        if (this.isOptedOutOfDartToolingTelemetry())
            return;
        if (!vscode_1.env.isTelemetryEnabled) {
            this.logger.info(`VS Code telemetry is disabled, analytics events will not be sent unless re-enabled`);
            // Don't return, as we check this on each event.
        }
        const googleAnalyticsTelemetrySender = new GoogleAnalyticsTelemetrySender(logger, (e) => this.handleError(e));
        this.telemetryLogger = vscode_1.env.createTelemetryLogger(googleAnalyticsTelemetrySender);
    }
    /// If a user opts-out of Dart/Flutter telemetry with the command line apps, also opt-out here to avoid
    /// confusion between Dart/Flutter analytics being reported to Google and extension analytics going
    /// to Dart Code. The prompt from the analysis server mentions "VS Code IDE plugins" which suggests the
    /// mechanism for opting out would apply to Dart Code.
    isOptedOutOfDartToolingTelemetry() {
        // Don't let this function ever throw.
        try {
            const configDirectory = constants_1.isWin ? process.env.USERPROFILE : process.env.HOME;
            if (!configDirectory) {
                this.logger.warn(`No valid home dir to check Dart/Flutter analytics file, disabling analytics`);
                return true;
            }
            const configFile = path.join(configDirectory, ".dart-tool", "dart-flutter-telemetry.config");
            if (!fs.existsSync(configFile)) {
                return false; // No file, means not opted out.
            }
            const configFileContents = fs.readFileSync(configFile).toString();
            const optedOutRegex = /^reporting=0/m;
            if (optedOutRegex.test(configFileContents)) {
                this.logger.info(`Dart/Flutter tooling telemetry is opted-out, disabling for Dart Code`);
                return true;
            }
            return false;
        }
        catch (e) {
            this.logger.warn(`Failed to check Dart/Flutter analytics file, disabling analytics: ${e}`);
            return true;
        }
    }
    event(category, customData) {
        if (this.disableAnalyticsForSession
            || !this.telemetryLogger
            || !machineId
            || !config_1.config.allowAnalytics /* Kept for users that opted-out when we used own flag */
            || this.workspaceContext?.config.disableAnalytics
            || !vscode_1.env.isTelemetryEnabled
            || constants_1.isDartCodeTestRun)
            return;
        const flutterUiGuides = this.workspaceContext?.hasAnyFlutterProjects
            ? (config_1.config.previewFlutterUiGuides ? (config_1.config.previewFlutterUiGuidesCustomTracking ? "On + Custom Tracking" : "On") : "Off")
            : undefined;
        const data = {
            analyzerProtocol: this.workspaceContext?.config.useLegacyProtocol ? "DAS" : "LSP",
            anonymize: true,
            appName: vscode_1.env.appName,
            closingLabels: config_1.config.closingLabels ? "On" : "Off",
            dartVersion: this.sdkVersion,
            event: AnalyticsEvent[category],
            extensionKind: extension_utils_1.isDevExtension ? "Dev" : extension_utils_1.isPreReleaseExtension ? "Pre-Release" : "Stable",
            flutterExtension: extension_utils_1.hasFlutterExtension ? "Installed" : "Not Installed",
            flutterHotReloadOnSave: this.workspaceContext?.hasAnyFlutterProjects ? config_1.config.flutterHotReloadOnSave : undefined,
            flutterUiGuides,
            flutterVersion: this.flutterSdkVersion,
            formatter: this.formatter,
            hostKind: utils_2.hostKind,
            language: vscode_1.env.language,
            platform: constants_1.isChromeOS ? `${process.platform} (ChromeOS)` : process.platform,
            showTodos: config_1.config.showTodos ? "On" : "Off",
            workspaceType: this.workspaceContext?.workspaceTypeDescription,
            ...customData,
        };
        this.telemetryLogger.logUsage("event", data);
    }
    getFormatterSetting() {
        try {
            // If there are multiple formatters for Dart, the user can select one, so check
            // that first so we don't record their formatter being enabled as ours.
            const otherDefaultFormatter = config_1.config.resolved.getAppliedConfig("editor", "defaultFormatter", false);
            if (otherDefaultFormatter && otherDefaultFormatter !== constants_1.dartCodeExtensionIdentifier)
                return otherDefaultFormatter;
            // If the user has explicitly disabled ours (without having another selected
            // then record that).
            if (!config_1.config.enableSdkFormatter)
                return "Disabled";
            // Otherwise record as enabled (and whether on-save).
            return config_1.config.resolved.getAppliedConfig("editor", "formatOnSave")
                ? "Enabled on Save"
                : "Enabled";
        }
        catch {
            return "Unknown";
        }
    }
    handleError(e) {
        this.disableAnalyticsForSession = true;
        this.logger.info(`Failed to send analytics, disabling for session: ${e}`);
    }
    getDebuggerPreference() {
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            return "All code";
        else if (config_1.config.debugSdkLibraries)
            return "My code + SDK";
        else if (config_1.config.debugExternalPackageLibraries)
            return "My code + Packages";
        else
            return "My code";
    }
    // All events below should be included in telemetry.json.
    logExtensionActivated() { this.event(AnalyticsEvent.Extension_Activated); }
    logExtensionRestart() { this.event(AnalyticsEvent.Extension_Restart); }
    logErrorFlutterDaemonTimeout() { this.event(AnalyticsEvent.Error_FlutterDaemonTimeout); }
    logSdkDetectionFailure() { this.event(AnalyticsEvent.SdkDetectionFailure); }
    logDebuggerStart(debuggerType, debuggerRunType, sdkDap) {
        const customData = {
            debuggerAdapterType: sdkDap ? "SDK" : "Legacy",
            debuggerExceptionBreakMode: debuggerRunType === "Debug" ? this.exceptionBreakTrackerFactory.lastTracker?.lastExceptionOptions : undefined,
            debuggerPreference: this.getDebuggerPreference(),
            debuggerRunType,
            debuggerType,
        };
        this.event(AnalyticsEvent.Debugger_Activated, customData);
    }
    logAddSdkToPath(result) {
        const customData = {
            addSdkToPathResult: AddSdkToPathResult[result],
        };
        this.event(AnalyticsEvent.Command_AddSdkToPath, customData);
    }
    logGitCloneSdk(result) {
        const customData = {
            cloneSdkResult: CloneSdkResult[result],
        };
        this.event(AnalyticsEvent.Command_CloneSdk, customData);
    }
    logExtensionPromotion(kind, extension) {
        const customData = {
            data: extension,
        };
        this.event(kind, customData);
    }
    logDevToolsOpened(commandSource) { this.event(AnalyticsEvent.DevTools_Opened, { commandSource }); }
    logFlutterDoctor(commandSource) { this.event(AnalyticsEvent.Command_FlutterDoctor, { commandSource }); }
    logFlutterNewProject(commandSource) { this.event(AnalyticsEvent.Command_FlutterNewProject, { commandSource }); }
    logDartNewProject(commandSource) { this.event(AnalyticsEvent.Command_DartNewProject, { commandSource }); }
    logFlutterSurveyShown() { this.event(AnalyticsEvent.FlutterSurvey_Shown); }
    logFlutterSurveyClicked() { this.event(AnalyticsEvent.FlutterSurvey_Clicked); }
    logFlutterSurveyDismissed() { this.event(AnalyticsEvent.FlutterSurvey_Dismissed); }
    logFlutterOutlineActivated() {
        if (this.hasLoggedFlutterOutline)
            return;
        this.hasLoggedFlutterOutline = true;
        this.event(AnalyticsEvent.FlutterOutline_Activated);
    }
    log(category) { this.event(category); }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.Analytics = Analytics;
class DebugAdapterExceptionSettingTrackerFactory {
    lastTracker;
    createDebugAdapterTracker(session) {
        this.lastTracker = new DebugAdapterExceptionSettingTracker();
        return this.lastTracker;
    }
}
exports.DebugAdapterExceptionSettingTrackerFactory = DebugAdapterExceptionSettingTrackerFactory;
class DebugAdapterExceptionSettingTracker {
    lastExceptionOptions;
    onWillReceiveMessage(message) {
        if (message.command === "setExceptionBreakpoints") {
            const exceptionFilters = message.arguments?.filters ?? [];
            this.lastExceptionOptions = exceptionFilters.slice().sort().join(", ");
            if (!this.lastExceptionOptions)
                this.lastExceptionOptions = "None";
        }
    }
}
var AddSdkToPathResult;
(function (AddSdkToPathResult) {
    AddSdkToPathResult[AddSdkToPathResult["alreadyExisted"] = 0] = "alreadyExisted";
    AddSdkToPathResult[AddSdkToPathResult["succeeded"] = 1] = "succeeded";
    AddSdkToPathResult[AddSdkToPathResult["failed"] = 2] = "failed";
    AddSdkToPathResult[AddSdkToPathResult["unavailableOnPlatform"] = 3] = "unavailableOnPlatform";
})(AddSdkToPathResult || (exports.AddSdkToPathResult = AddSdkToPathResult = {}));
var CloneSdkResult;
(function (CloneSdkResult) {
    CloneSdkResult[CloneSdkResult["cancelled"] = 0] = "cancelled";
    CloneSdkResult[CloneSdkResult["noGit"] = 1] = "noGit";
    CloneSdkResult[CloneSdkResult["succeeded"] = 2] = "succeeded";
    CloneSdkResult[CloneSdkResult["failed"] = 3] = "failed";
})(CloneSdkResult || (exports.CloneSdkResult = CloneSdkResult = {}));


/***/ }),

/***/ 1603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartExtensionApi = void 0;
const vs = __importStar(__webpack_require__(1398));
class DartExtensionApi {
    version = 1;
    flutterCreateSampleProject = () => vs.commands.executeCommand("_dart.flutter.createSampleProject");
}
exports.DartExtensionApi = DartExtensionApi;


/***/ }),

/***/ 9488:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDartPadSamplesCodeLensProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_das_1 = __webpack_require__(2959);
const utils_2 = __webpack_require__(1894);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class FlutterDartPadSamplesCodeLensProvider {
    logger;
    analyzer;
    sdks;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    flutterPackagesFolder;
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", async (sample) => {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const suffix = sample.elementKind === "MIXIN"
                ? "mixin"
                : sample.elementKind === "EXTENSION"
                    ? "extension-type"
                    : "class";
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-${suffix}.html${fragment}`;
            await utils_2.envUtils.openInBrowser(url);
        }));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    async provideCodeLenses(document, token) {
        // Ensure this file is a Flutter package file.
        const filePath = (0, fs_1.fsPath)(document.uri);
        if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
            return;
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
        const visitor = new outline_das_1.ClassOutlineVisitor(this.logger);
        visitor.visit(outline);
        // Filter classes to those with DartPad samples.
        const samples = visitor.classes.filter((cl) => {
            // HACK: DartDocs are between the main offset and codeOffset.
            const docs = document.getText((0, utils_2.toRange)(document, cl.offset, cl.codeOffset - cl.offset));
            return dartPadSamplePattern.test(docs);
        }).map((cl) => ({ ...cl, libraryName }));
        return samples
            .filter((sample) => sample.codeOffset && sample.codeLength)
            .map((sample) => new vscode_1.CodeLens((0, utils_2.toRange)(document, sample.codeOffset, sample.codeLength), {
            arguments: [sample],
            command: "_dart.openDartPadSample",
            title: `Open online interactive samples for ${sample.className}`,
        }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterDartPadSamplesCodeLensProvider = FlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 6296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFlutterDartPadSamplesCodeLensProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_lsp_1 = __webpack_require__(3248);
const utils_2 = __webpack_require__(1894);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class LspFlutterDartPadSamplesCodeLensProvider {
    logger;
    analyzer;
    sdks;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    flutterPackagesFolder;
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables.push(this.analyzer.fileTracker.onOutline(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", async (sample) => {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const suffix = sample.elementKind === "MIXIN"
                ? "mixin"
                : sample.elementKind === "EXTENSION"
                    ? "extension-type"
                    : "class";
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-${suffix}.html${fragment}`;
            await utils_2.envUtils.openInBrowser(url);
        }));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    async provideCodeLenses(document, token) {
        // Ensure this file is a Flutter package file.
        const filePath = (0, fs_1.fsPath)(document.uri);
        if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
            return;
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
        const visitor = new outline_lsp_1.LspClassOutlineVisitor(this.logger);
        visitor.visit(outline);
        // Filter classes to those with DartPad samples.
        const samples = visitor.classes.filter((cl) => {
            // HACK: DartDocs are between the main offset and codeOffset.
            const docs = document.getText(new vscode_1.Range((0, utils_2.lspToPosition)(cl.range.start), (0, utils_2.lspToPosition)(cl.codeRange.start)));
            return dartPadSamplePattern.test(docs);
        }).map((cl) => ({ ...cl, libraryName }));
        return samples
            .filter((sample) => sample.codeRange)
            .map((sample) => new vscode_1.CodeLens((0, utils_2.lspToRange)(sample.codeRange), {
            arguments: [sample],
            command: "_dart.openDartPadSample",
            title: `Open online interactive samples for ${sample.className}`,
        }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFlutterDartPadSamplesCodeLensProvider = LspFlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 7520:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const debugger_1 = __webpack_require__(7976);
const utils_2 = __webpack_require__(1894);
const utils_3 = __webpack_require__(279);
class MainCodeLensProvider {
    logger;
    analyzer;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    async provideCodeLenses(document, token) {
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
        const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, fileType);
        const templatesHaveRun = !!templates.find((t) => t.name === "Run");
        const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
        const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
        const mainFunction = outline.children?.find((o) => o.element.name === "main");
        if (!mainFunction)
            return;
        const results = [];
        if (!templatesHaveRun)
            results.push(this.createCodeLens(document, mainFunction, "Run", false));
        if (!templatesHaveDebug)
            results.push(this.createCodeLens(document, mainFunction, "Debug", true));
        if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
            results.push(this.createCodeLens(document, mainFunction, "Profile", false, { flutterMode: "profile", openDevTools: "performance" }));
        return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, !t.noDebug, t)));
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, mainFunction.offset, mainFunction.length), {
            arguments: [{ resource: document.uri, launchTemplate: template }],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.MainCodeLensProvider = MainCodeLensProvider;


/***/ }),

/***/ 387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspMainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const debugger_1 = __webpack_require__(7976);
const utils_2 = __webpack_require__(1894);
const utils_3 = __webpack_require__(279);
class LspMainCodeLensProvider {
    logger;
    analyzer;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(this.analyzer.fileTracker.onOutline(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    async provideCodeLenses(document, token) {
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
        const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, fileType);
        const templatesHaveRun = !!templates.find((t) => t.name === "Run");
        const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
        const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
        const mainFunction = outline.children?.find((o) => o.element.name === "main");
        if (!mainFunction)
            return;
        const results = [];
        if (!templatesHaveRun)
            results.push(this.createCodeLens(document, mainFunction, "Run", false));
        if (!templatesHaveDebug)
            results.push(this.createCodeLens(document, mainFunction, "Debug", true));
        if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
            results.push(this.createCodeLens(document, mainFunction, "Profile", false, { flutterMode: "profile", openDevTools: "performance" }));
        return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, !t.noDebug, t)));
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(mainFunction.codeRange), {
            arguments: [{ resource: document.uri, launchTemplate: template }],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspMainCodeLensProvider = LspMainCodeLensProvider;


/***/ }),

/***/ 3928:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_das_1 = __webpack_require__(2959);
const debugger_1 = __webpack_require__(7976);
const utils_2 = __webpack_require__(1894);
const utils_3 = __webpack_require__(279);
class TestCodeLensProvider {
    logger;
    analyzer;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    async provideCodeLenses(document, token) {
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
        // SDK codebase cannot, and will therefore run all tests when you click them).
        if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
            return;
        // If we don't consider this a test file, we should also not show links (since we may try to run the
        // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
        if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
            return;
        const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, "test");
        const templatesHaveRun = !!templates.find((t) => t.name === "Run");
        const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
        const visitor = new outline_das_1.TestOutlineVisitor(this.logger);
        visitor.visit(outline);
        return (0, utils_1.flatMap)(visitor.tests
            .filter((test) => test.offset && test.length)
            .map((test) => {
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, test, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, test, "Debug", true));
            return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, !t.noDebug, t)));
        }), (x) => x);
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, test.offset, test.length), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCodeLensProvider = TestCodeLensProvider;


/***/ }),

/***/ 7107:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspTestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_lsp_1 = __webpack_require__(3248);
const debugger_1 = __webpack_require__(7976);
const utils_2 = __webpack_require__(1894);
const utils_3 = __webpack_require__(279);
class LspTestCodeLensProvider {
    logger;
    analyzer;
    disposables = [];
    onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
    onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(this.analyzer.fileTracker.onOutline(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    async provideCodeLenses(document, token) {
        // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
        // SDK codebase cannot, and will therefore run all tests when you click them).
        if (!this.analyzer.fileTracker.supportsPackageTest(document.uri))
            return;
        // If we don't consider this a test file, we should also not show links (since we may try to run the
        // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
        if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
            return;
        // Without version numbers, the best we have to tell if an outline is likely correct or stale is
        // if its length matches the document exactly.
        const expectedLength = document.getText().length;
        const outline = await this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
        if (!outline || !outline.children || !outline.children.length)
            return;
        const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, "test");
        const templatesHaveRun = !!templates.find((t) => t.name === "Run");
        const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
        const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, (0, fs_1.fsPath)(document.uri));
        visitor.visit(outline);
        return (0, utils_1.flatMap)(visitor.tests
            .filter((test) => test.range)
            .map((test) => {
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, test, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, test, "Debug", true));
            return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, !t.noDebug, t)));
        }), (x) => x);
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(test.range), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspTestCodeLensProvider = LspTestCodeLensProvider;


/***/ }),

/***/ 6616:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCommand = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const util_1 = __webpack_require__(9023);
const vs = __importStar(__webpack_require__(1398));
const pub_add_1 = __webpack_require__(703);
const fs_1 = __webpack_require__(2587);
const analytics_1 = __webpack_require__(5922);
const util = __importStar(__webpack_require__(279));
const projects_1 = __webpack_require__(6265);
const sdk_1 = __webpack_require__(7177);
const cacheFilename = "package_cache.json";
const knownFlutterSdkPackages = [
    "flutter",
    "flutter_test",
    "flutter_driver",
    "flutter_localizations",
    "integration_test",
];
class AddDependencyCommand extends sdk_1.BaseSdkCommands {
    pubApi;
    analytics;
    extensionStorageUri;
    cache;
    nextPackageNameFetchTimeout;
    constructor(logger, context, workspace, dartCapabilities, pubApi, analytics) {
        super(logger, context, workspace, dartCapabilities);
        this.pubApi = pubApi;
        this.analytics = analytics;
        this.disposables.push(vs.commands.registerCommand("dart.addDependency", (uri) => this.promptAndAddDependency(uri, false)));
        this.disposables.push(vs.commands.registerCommand("dart.addDevDependency", (uri) => this.promptAndAddDependency(uri, true)));
        this.disposables.push(vs.commands.registerCommand("_dart.addDependency", this.addDependency, this));
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependency", this.removeDependency, this));
        this.extensionStorageUri = context.extensionStorageUri;
        // Kick off async work to fetch then queue a new check.
        this.loadAndFetch().catch((e) => this.logger.error(e));
    }
    async loadAndFetch() {
        try {
            await this.loadPackageCache();
        }
        finally {
            this.queueNextPackageNameFetch(this.cache?.cacheTimeRemainingMs ?? 0);
        }
    }
    async loadPackageCache() {
        try {
            const bytes = await vs.workspace.fs.readFile(this.packageNameCacheUri);
            const contents = new util_1.TextDecoder().decode(bytes);
            this.cache = pub_add_1.PackageCacheData.fromJson(contents.toString());
            this.logger.info(`Loaded ${this.cache?.packageNames.length} package names from ${this.packageNameCacheUri}`);
        }
        catch (e) {
            this.logger.info(`Failed to read package cache file: ${e}`);
        }
    }
    get packageNameCacheUri() {
        return vs.Uri.joinPath(this.extensionStorageUri, cacheFilename);
    }
    async savePackageCache() {
        try {
            const json = this.cache?.toJson();
            if (json) {
                const bytes = new util_1.TextEncoder().encode(json);
                await vs.workspace.fs.writeFile(this.packageNameCacheUri, bytes);
            }
            this.logger.info(`Saved ${this.cache?.packageNames.length} in ${this.packageNameCacheUri}`);
        }
        catch (e) {
            this.logger.error(`Failed to save package cache file: ${e}`);
        }
    }
    queueNextPackageNameFetch(ms) {
        if (this.nextPackageNameFetchTimeout)
            clearTimeout(this.nextPackageNameFetchTimeout);
        this.nextPackageNameFetchTimeout = setTimeout(() => this.fetchPackageNames(), ms);
    }
    async fetchPackageNames() {
        this.logger.info(`Caching Pub package names from ${this.pubApi.pubUrlBase}...`);
        let results;
        try {
            results = await this.pubApi.getPackageNames();
        }
        catch (e) {
            this.logger.error(`Failed to fetch Pub package names: ${e}`);
        }
        if (results && results.packages) {
            try {
                this.cache = pub_add_1.PackageCacheData.fromPackageNames(results.packages);
                await this.savePackageCache();
            }
            catch (e) {
                this.logger.error(`Failed to cache Pub package names: ${e}`);
            }
        }
        else {
            this.logger.error(`Pub package name results were invalid`);
        }
        this.queueNextPackageNameFetch(pub_add_1.PackageCacheData.maxCacheAgeMs);
    }
    async promptAndAddDependency(uri, isDevDependency) {
        this.analytics.log(analytics_1.AnalyticsEvent.Command_AddDependency);
        if (!uri || !(uri instanceof vs.Uri)) {
            uri = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to add the dependency to");
            // If the user cancelled, bail out (otherwise we'll prompt them again below).
            if (!uri)
                return;
        }
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        let selectedOption = await this.promptForPackageInfo();
        if (!selectedOption)
            return;
        let packageInfo;
        if (typeof selectedOption === "string") {
            selectedOption = selectedOption.trim();
            // For convenience, we handle string URLs/paths too.
            if (selectedOption.startsWith("http://") || selectedOption.startsWith("https://"))
                packageInfo = await this.promptForGitPackageInfo(selectedOption);
            else if (selectedOption.includes("/") || selectedOption.includes("\\"))
                packageInfo = await this.promptForPathPackageInfo(selectedOption);
            else
                packageInfo = { packageNames: selectedOption, marker: undefined };
        }
        else {
            switch (selectedOption.marker) {
                case "PATH":
                    packageInfo = await this.promptForPathPackageInfo();
                    break;
                case "GIT":
                    packageInfo = await this.promptForGitPackageInfo();
                    break;
                default:
                    packageInfo = selectedOption;
                    break;
            }
        }
        if (!packageInfo)
            return;
        return this.addDependency(uri, packageInfo, isDevDependency);
    }
    /// Note: This is called by quick-fix as well as directly from the command palette.
    async addDependency(uri, selectedPackage, isDevDependency) {
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        const args = ["add"];
        let packageName;
        if (selectedPackage.marker === "GIT") {
            packageName = selectedPackage.packageName;
            args.push(packageName);
            args.push(`--git-url=${selectedPackage.url}`);
            if (selectedPackage.ref) {
                args.push(`--git-ref=${selectedPackage.ref}`);
            }
            if (selectedPackage.path) {
                args.push(`--git-path=${selectedPackage.path}`);
            }
        }
        else if (selectedPackage.marker === "PATH") {
            packageName = selectedPackage.packageName;
            args.push(packageName);
            args.push(`--path=${selectedPackage.path}`);
        }
        else {
            const packageNames = selectedPackage.packageNames.split(",").map((p) => p.trim());
            for (const packageName of packageNames) {
                args.push(packageName);
            }
            // We assume when multiple are given, they're all of the same type.
            // The completion list should filter when this is the case.
            packageName = packageNames[0];
        }
        if (isDevDependency)
            args.push("--dev");
        // Handle some known Flutter dependencies.
        const isFlutterSdkPackage = knownFlutterSdkPackages.includes(packageName);
        if (isFlutterSdkPackage) {
            args.push("--sdk");
            args.push("flutter");
        }
        if (this.sdks.flutter && (isFlutterSdkPackage || util.isInsideFlutterProject(uri))) {
            return this.runFlutter(["pub", ...args], uri);
        }
        else {
            return this.runPub(args, uri);
        }
    }
    async removeDependency(uri, packageName) {
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        const args = ["remove", packageName];
        if (this.sdks.flutter && util.isInsideFlutterProject(uri)) {
            return this.runFlutter(["pub", ...args], uri);
        }
        else {
            return this.runPub(args, uri);
        }
    }
    /// Prompts the user to select a package name, or the option to select a path or Git package (in
    /// which case they must also provide package name etc).
    async promptForPackageInfo() {
        const quickPick = vs.window.createQuickPick();
        quickPick.placeholder = this.dartCapabilities.supportsPubAddMultiple
            ? "package name (can be comma separated), URL or path"
            : "package name, URL or path";
        quickPick.title = this.dartCapabilities.supportsPubAddMultiple
            ? "Enter package name(s), URL or local path"
            : "Enter a package name, URL or local path";
        quickPick.items = this.getPackageEntries();
        quickPick.onDidChangeValue((userInput) => {
            quickPick.items = this.getPackageEntries(userInput);
        });
        const selectedOption = await new Promise((resolve) => {
            quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0] ? quickPick.selectedItems[0] : quickPick.value));
            quickPick.onDidHide(() => resolve(undefined));
            quickPick.show();
        });
        quickPick.dispose();
        return selectedOption;
    }
    async promptForPathPackageInfo(packagePath) {
        if (!packagePath) {
            const packagePaths = await vs.window.showOpenDialog({
                canSelectFiles: false,
                canSelectFolders: true,
                canSelectMany: false,
                openLabel: "Select package folder",
            });
            if (!packagePaths || packagePaths.length !== 1)
                return;
            packagePath = (0, fs_1.fsPath)(packagePaths[0]);
        }
        if (!packagePath)
            return;
        try {
            const pubspecPackageNameRegex = /^name: (\w+)$/gm;
            const pubspecContent = fs.readFileSync(path.join(packagePath, "pubspec.yaml"), "utf8");
            const packageNameResult = pubspecPackageNameRegex.exec(pubspecContent);
            if (packageNameResult)
                return { path: packagePath, packageName: packageNameResult[1], marker: "PATH" };
        }
        catch (e) {
            this.logger.error(e);
            void vs.window.showErrorMessage("The selected folder does not appear to be a valid Pub package");
            return;
        }
    }
    async promptForGitPackageInfo(repoUrl) {
        if (!repoUrl)
            repoUrl = await this.promptForGitUrl();
        if (!repoUrl)
            return;
        const urlSegments = repoUrl.split("/");
        const packageName = await this.promptForPackageName(urlSegments[urlSegments.length - 1]);
        if (!packageName)
            return;
        const repoRef = await this.promptForGitRef();
        const repoPath = await this.promptForGitPath();
        return {
            marker: "GIT",
            packageName,
            path: repoPath,
            ref: repoRef,
            url: repoUrl,
        };
    }
    promptForGitUrl() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "git repo url",
            title: "Enter a Git repository url",
        });
    }
    promptForGitPath() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "path to package",
            title: "Enter the path to the package in the repository (press <enter> for default)",
        });
    }
    async promptForGitRef() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "commit/branch",
            title: "Enter the commit/branch to use (press <enter> for default)",
        });
    }
    async promptForPackageName(name) {
        return await vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "package name",
            title: "Enter the Packages name",
            value: name,
        });
    }
    getPackageEntries(userInput) {
        let currentSearchString = userInput;
        let completionItemPrefixes = "";
        if (userInput && this.dartCapabilities.supportsPubAddMultiple) {
            // If we support multiple, we need to split "foo, bar, ba" into "foo, bar, " and "ba". One is the search
            // and the other is a prefix that needs adding to all package names in the completion list.
            const startOfCurrentPackageName = Math.max(userInput.lastIndexOf(" "), userInput.lastIndexOf(","));
            currentSearchString = userInput.substring(startOfCurrentPackageName + 1);
            completionItemPrefixes = userInput.substring(0, startOfCurrentPackageName + 1);
            if (currentSearchString === "" && completionItemPrefixes.endsWith(","))
                completionItemPrefixes = `${completionItemPrefixes} `;
        }
        const max = 50;
        const packageNames = this.cache?.packageNames ?? [];
        let matches = new Set();
        // This list can be quite large, so avoid using .filter() if we can bail out early.
        if (currentSearchString) {
            currentSearchString = currentSearchString.trim();
            for (let i = 0; i < packageNames.length && matches.size < max; i++) {
                const packageName = packageNames[i];
                if (packageName.startsWith(currentSearchString))
                    matches.add(packageName);
            }
            // Also add on any Flutter-SDK packages that match.
            for (const packageName of knownFlutterSdkPackages) {
                if (packageName.startsWith(currentSearchString))
                    matches.add(packageName);
            }
        }
        else {
            matches = new Set(packageNames.slice(0, Math.min(max, packageNames.length)));
        }
        const pickablePackageNames = Array.from(matches).map((packageName) => {
            const fullString = `${completionItemPrefixes}${packageName}`;
            return {
                label: fullString,
                marker: undefined,
                packageNames: fullString,
            };
        });
        if (currentSearchString) {
            return pickablePackageNames;
        }
        else {
            return [
                {
                    description: "add a package from a local path",
                    label: "Local Path Package",
                    marker: "PATH",
                },
                {
                    description: "add a package from a Git repository",
                    label: "Git Repository URL",
                    marker: "GIT",
                },
                ...pickablePackageNames,
            ];
        }
    }
}
exports.AddDependencyCommand = AddDependencyCommand;


/***/ }),

/***/ 439:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddSdkToPathCommands = exports.AddSdkToPath = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const analytics_1 = __webpack_require__(5922);
const processes_1 = __webpack_require__(8141);
class AddSdkToPath {
    logger;
    context;
    analytics;
    constructor(logger, context, analytics) {
        this.logger = logger;
        this.context = context;
        this.analytics = analytics;
    }
    async addToPath(sdkType, sdkPath) {
        if (!sdkPath) {
            void vs.window.showErrorMessage(constants_1.noSdkAvailablePrompt);
            return;
        }
        sdkPath = path.join(sdkPath, "bin");
        let result = analytics_1.AddSdkToPathResult.failed;
        try {
            result = this.canAddPathAutomatically()
                ? constants_1.isWin
                    ? await this.addToPathWindows(sdkPath)
                    // If we add more platforms here, we must also remove the isWin check in
                    // tryFlutterCloneIfGitAvailable() so the prompt to add to PATH shows.
                    : analytics_1.AddSdkToPathResult.unavailableOnPlatform
                : analytics_1.AddSdkToPathResult.unavailableOnPlatform;
            if (result === analytics_1.AddSdkToPathResult.alreadyExisted || (result === analytics_1.AddSdkToPathResult.failed && process.env.PATH?.includes(sdkPath))) {
                void vs.window.showInformationMessage((0, constants_1.sdkAlreadyOnPathPrompt)(sdkType));
            }
            else if (result === analytics_1.AddSdkToPathResult.succeeded) {
                void vs.window.showInformationMessage((0, constants_1.addedToPathPrompt)(sdkType));
            }
            else if (this.canShowInstructions()) {
                await this.showManualInstructions(sdkType, sdkPath, result === analytics_1.AddSdkToPathResult.failed);
            }
        }
        finally {
            this.analytics.logAddSdkToPath(result);
        }
    }
    async promptToAddToPath(sdkType, sdkPath) {
        if (!this.canAddPathAutomatically() && !this.canShowInstructions())
            return;
        // Change isWin here if we support this on other platforms in AddSdkToPath.addToPath.
        if (this.canAddPathAutomatically()) {
            const action = await vs.window.showInformationMessage((0, constants_1.addSdkToPathPrompt)(sdkType), constants_1.addSdkToPathAction, constants_1.noThanksAction);
            if (action === constants_1.addSdkToPathAction)
                await this.addToPath(sdkType, sdkPath);
        }
        else {
            await this.showManualInstructions(sdkType, sdkPath);
        }
    }
    canAddPathAutomatically() {
        return constants_1.isWin;
    }
    canShowInstructions() {
        return !constants_1.isChromeOS;
    }
    async showManualInstructions(sdkType, sdkPath, didFailToAutomaticallyAdd = false) {
        if (!constants_1.addToPathInstructionsUrl)
            return;
        while (true) {
            const action = didFailToAutomaticallyAdd
                ? await vs.window.showWarningMessage((0, constants_1.unableToAddToPathPrompt)(sdkType), constants_1.openInstructionsAction, constants_1.copySdkPathToClipboardAction, constants_1.noThanksAction)
                : await vs.window.showInformationMessage((0, constants_1.addSdkToPathPrompt)(sdkType), constants_1.openInstructionsAction, constants_1.copySdkPathToClipboardAction, constants_1.noThanksAction);
            if (action === constants_1.openInstructionsAction) {
                await utils_2.envUtils.openInBrowser(constants_1.addToPathInstructionsUrl);
            }
            else if (action === constants_1.copySdkPathToClipboardAction) {
                await vs.env.clipboard.writeText(sdkPath);
            }
            else {
                break;
            }
        }
    }
    async addToPathWindows(sdkPath) {
        try {
            const scriptPath = this.context.asAbsolutePath("media/add_to_path.ps1");
            const result = await (0, processes_1.runToolProcess)(this.logger, undefined, "powershell", [
                "-NoProfile",
                "-NonInteractive",
                "-WindowStyle", "Hidden",
                "-ExecutionPolicy", "Bypass",
                "-File", scriptPath,
                sdkPath,
            ], undefined);
            return result.exitCode === 12345
                ? analytics_1.AddSdkToPathResult.alreadyExisted
                : result.exitCode
                    ? analytics_1.AddSdkToPathResult.failed
                    : analytics_1.AddSdkToPathResult.succeeded;
        }
        catch (e) {
            this.logger.error(e);
            return analytics_1.AddSdkToPathResult.failed;
        }
    }
}
exports.AddSdkToPath = AddSdkToPath;
class AddSdkToPathCommands extends AddSdkToPath {
    disposables = [];
    constructor(logger, context, wsContext, analytics) {
        super(logger, context, analytics);
        this.disposables.push(vs.commands.registerCommand("dart.addSdkToPath", async () => {
            if (wsContext.sdks.dartSdkIsFromFlutter) {
                return vs.commands.executeCommand("flutter.addSdkToPath");
            }
            await this.addToPath("Dart", wsContext.sdks.dart);
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.addSdkToPath", async () => {
            await this.addToPath("Flutter", wsContext.sdks.flutter);
        }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.AddSdkToPathCommands = AddSdkToPathCommands;


/***/ }),

/***/ 5591:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerCommands = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(1894);
const analytics_1 = __webpack_require__(5922);
// Must be global, as all classes are created during an extension restart.
let forcedReanalyzeCount = 0;
class AnalyzerCommands {
    logger;
    constructor(context, logger, analyzer, analytics) {
        this.logger = logger;
        context.subscriptions.push(vs.commands.registerCommand("dart.openAnalyzerDiagnostics", async () => {
            const res = await analyzer.getDiagnosticServerPort();
            await utils_1.envUtils.openInBrowser(`http://127.0.0.1:${res.port}/`);
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.restartAnalysisServer", async () => {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.log(analytics_1.AnalyticsEvent.Command_RestartAnalyzer);
            void vs.commands.executeCommand("_dart.reloadExtension");
        }));
        context.subscriptions.push(vs.commands.registerCommand("dart.forceReanalyze", async () => {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.log(analytics_1.AnalyticsEvent.Command_ForceReanalyze);
            await analyzer.forceReanalyze();
        }));
    }
    async showServerRestartPrompt() {
        const choice = await vs.window.showInformationMessage("Needing to reanalyze a lot? Please consider filing a bug with a server instrumentation log", constants_1.issueTrackerAction);
        if (choice === constants_1.issueTrackerAction)
            await utils_1.envUtils.openInBrowser(constants_1.issueTrackerUri, this.logger);
    }
}
exports.AnalyzerCommands = AnalyzerCommands;


/***/ }),

/***/ 269:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOutputChannel = getOutputChannel;
exports.runProcessInOutputChannel = runProcessInOutputChannel;
const vs = __importStar(__webpack_require__(1398));
const channels = {};
function getOutputChannel(name, insertDivider = false) {
    if (!channels[name]) {
        channels[name] = vs.window.createOutputChannel(name);
    }
    else if (insertDivider) {
        const ch = channels[name];
        ch.appendLine("");
        ch.appendLine("--");
        ch.appendLine("");
    }
    return channels[name];
}
function runProcessInOutputChannel(process, channel) {
    process.stdout.on("data", (data) => channel.append(data.toString()));
    process.stderr.on("data", (data) => channel.append(data.toString()));
    process.on("close", (code) => channel.appendLine(`exit code ${code}`));
}


/***/ }),

/***/ 5068:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCommands = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const projects_1 = __webpack_require__(8146);
const config_1 = __webpack_require__(7678);
const dart_create_1 = __webpack_require__(33);
const sdk_1 = __webpack_require__(7177);
class DartCommands extends sdk_1.BaseSdkCommands {
    sdkUtils;
    pubGlobal;
    analytics;
    constructor(logger, context, workspace, sdkUtils, pubGlobal, dartCapabilities, analytics) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.pubGlobal = pubGlobal;
        this.analytics = analytics;
        this.disposables.push(vs.commands.registerCommand("dart.createProject", this.createDartProject, this));
        this.disposables.push(vs.commands.registerCommand("_dart.create", this.dartCreate, this));
    }
    dartCreate(projectPath, templateName) {
        if (!this.dartCapabilities.supportsDartCreate) {
            void vs.window.showErrorMessage("Creating projects is only supported for Dart SDKs >= v2.10");
            return;
        }
        const binPath = path.join(this.sdks.dart, constants_1.dartVMPath);
        const projectContainer = path.dirname(projectPath);
        const projectName = path.basename(projectPath);
        const args = ["create", "-t", templateName, projectName, "--force"];
        return this.runCommandInFolder(templateName, projectContainer, binPath, args, false);
    }
    async createDartProject(options) {
        const command = "dart.createProject";
        const triggerFilename = constants_1.DART_CREATE_PROJECT_TRIGGER_FILE;
        const autoPickIfSingleItem = false;
        if (!this.sdks || !this.sdks.dart) {
            this.sdkUtils.showDartActivationFailure(command);
            return;
        }
        if (!this.dartCapabilities.supportsDartCreate) {
            void vs.window.showErrorMessage("Creating projects is only supported for Dart SDKs >= v2.10");
            return;
        }
        this.analytics.logDartNewProject(options?.commandSource);
        // Get the JSON for the available templates by calling 'dart create'.
        const creator = new dart_create_1.DartCreate(this.logger, this.sdks);
        let templates;
        try {
            templates = await creator.getTemplates();
        }
        catch (e) {
            void vs.window.showErrorMessage(`Unable to fetch project templates. ${e}`);
            return;
        }
        const sortedTemplates = (0, array_1.sortBy)(templates, (s) => s.label);
        const pickItems = sortedTemplates.map((t) => ({
            description: t.name,
            detail: t.description,
            label: t.label,
            template: t,
        }));
        // Get the user to pick a template (but pick for them if there's only one
        // and autoPickIfSingleItem).
        const selectedTemplate = autoPickIfSingleItem && pickItems.length === 1
            ? pickItems[0]
            : await vs.window.showQuickPick(pickItems, {
                ignoreFocusOut: true,
                matchOnDescription: true,
                placeHolder: "Which Dart template?",
            });
        if (!selectedTemplate)
            return;
        // If already in a workspace, set the default folder to something nearby.
        const folders = await vs.window.showOpenDialog({
            canSelectFolders: true,
            defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
            openLabel: "Select a folder to create the project in",
        });
        if (!folders || folders.length !== 1)
            return;
        const folderPath = (0, fs_1.fsPath)(folders[0]);
        this.context.lastUsedNewProjectPath = folderPath;
        const projectKind = this.getProjectKind(selectedTemplate.template.name);
        const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, `dart_${projectKind}_`);
        const name = await vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: defaultName,
            prompt: "Enter a name for your new project",
            validateInput: (s) => this.validateDartProjectName(s, folderPath),
            value: defaultName,
        });
        if (!name)
            return;
        const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
        const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
        if (fs.existsSync(projectFolderPath)) {
            void vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
            return;
        }
        // Create the empty folder so we can open it.
        fs.mkdirSync(projectFolderPath);
        // Create a temp dart file to force extension to load when we open this folder.
        fs.writeFileSync(path.join(projectFolderPath, triggerFilename), JSON.stringify(selectedTemplate.template));
        // If we're using a custom SDK, we need to apply it to the new project too.
        if (config_1.config.workspaceSdkPath)
            (0, projects_1.writeDartSdkSettingIntoProject)(config_1.config.workspaceSdkPath, projectFolderPath);
        void vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
    }
    validateDartProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Dart project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["dart", "test", "this"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a dart project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
    getProjectKind(templateName) {
        if (templateName.includes("package"))
            return "package";
        if (templateName.includes("web"))
            return "web_application";
        return "application";
    }
}
exports.DartCommands = DartCommands;


/***/ }),

/***/ 394:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugCommands = exports.LastTestDebugSession = exports.LastDebugSession = exports.isInFlutterProfileModeDebugSession = exports.isInFlutterDebugModeDebugSession = exports.isInDartDebugSession = exports.debugSessionChanged = exports.debugSessionStopped = exports.debugSessionStarted = exports.debugSessionsChanged = exports.debugSessions = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const constants_2 = __webpack_require__(5706);
const debugger_1 = __webpack_require__(7976);
const status_bar_1 = __webpack_require__(719);
const user_prompts_1 = __webpack_require__(7020);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const vm_service_extensions_1 = __webpack_require__(3419);
const project_1 = __webpack_require__(5143);
const utils_3 = __webpack_require__(279);
const debug_1 = __webpack_require__(5940);
exports.debugSessions = [];
const debugSessionsChangedEmitter = new vs.EventEmitter();
exports.debugSessionsChanged = debugSessionsChangedEmitter.event;
const debugSessionStartedEmitter = new vs.EventEmitter();
exports.debugSessionStarted = debugSessionStartedEmitter.event;
const debugSessionStoppedEmitter = new vs.EventEmitter();
exports.debugSessionStopped = debugSessionStoppedEmitter.event;
const debugSessionChangedEmitter = new vs.EventEmitter();
exports.debugSessionChanged = debugSessionChangedEmitter.event;
const CURRENT_FILE_RUNNABLE = "dart-code:currentFileIsRunnable";
// Workaround for https://github.com/microsoft/vscode/issues/100115
const dynamicDebugSessionName = "Dart ";
// As a workaround for https://github.com/Microsoft/vscode/issues/71651 we
// will keep any events that arrive before their session "started" and then
// replace them when the start event comes through.
let pendingCustomEvents = [];
let hasPromptedAboutDebugSettings = false;
exports.isInDartDebugSession = false;
exports.isInFlutterDebugModeDebugSession = false;
exports.isInFlutterProfileModeDebugSession = false;
class LastDebugSession {
    static workspaceFolder;
    static debugConfig;
}
exports.LastDebugSession = LastDebugSession;
class LastTestDebugSession {
    static workspaceFolder;
    static debugConfig;
}
exports.LastTestDebugSession = LastTestDebugSession;
class DebugCommands {
    logger;
    fileTracker;
    context;
    workspaceContext;
    dartCapabilities;
    flutterCapabilities;
    devTools;
    logging;
    disposables = [];
    debugOptions = vs.window.createStatusBarItem("dartStatusDebugOptions", vs.StatusBarAlignment.Left, 0);
    currentDebugOption = enums_1.DebugOption.MyCode;
    debugMetrics = vs.window.createStatusBarItem("dartStatusDebugMetrics", vs.StatusBarAlignment.Right, 0);
    debugSessionsStatusItem = (0, status_bar_1.getLanguageStatusItem)("dart.debugSessions", constants_2.ANALYSIS_FILTERS);
    onWillHotReloadEmitter = new vs.EventEmitter();
    onWillHotReload = this.onWillHotReloadEmitter.event;
    onWillHotRestartEmitter = new vs.EventEmitter();
    onWillHotRestart = this.onWillHotRestartEmitter.event;
    onDebugSessionVmServiceAvailableEmitter = new vs.EventEmitter();
    onDebugSessionVmServiceAvailable = this.onDebugSessionVmServiceAvailableEmitter.event;
    vmServices;
    suppressFlutterWidgetErrors = false;
    isInspectingWidget = false;
    autoCancelNextInspectWidgetMode = false;
    constructor(logger, fileTracker, context, workspaceContext, dartCapabilities, flutterCapabilities, devTools, logging) {
        this.logger = logger;
        this.fileTracker = fileTracker;
        this.context = context;
        this.workspaceContext = workspaceContext;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.devTools = devTools;
        this.logging = logging;
        this.vmServices = new vm_service_extensions_1.VmServiceExtensions(logger, this, workspaceContext, flutterCapabilities);
        this.devTools.debugCommands = this;
        this.debugOptions.name = "Dart Debug Options";
        this.disposables.push(this.debugOptions);
        this.debugMetrics.name = "Dart Debug Metrics";
        this.disposables.push(this.debugMetrics);
        this.debugSessionsStatusItem.name = "Dart Debug Sessions";
        this.updateDebugSessionsStatus();
        this.disposables.push(vs.debug.onDidChangeBreakpoints((e) => this.handleBreakpointChange(e)));
        this.disposables.push(vs.debug.onDidStartDebugSession((s) => this.handleDebugSessionStart(s)));
        this.disposables.push(vs.debug.onDidReceiveDebugSessionCustomEvent((e) => this.handleDebugSessionCustomEvent(e)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((s) => this.handleDebugSessionEnd(s)));
        this.disposables.push(this.logging.onCaptureLogs((isCapturing) => this.setSendLogsToClient(isCapturing)));
        // Handle enabling Run/Debug buttons for the file if an entry point or have a main() method.
        if (this.fileTracker)
            this.disposables.push(this.fileTracker.onOutline(() => this.updateRunnableContexts()));
        this.disposables.push(vs.window.onDidChangeActiveTextEditor(() => this.updateRunnableContexts()));
        // Run for current open editor.
        this.updateRunnableContexts();
        this.disposables.push(vs.commands.registerCommand("flutter.overridePlatform", () => this.vmServices.overridePlatform()));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugPainting", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugPaint)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePerformanceOverlay", () => this.vmServices.toggle(enums_1.VmServiceExtension.PerformanceOverlay)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleBrightness", () => this.vmServices.toggle(enums_1.VmServiceExtension.BrightnessOverride, "Brightness.dark", "Brightness.light")));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleRepaintRainbow", () => this.vmServices.toggle(enums_1.VmServiceExtension.RepaintRainbow)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugModeBanner", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugBanner)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePaintBaselines", () => this.vmServices.toggle(enums_1.VmServiceExtension.PaintBaselines)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleSlowAnimations", () => this.vmServices.toggle(enums_1.VmServiceExtension.SlowAnimations, vm_service_extensions_1.timeDilationNormal, vm_service_extensions_1.timeDilationSlow)));
        this.disposables.push(vs.commands.registerCommand("flutter.inspectWidget", () => {
            this.autoCancelNextInspectWidgetMode = false;
            void this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true);
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.inspectWidget.autoCancel", () => {
            this.autoCancelNextInspectWidgetMode = true;
            void this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true);
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.cancelInspectWidget", () => {
            this.autoCancelNextInspectWidgetMode = false;
            void this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, false, false);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.openObservatory", async () => {
            const session = await this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                await utils_2.envUtils.openInBrowser(session.observatoryUri);
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("dart.copyVmServiceUri", async () => {
            const session = await this.getDebugSession();
            if (!session) {
                await vs.window.showInformationMessage("No Dart/Flutter debug session available");
                return;
            }
            const vmUri = session?.vmServiceUri;
            if (!vmUri) {
                if (session?.hasStarted)
                    await vs.window.showInformationMessage("This debug session does not have a VM Service");
                else
                    await vs.window.showInformationMessage("This debug session is not ready yet");
                return;
            }
            await vs.env.clipboard.writeText(vmUri.toString());
        }));
        this.disposables.push(vs.commands.registerCommand("dart.openDevTools.external", () => vs.commands.executeCommand("dart.openDevTools", { commandSource: constants_1.CommandSource.commandPalette, location: "external" })));
        this.disposables.push(vs.commands.registerCommand("_dart.openDevTools.touchBar", () => vs.commands.executeCommand("dart.openDevTools", { commandSource: constants_1.CommandSource.touchbar })));
        constants_1.devToolsPages.forEach((page) => {
            void vs.commands.executeCommand("setContext", `dart-code:devToolsSupports${page.commandSuffix}`, this.devTools.isPageAvailable(true, page));
            this.disposables.push(vs.commands.registerCommand(`dart.openDevTools${page.commandSuffix}`, async (options) => {
                options = Object.assign({}, options, { pageId: page.id });
                return vs.commands.executeCommand("dart.openDevTools", options);
            }));
        });
        this.disposables.push(vs.commands.registerCommand("flutter.openDevTools.sidebar", () => vs.commands.executeCommand("flutter.openDevTools", { commandSource: constants_1.CommandSource.sidebarTitle })));
        this.disposables.push(vs.commands.registerCommand("flutter.openDevTools", async (options) => vs.commands.executeCommand("dart.openDevTools", options)));
        this.disposables.push(vs.commands.registerCommand("dart.openDevTools", async (options) => {
            const commandSource = options?.commandSource ?? constants_1.CommandSource.commandPalette;
            const pageId = options?.pageId;
            const location = options?.location;
            const triggeredAutomatically = options?.triggeredAutomatically;
            let requiresDebugSession = options?.requiresDebugSession;
            let prefersDebugSession = options?.prefersDebugSession;
            // Check whether we'll need a Debug Session to open this page.
            // If we weren't given an explicit `requiresDebugSession` then require it only if we have a page ID
            // _and_ we are not known to be a static page (that is, we're a page we don't recognise or a page
            // we know to _not_ be static).
            // Ideally we'll never fall into this, because the call will always have a requiresDebugSession
            const page = constants_1.devToolsPages.find((p) => p.id === pageId);
            const isKnownStaticPage = page && page.isStaticTool;
            requiresDebugSession = requiresDebugSession ?? (!!pageId && !isKnownStaticPage);
            // Also, _prefer_ a debug session if we haven't been told but we know we're not a static page.
            prefersDebugSession = prefersDebugSession ?? !isKnownStaticPage;
            // As a workaround for https://github.com/Dart-Code/Dart-Code/issues/5208, if this is
            // a request to launch an extension and neither flag was set, then rather than defaulting
            // to `requires` (and not `prefers`), fall back to just prefering.
            if (pageId && pageId.endsWith("_ext")
                && options?.requiresDebugSession === undefined
                && options?.prefersDebugSession === undefined
                && requiresDebugSession) {
                requiresDebugSession = false;
                prefersDebugSession = true;
            }
            let session;
            if (requiresDebugSession || (prefersDebugSession && exports.debugSessions.length)) {
                session = options?.debugSessionId
                    ? exports.debugSessions.find((s) => s.session.id === options.debugSessionId)
                    : await this.getDebugSession();
                if (!session)
                    return; // User cancelled or specified session was gone
            }
            // Only show a notification if we were not triggered automatically.
            const notify = !options || triggeredAutomatically !== true;
            if (!session || session?.vmServiceUri) {
                return this.devTools.spawn(session, { notify, pageId, commandSource, location, triggeredAutomatically });
            }
            else if (session.session.configuration.noDebug) {
                void vs.window.showInformationMessage("You must start your app with debugging in order to use DevTools.");
            }
            else if (session.hasStarted && session.flutterMode && session.flutterDeviceId) {
                void vs.window.showInformationMessage(`DevTools is not available for an app running in ${session.flutterMode} mode on device '${session.flutterDeviceId}'.`);
            }
            else if (session.hasStarted) {
                void vs.window.showInformationMessage("DevTools is not available for an app running in this mode.");
            }
            else {
                void vs.window.showInformationMessage("This debug session is not ready yet.");
            }
        }));
        // Misc custom debug commands.
        this.disposables.push(vs.commands.registerCommand("_dart.hotReload.touchBar", (args) => vs.commands.executeCommand("_dart.hotReload.withSave", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.hotReload", (args) => vs.commands.executeCommand("dart.hotReload", args)));
        this.disposables.push(vs.commands.registerCommand("_dart.hotReload.withSave", async (args) => {
            try {
                const hasDirtyFiles = !!vs.workspace.textDocuments.find((td) => td.isDirty);
                if (hasDirtyFiles) {
                    // Trigger save, but don't wait more than 100ms because if the user has configured codeActionsOnSave this might
                    // take a while. A request for a better API is here:
                    //   https://github.com/microsoft/vscode/issues/191639
                    await Promise.race([
                        vs.workspace.saveAll(false),
                        new Promise((resolve) => setTimeout(resolve, 100)),
                    ]);
                }
            }
            finally {
                await vs.commands.executeCommand("dart.hotReload");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("dart.hotReload", async (args) => {
            if (!exports.debugSessions.length)
                return;
            const onlyDart = !!args?.onlyDart;
            const onlyFlutter = !!args?.onlyFlutter;
            this.onWillHotReloadEmitter.fire();
            await Promise.all(exports.debugSessions.map(async (s) => {
                const shouldReload = onlyDart
                    ? (s.debuggerType === enums_1.DebuggerType.Dart || s.debuggerType === enums_1.DebuggerType.Web)
                    : onlyFlutter
                        ? (s.debuggerType === enums_1.DebuggerType.Flutter)
                        : true;
                if (shouldReload)
                    await s.session.customRequest("hotReload", args);
            }));
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.hotRestart", async (args) => {
            if (!exports.debugSessions.length)
                return;
            this.onWillHotRestartEmitter.fire();
            await Promise.all(exports.debugSessions.map((s) => s.session.customRequest("hotRestart", args)));
        }));
        this.disposables.push(vs.commands.registerCommand("dart.startDebugging", async (arg) => {
            const resource = "resource" in arg ? arg.resource : arg;
            let launchTemplate = "launchTemplate" in arg ? arg.launchTemplate : undefined;
            launchTemplate ??= (0, debugger_1.getLaunchConfigDefaultTemplate)(resource, true);
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: false,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            await vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.startWithoutDebugging", async (arg) => {
            const resource = "resource" in arg ? arg.resource : arg;
            let launchTemplate = "launchTemplate" in arg ? arg.launchTemplate : undefined;
            launchTemplate ??= (0, debugger_1.getLaunchConfigDefaultTemplate)(resource, false);
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: true,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            await vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.createLaunchConfiguration", this.createLaunchConfiguration, this));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastDebugSession", async () => {
            if (LastDebugSession.debugConfig) {
                await vs.debug.startDebugging(LastDebugSession.workspaceFolder, LastDebugSession.debugConfig);
            }
            else {
                void vs.window.showErrorMessage("There is no previous debug session to run.");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastTestDebugSession", async () => {
            if (LastTestDebugSession.debugConfig) {
                await vs.debug.startDebugging(LastTestDebugSession.workspaceFolder, LastTestDebugSession.debugConfig);
            }
            else {
                void vs.window.showErrorMessage("There is no previous test session to run.");
            }
        }));
        // Attach commands.
        this.disposables.push(vs.commands.registerCommand("dart.attach", async () => {
            await vs.debug.startDebugging(undefined, {
                name: "Dart: Attach to Process",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.attachProcess", async () => {
            await vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Process",
                request: "attach",
                type: "dart",
                vmServiceUri: "${command:dart.promptForVmService}",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.runProfileMode", async () => {
            await vs.debug.startDebugging(undefined, {
                flutterMode: "profile",
                name: "Flutter: Run in Profile Mode",
                openDevTools: "performance",
                request: "launch",
                type: "dart",
            });
            if (!this.context.hasNotifiedAboutProfileModeDefaultConfiguration) {
                this.context.hasNotifiedAboutProfileModeDefaultConfiguration = true;
                void vs.window.showInformationMessage("Profiling Flutter app with default configuration. To customize this, create a launch configuration (and include 'flutterMode': 'profile').");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.runReleaseMode", async () => {
            await vs.debug.startDebugging(undefined, {
                flutterMode: "release",
                name: "Flutter: Run in Release Mode",
                request: "launch",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.attach", async () => {
            await vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Device",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("dart.promptForVmService", async (defaultValueOrConfig) => {
            const defaultValue = typeof defaultValueOrConfig === "string" ? defaultValueOrConfig : undefined;
            return vs.window.showInputBox({
                ignoreFocusOut: true, // Don't close the window if the user tabs away to get the uri
                placeHolder: "Paste an VM Service URI",
                prompt: "Enter VM Service URI",
                validateInput: (input) => {
                    if (!input)
                        return;
                    input = input.trim();
                    // eslint-disable-next-line id-blacklist
                    if (Number.isInteger(parseFloat(input)))
                        return;
                    // Uri.parse doesn't seem to work as expected, so do our own basic validation
                    // https://github.com/Microsoft/vscode/issues/49818
                    if (!input.startsWith("http://") && !input.startsWith("https://")
                        && !input.startsWith("ws://") && !input.startsWith("wss://"))
                        return "Please enter a valid VM Service URI";
                },
                value: defaultValue,
            });
        }));
        // Debug options.
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
        else if (config_1.config.debugSdkLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodeSdk;
        else if (config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackages;
        this.disposables.push(vs.commands.registerCommand("_dart.toggleDebugOptions", this.toggleDebugOptions, this));
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        this.debugOptions.tooltip = `Controls whether to step into or stop at breakpoints in only files in this workspace or also those in SDK and/or external Pub packages`;
        this.debugOptions.command = "_dart.toggleDebugOptions";
    }
    async createLaunchConfiguration(resourceUri) {
        if (!resourceUri || resourceUri.scheme !== "file")
            return;
        const entryScriptPath = (0, fs_1.fsPath)(resourceUri);
        if (!(0, utils_3.isDartFile)(entryScriptPath))
            return;
        const workspaceFolder = vs.workspace.getWorkspaceFolder(resourceUri);
        if (!workspaceFolder)
            return;
        const workspaceFolderPath = (0, fs_1.fsPath)(workspaceFolder.uri);
        const projectFolderPath = (0, project_1.locateBestProjectRoot)(entryScriptPath) ?? workspaceFolderPath;
        const relativeCwdPath = path.relative(workspaceFolderPath, projectFolderPath);
        const relativeEntryScriptPath = path.relative(projectFolderPath, entryScriptPath);
        const projectType = (0, fs_1.isFlutterProjectFolder)(projectFolderPath) ? "Flutter" : "Dart";
        const name = `${projectType} (${relativeEntryScriptPath})`;
        const newLaunchConfig = {
            name,
            type: "dart",
            // eslint-disable-next-line @typescript-eslint/tslint/config
            request: "launch",
            cwd: relativeCwdPath ? relativeCwdPath : undefined,
            program: relativeEntryScriptPath,
        };
        // Add to the launch.json config.
        const launchFile = vs.workspace.getConfiguration("launch", workspaceFolder);
        // If we're in a code-workspace that already has workspace-level launch configs,
        // we should add to that. Otherwise add directly to the workspace folder.
        const configInspect = launchFile.inspect("configurations");
        const workspaceConfigs = configInspect?.workspaceValue ?? [];
        const workspaceFolderConfigs = configInspect?.workspaceFolderValue ?? [];
        const hasWorkspaceConfigs = !!vs.workspace.workspaceFile && !!workspaceConfigs.length;
        const configs = hasWorkspaceConfigs ? workspaceConfigs : workspaceFolderConfigs;
        const target = hasWorkspaceConfigs ? vs.ConfigurationTarget.Workspace : vs.ConfigurationTarget.WorkspaceFolder;
        configs.push(newLaunchConfig);
        await launchFile.update("configurations", configs, target);
        // Open the correct file based on workspace or workspace folder.
        if (hasWorkspaceConfigs) {
            void vs.commands.executeCommand("workbench.action.openWorkspaceConfigFile");
        }
        else {
            const launchConfig = path.join(workspaceFolderPath, ".vscode", "launch.json");
            void vs.workspace.openTextDocument(launchConfig).then((doc) => vs.window.showTextDocument(doc));
        }
    }
    async getDebugSession() {
        if (exports.debugSessions.length === 0) {
            this.logger.info("No debug session to use!");
            return undefined;
        }
        else if (exports.debugSessions.length === 1) {
            this.logger.info("Using only available debug session");
            return exports.debugSessions[0];
        }
        else {
            this.logger.info("Multiple debug sessions available, will prompt user:");
            const sessions = exports.debugSessions.map((s) => ({
                description: s.session.workspaceFolder ? s.session.workspaceFolder.name : undefined,
                detail: s.session.configuration.deviceName || `Started ${s.sessionStart.toLocaleTimeString()}`,
                label: s.session.name,
                session: s,
            }));
            for (const session of sessions)
                this.logger.info(`${session.label} ${session.description} (${session.detail})`);
            const selectedItem = await vs.window.showQuickPick(sessions, { placeHolder: "Which debug session?" });
            return selectedItem && selectedItem.session;
        }
    }
    handleBreakpointChange(e) {
        if (hasPromptedAboutDebugSettings)
            return;
        for (const bp of e.added)
            this.promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(bp);
    }
    promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(e) {
        if (hasPromptedAboutDebugSettings || this.context.breakpointInNonDebuggableFileDoNotShowAgain || !(e instanceof vs.SourceBreakpoint) || !e.enabled)
            return;
        // Don't consider non-files or non-Dart files.
        if (e.location.uri.scheme !== "file" || !(0, fs_1.fsPath)(e.location.uri).toLocaleLowerCase().endsWith(".dart"))
            return;
        // If it's inside the workspace we don't want to prompt.
        if (vs.workspace.getWorkspaceFolder(e.location.uri))
            return;
        const isSdkBreakpoint = (0, fs_1.isWithinPath)((0, fs_1.fsPath)(e.location.uri), this.workspaceContext.sdks.dart);
        if (isSdkBreakpoint && config_1.config.debugSdkLibraries)
            return;
        if (!isSdkBreakpoint && config_1.config.debugExternalPackageLibraries)
            return;
        hasPromptedAboutDebugSettings = true;
        const message = `You have a breakpoint outside of your workspace but debug settings are set to 'my code'. Would you like to change settings? You can also change this from the status bar while debugging.`;
        const debugJustMyCodeAction = "Debug my code";
        const debugEverything = "Debug all code";
        void vs.window.showWarningMessage(message, debugJustMyCodeAction, debugEverything, constants_1.doNotAskAgainAction).then((choice) => {
            if (choice === constants_1.doNotAskAgainAction)
                this.context.breakpointInNonDebuggableFileDoNotShowAgain = true;
            if (choice !== debugEverything)
                return;
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
            this.applyNewDebugOption();
        });
    }
    updateDebugSessionsStatus() {
        if (!exports.debugSessions.length) {
            this.debugSessionsStatusItem.text = "No Debug Sessions";
            this.debugSessionsStatusItem.command = undefined;
            return;
        }
        this.debugSessionsStatusItem.text = `${exports.debugSessions.length} Debug Session${exports.debugSessions.length === 1 ? "" : "s"}`;
        this.debugSessionsStatusItem.command = {
            command: "dart.copyVmServiceUri",
            title: "copy vm service",
        };
    }
    handleDebugSessionStart(s) {
        if (s.type !== "dart")
            return;
        const session = new debug_1.DartDebugSessionInformation(s, s.configuration);
        // If we're the first fresh debug session, reset all settings to default.
        // Subsequent launches will inherit the "current" values.
        if (exports.debugSessions.length === 0)
            this.vmServices.resetToDefaults();
        exports.debugSessions.push(session);
        this.updateDebugSessionsStatus();
        debugSessionStartedEmitter.fire(session);
        debugSessionsChangedEmitter.fire();
        if (s.configuration.debuggerType === enums_1.DebuggerType.Flutter || s.configuration.debuggerType === enums_1.DebuggerType.Web) {
            // TODO(dantup): Can these use session.flutterMode in preference?
            const isProfileMode = s.configuration.toolArgs?.includes("--profile");
            const isReleaseMode = s.configuration.toolArgs?.includes("--release");
            if (isReleaseMode) {
                void vs.commands.executeCommand("setContext", constants_contexts_1.isInFlutterReleaseModeDebugSessionContext, true);
            }
            else if (isProfileMode) {
                exports.isInFlutterProfileModeDebugSession = true;
                void vs.commands.executeCommand("setContext", constants_contexts_1.isInFlutterProfileModeDebugSessionContext, true);
            }
            else {
                exports.isInFlutterDebugModeDebugSession = true;
                void vs.commands.executeCommand("setContext", constants_contexts_1.isInFlutterDebugModeDebugSessionContext, true);
            }
        }
        else if (s.configuration.debuggerType === enums_1.DebuggerType.Dart) {
            exports.isInDartDebugSession = true;
            void vs.commands.executeCommand("setContext", constants_contexts_1.isInDartDebugSessionContext, true);
        }
        // Process any queued events that came in before the session start
        // event.
        const eventsToProcess = pendingCustomEvents.filter((e) => e.session.id === s.id);
        pendingCustomEvents = pendingCustomEvents.filter((e) => e.session.id !== s.id);
        eventsToProcess.forEach((e) => {
            this.logger.info(`Processing delayed event ${e.event} for session ${e.session.id}`);
            void this.handleCustomEventWithSession(session, e);
        });
        this.debugOptions.show();
    }
    handleDebugSessionCustomEvent(e) {
        if (this.handleCustomEvent(e))
            return;
        const session = exports.debugSessions.find((ds) => ds.session.id === e.session.id);
        if (!session) {
            this.logger.info(`Did not find session ${e.session.id} to handle ${e.event}. There were ${exports.debugSessions.length} sessions:\n${exports.debugSessions.map((ds) => `  ${ds.session.id}`).join("\n")}`);
            this.logger.info(`Event will be queued and processed when the session start event fires`);
            pendingCustomEvents.push(e);
            return;
        }
        void this.handleCustomEventWithSession(session, e);
    }
    handleDebugSessionEnd(s) {
        const sessionIndex = exports.debugSessions.findIndex((ds) => ds.session.id === s.id);
        if (sessionIndex === -1)
            return;
        // Grab the session and remove it from the list so we don't try to interact with it anymore.
        const session = exports.debugSessions[sessionIndex];
        session.hasEnded = true;
        exports.debugSessions.splice(sessionIndex, 1);
        this.updateDebugSessionsStatus();
        debugSessionStoppedEmitter.fire(session);
        debugSessionsChangedEmitter.fire();
        // Close any in-progress progress notifications.
        for (const progressId of Object.keys(session.progress))
            session.progress[progressId]?.complete();
        const debugSessionEnd = new Date();
        // If this was the last session terminating, then remove all the flags for which service extensions are supported.
        // Really we should track these per-session, but the changes of them being different given we only support one
        // SDK at a time are practically zero.
        if (exports.debugSessions.length === 0) {
            this.vmServices.markAllServicesUnloaded();
            this.vmServices.markAllServiceExtensionsUnloaded();
            this.debugOptions.hide();
            this.debugMetrics.hide();
            exports.isInFlutterDebugModeDebugSession = false;
            exports.isInFlutterProfileModeDebugSession = false;
            for (const debugContext of [
                constants_contexts_1.isInDartDebugSessionContext,
                constants_contexts_1.isInFlutterDebugModeDebugSessionContext,
                constants_contexts_1.isInFlutterProfileModeDebugSessionContext,
                constants_contexts_1.isInFlutterReleaseModeDebugSessionContext,
            ])
                void vs.commands.executeCommand("setContext", debugContext, false);
        }
    }
    handleCustomEvent(e) {
        const event = e.event;
        const body = e.body;
        if (event === "dart.log") {
            const message = e.body;
            const logMessage = `[${e.session.name}] ${message.message}`;
            switch (message.severity) {
                case enums_1.LogSeverity.Warn:
                    this.logger.warn(logMessage, message.category);
                    break;
                case enums_1.LogSeverity.Error:
                    this.logger.error(logMessage, message.category);
                    break;
                default:
                    this.logger.info(logMessage, message.category);
            }
        }
        else if (event === "dart.hotRestartRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.onWillHotRestartEmitter.fire();
        }
        else if (event === "dart.hotReloadRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.onWillHotReloadEmitter.fire();
        }
        else if (event === "dart.debugMetrics") {
            const memory = body.memory;
            const message = `${Math.ceil(memory.current / 1024 / 1024)}MB of ${Math.ceil(memory.total / 1024 / 1024)}MB`;
            this.debugMetrics.text = message;
            this.debugMetrics.tooltip = "This is the amount of memory being consumed by your applications heaps (out of what has been allocated).\n\nNote: memory usage shown in debug builds may not be indicative of usage in release builds. Use profile builds for more accurate figures when testing memory usage.";
            this.debugMetrics.show();
        }
        else if (event === "dart.toolEvent") {
            const kind = body.kind;
            const data = body.data;
            switch (kind) {
                case "navigate":
                    const uri = data.resolvedFileUri ?? data.resolvedUri ?? data.fileUri ?? data.uri ?? data.file;
                    const line = data.line;
                    const col = data.column;
                    const isFlutterInspectorNavigation = data.source === "flutter.inspector";
                    if (uri && uri.startsWith("file://") && line && col) {
                        // Only navigate if it's not from inspector, or is from inspector but we're not in full-width mode.
                        const navigate = !isFlutterInspectorNavigation || this.devTools.getDevToolsLocation(constants_1.widgetInspectorPage.id) !== "active";
                        if (navigate)
                            void vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.parse(uri), line, col, true);
                        if (isFlutterInspectorNavigation && this.isInspectingWidget && this.autoCancelNextInspectWidgetMode) {
                            // Add a short delay because this will remove the visible selection.
                            setTimeout(() => vs.commands.executeCommand("flutter.cancelInspectWidget"), 1000);
                        }
                    }
                    break;
                default:
                    return false;
            }
        }
        else if (event === "dart.navigate") {
            if (body.file && body.line && body.column) {
                // Only navigate if it's not from inspector, or is from inspector but we're not in full-width mode.
                const navigate = !body.fromInspector || this.devTools.getDevToolsLocation(constants_1.widgetInspectorPage.id) !== "active";
                if (navigate)
                    void vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.parse(body.file), body.line, body.column, body.inOtherEditorColumn);
                if (this.isInspectingWidget && this.autoCancelNextInspectWidgetMode) {
                    // Add a short delay because this will remove the visible selection.
                    setTimeout(() => vs.commands.executeCommand("flutter.cancelInspectWidget"), 1000);
                }
            }
        }
        else {
            // Not handled, will fall through in the caller.
            return false;
        }
        return true;
    }
    async handleCustomEventWithSession(session, e) {
        this.vmServices.handleDebugEvent(session, e)
            .catch((e) => this.logger.error(e));
        const event = e.event;
        const body = e.body;
        if (event === "dart.webLaunchUrl") {
            const launched = !!body.launched;
            if (!launched && !session.session.configuration.suppressWebServerDeviceBrowserLaunch) {
                try {
                    await utils_2.envUtils.openInBrowser(body.url, this.logger);
                }
                catch (e) {
                    this.logger.error(`Failed to launch URL from Flutter app.webLaunchUrl event: ${body.url}`);
                }
            }
        }
        else if (event === "dart.exposeUrl") {
            const originalUrl = body.url;
            try {
                const exposedUrl = await utils_2.envUtils.exposeUrl(originalUrl, this.logger);
                await session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl });
            }
            catch (e) {
                this.logger.error(`Failed to expose URL ${originalUrl}: ${e}`);
                await session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl: originalUrl });
            }
        }
        else if (event === "flutter.forwardedEvent") {
            const event = body.event;
            const params = body.params;
            switch (event) {
                case "app.webLaunchUrl":
                    const url = params.url;
                    const launched = !!params.launched;
                    if (!launched && !session.session.configuration.suppressWebServerDeviceBrowserLaunch) {
                        try {
                            await utils_2.envUtils.openInBrowser(url, this.logger);
                        }
                        catch (e) {
                            this.logger.error(`Failed to launch URL from Flutter app.webLaunchUrl event: ${url}`);
                        }
                    }
            }
        }
        else if (event === "flutter.forwardedRequest") {
            const id = body.id;
            const method = body.method;
            const params = body.params;
            let result;
            let error;
            try {
                switch (method) {
                    case "app.exposeUrl":
                        const originalUrl = params.url;
                        let url;
                        try {
                            url = await utils_2.envUtils.exposeUrl(originalUrl, this.logger);
                        }
                        catch (e) {
                            this.logger.error(`Failed to expose URL ${originalUrl}: ${e}`);
                            url = originalUrl;
                        }
                        result = { url };
                        break;
                }
            }
            catch (e) {
                error = `${e}`;
            }
            void session.session.customRequest("flutter.sendForwardedRequestResponse", { id, result, error });
        }
        else if (event === "dart.debuggerUris") {
            session.observatoryUri = body.observatoryUri;
            session.vmServiceUri = body.vmServiceUri;
            session.clientVmServiceUri = body.clientVmServiceUri;
            this.onDebugSessionVmServiceAvailableEmitter.fire(session);
            debugSessionChangedEmitter.fire(session);
            debugSessionsChangedEmitter.fire();
            // Open or prompt for DevTools when appropriate.
            const debuggerType = session.session.configuration.debuggerType;
            if (debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.Web) {
                if (session.session.configuration.openDevTools) {
                    const pageId = session.session.configuration.openDevTools;
                    if (pageId) {
                        void vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, pageId, commandSource: constants_1.CommandSource.launchConfiguration });
                    }
                    else {
                        void vs.window.showWarningMessage(`Debug configuration contain an invalid DevTools page '${pageId}' in 'openDevTools'`);
                    }
                }
                else if (config_1.config.openDevTools !== "never") {
                    const shouldLaunch = debuggerType !== enums_1.DebuggerType.Dart || config_1.config.openDevTools === "always";
                    if (shouldLaunch) {
                        // If embedded DevTools is enabled and it's a Flutter app, assume the user wants the Widget inspector.
                        // Otherwise, DevTools will be launched externally (since it's not clear which page they may want).
                        const page = debuggerType === enums_1.DebuggerType.Flutter ? constants_1.widgetInspectorPage : null;
                        const location = page ? undefined : "external";
                        void vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, pageId: page?.id, location, commandSource: constants_1.CommandSource.onDebugAutomatic });
                    }
                }
                else if (debuggerType === enums_1.DebuggerType.Flutter) {
                    void (0, user_prompts_1.showDevToolsNotificationIfAppropriate)(this.context).then((res) => {
                        if (res.shouldAlwaysOpen)
                            void config_1.config.setOpenDevTools("flutter");
                    });
                }
            }
        }
        else if (event === "dart.progressStart") {
            // When a debug session is restarted by VS Code (eg. not handled by the DA), the session-end event
            // will not fire so we need to clean up the "Terminating debug session" message manually. Doing it here
            // means it will vanish at the same time as the new one appears, so there are no gaps in progress indicators.
            if (body.progressId === constants_1.debugLaunchProgressId) {
                session.progress[constants_1.debugTerminatingProgressId]?.complete();
                delete session.progress[constants_1.debugTerminatingProgressId];
            }
            const progressId = body.progressId;
            const isHotEvent = progressId?.includes("reload") || progressId?.includes("restart");
            const progressLocation = isHotEvent && config_1.config.hotReloadProgress === "statusBar" ? vs.ProgressLocation.Window : vs.ProgressLocation.Notification;
            await vs.window.withProgress(
            // TODO: This was previously Window to match what we'd get using DAP progress
            // notifications but users prefer larger notifications as they're easier to
            // see (especially when it comes to things like waiting for debug extension).
            // https://github.com/Dart-Code/Dart-Code/issues/2597
            // If this is changed back, ensure the waiting-for-debug-extension notification
            // is still displayed with additional description.
            { location: progressLocation, title: body.title }, (progress) => {
                // Complete any existing one with this ID.
                session.progress[body.progressId]?.complete();
                // Build a new progress and store it in the session.
                const completer = new utils_1.PromiseCompleter();
                session.progress[body.progressId] = new debug_1.ProgressMessage(progress, completer);
                if (body.message)
                    session.progress[body.progressId]?.report(body.message);
                return completer.promise;
            });
        }
        else if (event === "dart.progressUpdate") {
            session.progress[body.progressId]?.report(body.message);
        }
        else if (event === "dart.progressEnd") {
            if (body.message) {
                session.progress[body.progressId]?.report(body.message);
                await new Promise((resolve) => setTimeout(resolve, 400));
            }
            session.progress[body.progressId]?.complete();
        }
        else if (event === "dart.flutter.widgetErrorInspectData") {
            if (this.suppressFlutterWidgetErrors || !config_1.config.showInspectorNotificationsForWidgetErrors)
                return;
            const data = e.body;
            if (data.devToolsUrl !== (await this.devTools.devtoolsUrl))
                return;
            // To avoid spam, when we show this dialog we will set a flag that prevents any more
            // of these types of dialogs until it is dismissed or 5 seconds have passed.
            this.suppressFlutterWidgetErrors = true;
            const timer = setTimeout(() => this.suppressFlutterWidgetErrors = false, 5000);
            const inspectAction = `Inspect Widget`;
            const choice = await vs.window.showWarningMessage(data.errorDescription, inspectAction, constants_1.doNotAskAgainAction);
            if (choice === inspectAction && session.vmServiceUri) {
                void this.devTools.spawn(session, {
                    inspectorRef: data.inspectorReference,
                    pageId: constants_1.widgetInspectorPage.id,
                });
            }
            else if (choice === constants_1.doNotAskAgainAction) {
                void config_1.config.setShowInspectorNotificationsForWidgetErrors(false);
            }
            clearTimeout(timer);
            this.suppressFlutterWidgetErrors = false;
        }
        else if (event === "flutter.appStarted") {
            session.hasStarted = true;
            debugSessionChangedEmitter.fire(session);
            debugSessionsChangedEmitter.fire();
            // In noDebug mode, we won't see services registered but we can tell if Hot Reload
            // is available.
            if (session.supportsHotReload)
                this.vmServices.handleServiceRegistered(enums_1.VmService.HotReload, enums_1.VmService.HotReload);
        }
        else if (event === "flutter.appStart") {
            session.flutterMode = body?.mode;
            session.flutterDeviceId = body?.deviceId;
            session.supportsHotReload = body?.supportsRestart;
            debugSessionChangedEmitter.fire(session);
            debugSessionsChangedEmitter.fire();
        }
    }
    toggleDebugOptions() {
        // -1 is because we skip the last combination when toggling since it seems uncommon.
        this.currentDebugOption = (this.currentDebugOption + 1) % (enums_1.debugOptionNames.length - 1);
        this.applyNewDebugOption();
    }
    applyNewDebugOption() {
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        const debugExternalPackageLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodePackages || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        const debugSdkLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodeSdk || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        void config_1.config.setGlobalDebugExternalPackageLibraries(debugExternalPackageLibraries);
        void config_1.config.setGlobalDebugSdkLibraries(debugSdkLibraries);
        exports.debugSessions.forEach((session) => {
            void session.session.customRequest("updateDebugOptions", {
                debugExternalPackageLibraries,
                debugSdkLibraries,
            });
        });
    }
    setSendLogsToClient(enabled) {
        // Only send values for sessions that didn't already have logging enabled.
        exports.debugSessions.filter((d) => !d.session.configuration.sendLogsToClient).forEach(async (session) => {
            try {
                await session.session.customRequest("updateSendLogsToClient", {
                    enabled,
                });
            }
            catch {
                // Older SDKs don't support this, so just do nothing.
            }
        });
    }
    updateRunnableContexts() {
        const editor = vs.window.activeTextEditor;
        const documentUri = editor?.document.uri;
        if (!documentUri || documentUri.scheme !== "file")
            return;
        const documentPath = (0, fs_1.fsPath)(documentUri);
        // Try simple check first to avoid possible out-of-sync outline.
        let isRunnable = (0, utils_3.isValidEntryFile)(documentPath);
        if (!isRunnable) {
            const outline = this.fileTracker?.getOutlineFor(documentUri);
            isRunnable = !!outline?.children?.find((c) => c.element.name === "main");
        }
        void vs.commands.executeCommand("setContext", CURRENT_FILE_RUNNABLE, isRunnable);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DebugCommands = DebugCommands;


/***/ }),

/***/ 1777:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditCommands = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(1894);
const editors_1 = __webpack_require__(9451);
const terminals_1 = __webpack_require__(5850);
class EditCommands {
    commands = [];
    constructor() {
        this.commands.push(vs.commands.registerCommand("_dart.jumpToLineColInUri", this.jumpToLineColInUri, this), vs.commands.registerCommand("_dart.showCode", utils_1.showCode, this), vs.commands.registerCommand("dart.writeRecommendedSettings", this.writeRecommendedSettings, this), vs.commands.registerCommand("dart.printSelectionToTerminal", this.printSelectionToTerminal, this), vs.commands.registerCommand("dart.toggleLineComment", this.toggleLineComment, this), vs.commands.registerCommand("dart.toggleDartdocComment", this.toggleDartdocComment, this));
    }
    async jumpToLineColInUri(uri, lineNumber, columnNumber, inOtherEditorColumn) {
        if (!uri || uri.scheme !== "file")
            return;
        // When navigating while using the inspector, we don't expect this file to replace
        // the inspector tab, so we always target a column that's showing an editor.
        const column = inOtherEditorColumn
            ? (0, utils_1.firstEditorColumn)() || vs.ViewColumn.Beside
            : vs.ViewColumn.Active;
        const doc = await vs.workspace.openTextDocument(uri);
        const editor = await vs.window.showTextDocument(doc, column, inOtherEditorColumn);
        if (lineNumber) {
            const line = doc.lineAt(lineNumber > 0 ? lineNumber - 1 : 0);
            if (!columnNumber || columnNumber > line.range.end.character)
                columnNumber = line.firstNonWhitespaceCharacterIndex;
            else if (columnNumber > 0) {
                columnNumber--;
            }
            const char = line.range.start.translate({ characterDelta: columnNumber });
            (0, utils_1.showCode)(editor, line.range, line.range, new vs.Range(char, char));
        }
    }
    async writeRecommendedSettings(options) {
        const topLevelConfig = vs.workspace.getConfiguration("", null);
        const dartLanguageConfig = topLevelConfig.inspect("[dart]");
        const existingConfig = dartLanguageConfig ? dartLanguageConfig.globalValue : undefined;
        const newValues = Object.assign({}, constants_1.dartRecommendedConfig, existingConfig);
        await topLevelConfig.update("[dart]", newValues, vs.ConfigurationTarget.Global);
        if (options?.showNotification !== false) {
            const action = await vs.window.showInformationMessage("Recommended settings were written to the [dart] section of your global settings file", constants_1.openSettingsAction);
            if (action === constants_1.openSettingsAction)
                await vs.commands.executeCommand("workbench.action.openSettingsJson", { revealSetting: { key: "[dart]" } });
        }
    }
    async printSelectionToTerminal() {
        const editor = (0, editors_1.getActiveRealFileEditor)();
        const selection = editor?.selection;
        const text = editor?.document?.getText(selection);
        if (text) {
            (0, terminals_1.writeToPseudoTerminal)([text]);
        }
    }
    toggleDartdocComment() {
        return this.toggleLineComment(true);
    }
    async toggleLineComment(onlyDartdoc = false) {
        const editor = (0, editors_1.getActiveRealFileEditor)();
        if (!editor || !editor.selections.length)
            return;
        const document = editor.document;
        const selections = editor.selections;
        // Track the prefix that matches all lines in all selections.
        // If any line does not start with `///` then it cannot be TRIPLE.
        // If any line does not start with '//' then it cannot be DOUBLE.
        // We start from the highest and work down as we find lines that don't match.
        let commonPrefix = "TRIPLE";
        check: {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    const line = document.lineAt(lineNumber);
                    // Skip over blank lines, as they won't have comment markers and shouldn't
                    // influence which common prefix we find.
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const text = line.text.trim();
                    if (commonPrefix === "TRIPLE" && !text.startsWith("///"))
                        commonPrefix = text.startsWith("//") ? "DOUBLE" : "NONE";
                    else if (commonPrefix === "DOUBLE" && !text.startsWith("//"))
                        commonPrefix = "NONE";
                    // Any time we hit NONE, we can bail out.
                    if (commonPrefix === "NONE")
                        break check;
                }
            }
        }
        if (onlyDartdoc) {
            switch (commonPrefix) {
                case "NONE":
                    // If no prefix, insert triples.
                    await this.prefixLines(editor, selections, "/// ");
                    break;
                case "DOUBLE":
                    // If already double, just add the additional one slash.
                    await this.prefixLines(editor, selections, "/");
                    break;
                case "TRIPLE":
                    // If already triple, remove slashes.
                    await this.removeLinePrefixes(editor, selections, ["/// ", "///"]);
                    break;
            }
        }
        else {
            switch (commonPrefix) {
                case "NONE":
                    // If no prefix, insert doubles.
                    await this.prefixLines(editor, selections, "// ");
                    break;
                case "DOUBLE":
                    // If already double, add an additional slash to make triple.
                    await this.prefixLines(editor, selections, "/");
                    break;
                case "TRIPLE":
                    // If already triple, remove slashes.
                    await this.removeLinePrefixes(editor, selections, ["/// ", "///"]);
                    break;
            }
        }
    }
    async prefixLines(editor, selections, prefix) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        // Find the minimum indent, so we can insert all slashes at the same level even if
        // there is indented code.
        let minIndent;
        for (const selection of selections) {
            for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                const line = document.lineAt(lineNumber);
                if (line.isEmptyOrWhitespace)
                    continue;
                if (!minIndent || line.firstNonWhitespaceCharacterIndex < minIndent)
                    minIndent = line.firstNonWhitespaceCharacterIndex;
            }
        }
        await editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const insertionPoint = line.range.start.translate(0, minIndent);
                    edit.insert(insertionPoint, prefix);
                }
            }
        });
    }
    async removeLinePrefixes(editor, selections, prefixes) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        await editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const lineContentStart = line.range.start.translate(0, line.firstNonWhitespaceCharacterIndex);
                    for (const prefix of prefixes) {
                        const possiblePrefixRange = new vs.Range(lineContentStart, lineContentStart.translate(0, prefix.length));
                        const possiblePrefix = document.getText(possiblePrefixRange);
                        if (possiblePrefix === prefix) {
                            edit.delete(possiblePrefixRange);
                            break;
                        }
                    }
                }
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.EditCommands = EditCommands;


/***/ }),

/***/ 3470:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DasEditCommands = void 0;
exports.hasOverlappingEdits = hasOverlappingEdits;
const fs = __importStar(__webpack_require__(9896));
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const editors = __importStar(__webpack_require__(9451));
class DasEditCommands {
    logger;
    context;
    analyzer;
    commands = [];
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.commands.push(vs.commands.registerCommand("_dart.organizeImports", this.organizeImports, this), vs.commands.registerCommand("dart.sortMembers", this.sortMembers, this), vs.commands.registerCommand("_dart.applySourceChange", this.applyEdits, this), vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this));
    }
    getActiveDoc() {
        return this.getActiveEditor()?.document;
    }
    getActiveEditor() {
        return editors.getActiveRealFileEditor();
    }
    organizeImports(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editOrganizeDirectives, "Organize Imports", document);
    }
    sortMembers(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editSortMembers, "Sort Members", document);
    }
    async completeStatement() {
        const editor = this.getActiveEditor();
        if (!editor || !editor.selection || !this.analyzer.capabilities.hasCompleteStatementFix)
            return;
        const document = editor.document;
        const file = (0, fs_1.fsPath)(document.uri);
        const offset = document.offsetAt(editor.selection.end);
        const res = await this.analyzer.editGetStatementCompletion({ file, offset });
        if (res && res.change)
            await this.applyEdits(document, res.change);
    }
    async sendEdit(f, commandName, document) {
        if (!document || !editors.isDartDocument(document)) {
            void vs.window.showWarningMessage("Not a Dart file.");
            return;
        }
        const originalDocumentVersion = document.version;
        f = f.bind(this.analyzer); // Yay JavaScript!
        try {
            const response = await f({ file: (0, fs_1.fsPath)(document.uri) });
            const edit = response.edit;
            if (edit.edits.length === 0)
                return;
            if (document.isClosed) {
                void vs.window.showErrorMessage(`Error running ${commandName}: Document has been closed.`);
                return;
            }
            if (document.version !== originalDocumentVersion) {
                void vs.window.showErrorMessage(`Error running ${commandName}: Document has been modified.`);
                return;
            }
            const editBuilder = new vs.WorkspaceEdit();
            edit.edits.forEach((edit) => {
                const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                editBuilder.replace(document.uri, range, edit.replacement);
            });
            await vs.workspace.applyEdit(editBuilder);
        }
        catch (error) {
            void vs.window.showErrorMessage(`Error running ${commandName}: ${(0, utils_1.errorString)(error)}.`);
        }
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
    async applyEdits(initiatingDocument, change) {
        // We can only apply with snippets if there's a single change.
        if (change.edits.length === 1 && change.linkedEditGroups && change.linkedEditGroups.length !== 0)
            return this.applyEditsWithSnippets(initiatingDocument, change);
        // VS Code expects offsets to be based on the original document, but the analysis server provides
        // them assuming all previous edits have already been made. This means if the server provides us a
        // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
        // If this happens; we will fall back to sequential edits and write a warning.
        const hasProblematicEdits = hasOverlappingEdits(change);
        if (hasProblematicEdits) {
            this.logger.warn("Falling back to sequential edits due to overlapping edits in server.");
        }
        const applyEditsSequentially = hasProblematicEdits;
        // Otherwise, just make all the edits without the snippets.
        let changes = applyEditsSequentially ? undefined : new vs.WorkspaceEdit();
        for (const edit of change.edits) {
            const uri = vs.Uri.file(edit.file);
            // We can only create files with edits that are at 0/0 because we can't open the document if it doesn't exist.
            // If we create the file ourselves, it won't go into the single undo buffer.
            if (!fs.existsSync(edit.file) && edit.edits.find((e) => e.offset !== 0 || e.length !== 0)) {
                this.logger.error(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                void vs.window.showErrorMessage(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                continue;
            }
            const document = fs.existsSync(edit.file) ? await vs.workspace.openTextDocument(uri) : undefined;
            if (changes)
                changes.createFile(uri, { ignoreIfExists: true });
            for (const e of edit.edits) {
                if (!changes) {
                    changes = new vs.WorkspaceEdit();
                    changes.createFile(uri, { ignoreIfExists: true });
                }
                const range = document
                    ? new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length))
                    : new vs.Range(new vs.Position(0, 0), new vs.Position(0, 0));
                changes.replace(uri, range, e.replacement);
                if (applyEditsSequentially) {
                    await vs.workspace.applyEdit(changes);
                    changes = undefined;
                }
            }
        }
        // If we weren't applying sequentially
        if (changes)
            await vs.workspace.applyEdit(changes);
        // Set the cursor position.
        if (change.selection) {
            const uri = vs.Uri.file(change.selection.file);
            const document = await vs.workspace.openTextDocument(uri);
            const editor = await vs.window.showTextDocument(document);
            const pos = document.positionAt(change.selection.offset);
            const selection = new vs.Selection(pos, pos);
            editor.selection = selection;
        }
    }
    async applyEditsWithSnippets(initiatingDocument, change) {
        const edit = change.edits[0];
        const document = await vs.workspace.openTextDocument(edit.file);
        const editor = await vs.window.showTextDocument(document);
        // Apply of all of the edits.
        await editor.edit((eb) => {
            edit.edits.forEach((e) => {
                eb.replace(new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
            });
        });
        const documentText = editor.document.getText();
        // Create a list of all the placeholders.
        const placeholders = [];
        let placeholderNumber = 1;
        change.linkedEditGroups.forEach((leg) => {
            leg.positions.forEach((pos) => {
                const defaultValue = documentText.substr(pos.offset, leg.length);
                let choices = leg.suggestions ? leg.suggestions.map((s) => s.value) : undefined;
                if (defaultValue && choices && !choices.includes(defaultValue)) {
                    choices = [defaultValue, ...choices];
                }
                placeholders.push({ offset: pos.offset, length: leg.length, defaultValue, choices, placeholderNumber });
            });
            placeholderNumber++;
        });
        // Ensure they're in offset order so the next maths works!
        placeholders.sort((p1, p2) => p1.offset - p2.offset);
        const snippet = new vs.SnippetString();
        const firstPlaceholder = placeholders[0];
        const lastPlaceholder = placeholders[placeholders.length - 1];
        const startPos = firstPlaceholder.offset;
        const endPos = lastPlaceholder.offset + lastPlaceholder.length;
        let currentPos = startPos;
        placeholders.forEach((p) => {
            // Add the text from where we last were up to current placeholder.
            if (currentPos !== p.offset)
                snippet.appendText(documentText.substring(currentPos, p.offset));
            // Add the choices / placeholder.
            if (p.choices && p.choices.length > 1)
                // TODO: Change this back to appendChoice when it handles commas correctly
                // https://github.com/microsoft/vscode/issues/107220
                // snippet.appendChoice(p.choices, p.placeholderNumber);
                snippet.value += "${" + p.placeholderNumber.toString() + "|" + p.choices.map((c) => this.snippetStringEscape(c)).join(",") + "|}";
            else
                snippet.appendPlaceholder(p.defaultValue, p.placeholderNumber);
            currentPos = p.offset + p.length;
        });
        // Replace the document.
        await editor.insertSnippet(snippet, new vs.Range(document.positionAt(startPos), document.positionAt(endPos)));
        // Ensure original document is the active one.
        await vs.window.showTextDocument(initiatingDocument);
    }
    snippetStringEscape(value) {
        return value.replace(/\$|}|\\|,/g, "\\$&");
    }
}
exports.DasEditCommands = DasEditCommands;
function hasOverlappingEdits(change) {
    const priorEdits = {};
    for (const edit of change.edits) {
        if (!priorEdits[edit.file])
            priorEdits[edit.file] = [];
        for (const e of edit.edits) {
            if (priorEdits[edit.file].find((pe) => pe.offset <= e.offset))
                return true;
            priorEdits[edit.file].push(e);
        }
    }
    return false;
}


/***/ }),

/***/ 8049:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspEditCommands = void 0;
const vs = __importStar(__webpack_require__(1398));
const vscode_languageclient_1 = __webpack_require__(99);
const editors = __importStar(__webpack_require__(9451));
class LspEditCommands {
    analyzer;
    commands = [];
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.commands.push(vs.commands.registerCommand("dart.sortMembers", () => this.runCodeAction("source.sortMembers")));
        // TODO: Enable this when https://github.com/dart-lang/sdk/issues/33521
        // is resolved.
        // this.commands.push(
        // 	vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this),
        // );
    }
    getActiveEditor() {
        return editors.getActiveRealFileEditor();
    }
    async runCodeAction(action) {
        return vs.commands.executeCommand("editor.action.codeAction", { kind: action, apply: "ifSingle" });
    }
    // TODO(dantup): Is this wired up?!
    async completeStatement() {
        const editor = this.getActiveEditor();
        if (!editor || !editor.selection)
            return;
        const edit = await this.analyzer.completeStatement({
            position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
            textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
        });
        if (edit) {
            if (await this.validDocumentVersionsStillMatch(edit)) {
                const codeEdit = await this.analyzer.client.protocol2CodeConverter.asWorkspaceEdit(edit);
                if (!await vs.workspace.applyEdit(codeEdit)) {
                    void vs.window.showErrorMessage("VS Code failed to apply edits");
                }
            }
            else {
                void vs.window.showErrorMessage("Documents have been modified so edits could not be applied");
            }
        }
    }
    async validDocumentVersionsStillMatch(edit) {
        // If the edit didn't have any documentChanges (it has changes) we have
        // to assume it's all up-to-date.
        if (!edit.documentChanges)
            return true;
        const openTextDocuments = new Map();
        vs.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        for (const change of edit.documentChanges) {
            if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    const textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.LspEditCommands = LspEditCommands;


/***/ }),

/***/ 8787:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterCommands = void 0;
const fs = __importStar(__webpack_require__(9896));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(2461);
const constants_1 = __webpack_require__(6709);
const array_1 = __webpack_require__(3043);
const dartdocs_1 = __webpack_require__(8450);
const fs_1 = __webpack_require__(2587);
const projects_1 = __webpack_require__(8146);
const flutter_samples_1 = __webpack_require__(5913);
const config_1 = __webpack_require__(7678);
const flutter_docs_snippets_1 = __webpack_require__(7030);
const util = __importStar(__webpack_require__(279));
const input_1 = __webpack_require__(7335);
const projects_2 = __webpack_require__(6265);
const sdk_1 = __webpack_require__(7177);
class FlutterCommands extends sdk_1.BaseSdkCommands {
    sdkUtils;
    flutterCapabilities;
    deviceManager;
    analytics;
    flutterScreenshotPath;
    constructor(logger, context, workspace, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager, analytics) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.flutterCapabilities = flutterCapabilities;
        this.deviceManager = deviceManager;
        this.analytics = analytics;
        this.disposables.push(vs.commands.registerCommand("flutter.clean", this.flutterClean, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.screenshot.touchBar", (args) => vs.commands.executeCommand("flutter.screenshot", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.screenshot", this.flutterScreenshot, this));
        this.disposables.push(vs.commands.registerCommand("flutter.doctor", this.flutterDoctor, this));
        this.disposables.push(vs.commands.registerCommand("flutter.doctor.sidebar", () => this.flutterDoctor({ commandSource: constants_1.CommandSource.sidebarTitle })));
        this.disposables.push(vs.commands.registerCommand("flutter.upgrade", this.flutterUpgrade, this));
        this.disposables.push(vs.commands.registerCommand("flutter.createProject", this.createFlutterProject, this));
        this.disposables.push(vs.commands.registerCommand("flutter.createProject.sidebar", () => this.createFlutterProject({ commandSource: constants_1.CommandSource.sidebarTitle })));
        this.disposables.push(vs.commands.registerCommand("_dart.flutter.createSampleProject", this.createFlutterSampleProject, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.create", this.flutterCreate, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.clean", this.flutterClean, this));
    }
    async flutterClean(selection) {
        if (!selection) {
            const path = await (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter clean" in`, selection, true);
            if (!path)
                return;
            selection = vs.Uri.file(path);
        }
        return this.runFlutter(["clean"], selection);
    }
    async flutterScreenshot() {
        let shouldNotify = false;
        // If there is no path for this session, or it differs from config, use the one from config.
        if (!this.flutterScreenshotPath ||
            (config_1.config.flutterScreenshotPath && this.flutterScreenshotPath !== config_1.config.flutterScreenshotPath)) {
            this.flutterScreenshotPath = config_1.config.flutterScreenshotPath;
            shouldNotify = true;
        }
        // If path is still empty, bring up the folder selector.
        if (!this.flutterScreenshotPath) {
            const selectedFolder = await vs.window.showOpenDialog({ canSelectFolders: true, openLabel: "Set screenshots folder" });
            if (selectedFolder && selectedFolder.length > 0) {
                // Set variable to selected path. This allows prompting the user only once.
                this.flutterScreenshotPath = selectedFolder[0].path;
                shouldNotify = true;
            }
            else {
                // Do nothing if the user cancelled the folder selection.
                return;
            }
        }
        // Ensure folder exists.
        (0, fs_1.mkDirRecursive)(this.flutterScreenshotPath);
        const debugSession = vs.debug.activeDebugSession;
        if (!debugSession) {
            void vs.window.showErrorMessage("You must have an active Flutter debug session to take screenshots");
            return;
        }
        if (debugSession.type !== "dart") {
            void vs.window.showErrorMessage("The active debug session is not a Flutter app");
            return;
        }
        const projectFolder = debugSession.configuration.cwd;
        const deviceId = (debugSession.configuration.deviceId ?? this.deviceManager?.currentDevice?.id);
        const outputFilename = (0, fs_1.nextAvailableFilename)(this.flutterScreenshotPath, "flutter_", ".png");
        const args = ["screenshot"];
        if (deviceId) {
            args.push("-d");
            args.push(deviceId);
        }
        args.push("-o");
        args.push(path.join(this.flutterScreenshotPath, outputFilename));
        await this.runFlutterInFolder(projectFolder, args, "screenshot");
        if (shouldNotify) {
            const res = await vs.window.showInformationMessage(`Screenshots will be saved to ${this.flutterScreenshotPath}`, "Show Folder");
            if (res)
                await vs.commands.executeCommand("revealFileInOS", vs.Uri.file(this.flutterScreenshotPath));
        }
    }
    flutterDoctor(options) {
        if (!this.workspace.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.doctor");
            return;
        }
        this.analytics.logFlutterDoctor(options?.commandSource);
        const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
        if (!fs.existsSync(tempDir))
            fs.mkdirSync(tempDir);
        return this.runFlutterInFolder(tempDir, ["doctor", "-v"], "flutter", true, this.workspace.config?.flutterDoctorScript);
    }
    async flutterUpgrade() {
        if (!this.workspace.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.upgrade");
            return;
        }
        const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
        if (!fs.existsSync(tempDir))
            fs.mkdirSync(tempDir);
        // Don't prompt to reload when the version changes, as we automatically reload here.
        sdk_1.commandState.promptToReloadOnVersionChanges = false;
        await this.runFlutterInFolder(tempDir, ["upgrade"], "flutter", true);
        await util.promptToReloadExtension();
    }
    async flutterCreate({ projectName, projectPath, triggerData, platform }) {
        if (!projectPath) {
            projectPath = await (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter create" in`, undefined, true);
            if (!projectPath)
                return;
        }
        const template = triggerData?.template;
        const templateSupportsPlatform = template === undefined || !!constants_1.flutterCreateTemplatesSupportingPlatforms.find((t) => t === template ?? "app");
        const defaultPlatforms = config_1.config.flutterCreatePlatforms;
        const args = ["create"];
        if (config_1.config.flutterCreateOffline || config_1.config.offline) {
            args.push("--offline");
        }
        if (templateSupportsPlatform) {
            if (platform) {
                args.push("--platforms");
                args.push(platform);
            }
            else if (defaultPlatforms) {
                for (const platform of defaultPlatforms) {
                    args.push("--platforms");
                    args.push(platform);
                }
            }
        }
        if (projectName) {
            args.push("--project-name");
            args.push(projectName);
        }
        if (config_1.config.flutterCreateOrganization) {
            args.push("--org");
            args.push(config_1.config.flutterCreateOrganization);
        }
        if (config_1.config.flutterCreateIOSLanguage && config_1.config.flutterCreateIOSLanguage !== "swift" && this.flutterCapabilities.supportsIOSLanguage) {
            args.push("--ios-language");
            args.push(config_1.config.flutterCreateIOSLanguage);
        }
        if (config_1.config.flutterCreateAndroidLanguage && config_1.config.flutterCreateAndroidLanguage !== "kotlin") {
            args.push("--android-language");
            args.push(config_1.config.flutterCreateAndroidLanguage);
        }
        if (triggerData?.sample) {
            args.push("--sample");
            args.push(triggerData.sample);
            args.push("--overwrite");
        }
        if (template) {
            args.push("--template");
            args.push(template);
            if (triggerData?.empty && this.flutterCapabilities.supportsCreateEmpty)
                args.push("--empty");
            args.push("--overwrite");
        }
        args.push(".");
        const exitCode = await this.runFlutterInFolder(projectPath, args, projectName);
        if (!vscode_1.vsCodeVersion.supportsDebugWithoutLaunchJson) {
            this.writeDefaultLaunchJson(projectPath);
        }
        return exitCode;
    }
    writeDefaultLaunchJson(projectPath) {
        const launchJsonFolder = path.join(projectPath, vscode_1.vsCodeVersion.editorConfigFolder);
        const launchJsonFile = path.join(launchJsonFolder, "launch.json");
        if (!fs.existsSync(launchJsonFile)) {
            (0, fs_1.mkDirRecursive)(launchJsonFolder);
            fs.writeFileSync(launchJsonFile, constants_1.defaultLaunchJson);
        }
    }
    getFlutterTemplates() {
        const templates = [
            {
                kind: vs.QuickPickItemKind.Separator,
                label: "Applications",
            },
            {
                detail: "A Flutter application with descriptive comments and tests.",
                label: "Application",
                template: { id: "app" },
            },
            {
                condition: this.flutterCapabilities.supportsCreateEmpty,
                detail: "A Flutter application without descriptive comments or tests.",
                label: "Empty Application",
                template: { id: "app", empty: true },
            },
            {
                condition: this.flutterCapabilities.supportsCreateSkeleton,
                detail: "A List View / Detail View Flutter application that follows community best practices.",
                label: "Skeleton Application",
                template: { id: "skeleton" },
            },
            {
                kind: vs.QuickPickItemKind.Separator,
                label: "Other Project Types",
            },
            {
                detail: "A project to add a Flutter module to an existing Android or iOS application.",
                label: "Module",
                template: { id: "module" },
            },
            {
                detail: "A shareable Flutter project containing modular Dart code.",
                label: "Package",
                template: { id: "package" },
            },
            {
                detail: "A shareable Flutter project containing an API in Dart code with a platform-specific implementation for Android, for iOS code, or for both.",
                label: "Plugin",
                template: { id: "plugin" },
            },
        ].filter((t) => t.condition !== false);
        return templates;
    }
    async createFlutterProject(options) {
        if (!this.sdks || !this.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
            return;
        }
        this.analytics.logFlutterNewProject(options?.commandSource);
        const pickItems = this.getFlutterTemplates();
        const selectedTemplate = await vs.window.showQuickPick(pickItems, {
            ignoreFocusOut: true,
            matchOnDescription: true,
            placeHolder: "Which Flutter template?",
        });
        if (!selectedTemplate?.template)
            return;
        return this.createFlutterProjectForTemplate(selectedTemplate.template);
    }
    async createFlutterProjectForTemplate(template) {
        if (!this.sdks || !this.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
            return;
        }
        // If already in a workspace, set the default folder to something nearby.
        const folders = await vs.window.showOpenDialog({
            canSelectFolders: true,
            defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
            openLabel: "Select a folder to create the project in",
        });
        if (!folders || folders.length !== 1)
            return;
        const folderPath = (0, fs_1.fsPath)(folders[0]);
        this.context.lastUsedNewProjectPath = folderPath;
        const projectKind = this.getProjectKind(template.id);
        const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, `flutter_${projectKind}_`);
        const name = await this.promptForNameWithSettings(defaultName, folderPath);
        if (!name)
            return;
        const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
        const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
        if (fs.existsSync(projectFolderPath)) {
            void vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
            return;
        }
        // Create the empty folder so we can open it.
        fs.mkdirSync(projectFolderPath);
        const triggerData = template
            ? { template: template.id, empty: template.empty }
            : undefined;
        (0, projects_1.writeFlutterTriggerFile)(projectFolderPath, triggerData);
        // If we're using a custom SDK, we need to apply it to the new project too.
        if (config_1.config.workspaceFlutterSdkPath)
            (0, projects_1.writeFlutterSdkSettingIntoProject)(config_1.config.workspaceFlutterSdkPath, projectFolderPath);
        void vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
        return projectFolderUri;
    }
    async promptForNameWithSettings(defaultName, folderPath) {
        while (true) {
            const response = await (0, input_1.showInputBoxWithSettings)(this.context, {
                ignoreFocusOut: true,
                placeholder: defaultName,
                prompt: "Enter a name for your new project",
                title: "Project Name",
                validation: (s) => this.validateFlutterProjectName(s, folderPath),
                value: defaultName,
            });
            if (response === "SETTINGS") {
                await (0, input_1.showSimpleSettingsEditor)("Settings for new Flutter projects", "Select a setting to change (or 'Escape' to cancel)", () => getCurrentFlutterCreateSettings());
                continue;
            }
            else if (response) {
                return response.value;
            }
            else {
                return undefined;
            }
        }
    }
    async createFlutterSampleProject() {
        if (!this.sdks || !this.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("_dart.flutter.createSampleProject");
            return;
        }
        // Fetch the JSON for the available samples.
        let snippets;
        try {
            snippets = await (0, flutter_docs_snippets_1.getFlutterSnippets)(this.logger, this.sdks, this.flutterCapabilities);
        }
        catch {
            void vs.window.showErrorMessage("Unable to retrieve Flutter documentation snippets");
            return;
        }
        const sortedSnippets = (0, array_1.sortBy)(snippets, (s) => s.element);
        const selectedSnippet = await vs.window.showQuickPick(sortedSnippets.map((s) => ({
            description: `${s.package}/${s.library}`,
            detail: (0, dartdocs_1.stripMarkdown)(s.description),
            label: s.element,
            snippet: s,
        })), {
            ignoreFocusOut: true,
            matchOnDescription: true,
            placeHolder: "Which Flutter sample?",
        });
        if (!selectedSnippet)
            return;
        return (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, selectedSnippet.snippet.id, config_1.config.workspaceFlutterSdkPath);
    }
    validateFlutterProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Flutter project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["flutter", "flutter_test", "test", "integration_test", "this"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a flutter project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
    getProjectKind(templateName) {
        if (templateName.includes("module"))
            return "module";
        if (templateName.includes("package"))
            return "package";
        if (templateName.includes("plugin"))
            return "plugin";
        return "application";
    }
}
exports.FlutterCommands = FlutterCommands;
function getCurrentFlutterCreateSettings() {
    return [
        {
            currentValue: config_1.config.flutterCreateOrganization || "com.example",
            description: config_1.config.flutterCreateOrganization || "com.example",
            detail: "The organization responsible for your new Flutter project, in reverse domain name notation. This string is used in Java package names and as prefix in the iOS bundle identifier.",
            label: "Organization",
            setValue: (newValue) => config_1.config.setFlutterCreateOrganization(newValue),
            settingKind: "STRING",
        },
        {
            currentValue: config_1.config.flutterCreateAndroidLanguage || "kotlin",
            description: config_1.config.flutterCreateAndroidLanguage || "kotlin",
            detail: "The language to use for Android-specific code, either Java (legacy) or Kotlin (recommended).",
            enumValues: ["kotlin", "java"],
            label: "Android Language",
            setValue: (newValue) => config_1.config.setFlutterCreateAndroidLanguage(newValue),
            settingKind: "ENUM",
        },
        {
            currentValue: config_1.config.flutterCreateIOSLanguage || "swift",
            description: config_1.config.flutterCreateIOSLanguage || "swift",
            detail: "The language to use for iOS-specific code (Flutter <= 3.22 only), either ObjectiveC (legacy) or Swift (recommended).",
            enumValues: ["swift", "objc"],
            label: "iOS Language",
            setValue: (newValue) => config_1.config.setFlutterCreateIOSLanguage(newValue),
            settingKind: "ENUM",
        },
        {
            currentValue: config_1.config.offline ? "enabled" : "not enabled",
            description: config_1.config.offline ? "enabled" : "not enabled",
            detail: "When commands like \"flutter pub get\" or \"flutter create\" are run, this indicates whether to run in offline mode or not. In offline mode, it will need to have all dependencies already available in the pub cache to succeed.",
            label: "Offline Mode",
            setValue: (newValue) => config_1.config.setOffline(newValue),
            settingKind: "BOOL",
        },
        {
            currentValue: config_1.config.flutterCreatePlatforms ?? constants_1.flutterCreateAvailablePlatforms,
            description: config_1.config.flutterCreatePlatforms ? config_1.config.flutterCreatePlatforms.join(", ") : "all",
            detail: "The platforms that should be enabled for new Flutter applications.",
            enumValues: [{
                    values: constants_1.flutterCreateAvailablePlatforms,
                },
                /* {
                    group: "Defaults",
                    values: ["Set as default..."],
                } */ 
            ],
            label: "Platforms",
            setValue: async (newValues) => {
                const valueToSave = newValues.length === constants_1.flutterCreateAvailablePlatforms.length
                    ? undefined // all
                    : newValues;
                await config_1.config.setFlutterCreatePlatforms(valueToSave);
            },
            settingKind: "MULTI_ENUM",
        },
    ];
}


/***/ }),

/***/ 5074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineCommands = exports.flutterOutlineCommands = void 0;
const vs = __importStar(__webpack_require__(1398));
exports.flutterOutlineCommands = [
    "refactor.flutter.wrap.center",
    "refactor.flutter.wrap.padding",
    "refactor.flutter.wrap.column",
    "refactor.flutter.move.up",
    "refactor.flutter.move.down",
    "refactor.flutter.removeWidget",
];
class FlutterOutlineCommands {
    tree;
    constructor(tree, context) {
        this.tree = tree;
        for (const id of exports.flutterOutlineCommands) {
            context.subscriptions.push(vs.commands.registerCommand("_flutter.outline." + id, () => this.applyRefactoring(id)));
        }
    }
    async applyRefactoring(refactorType) {
        if (!this.tree.selection || this.tree.selection.length !== 1) {
            console.error(`Invalid selection when running Flutter Outline refactor: ${refactorType}`);
            return;
        }
        const widget = this.tree.selection[0];
        const fix = widget.fixes.find((f) => f.kind && f.kind.value.endsWith(refactorType));
        if (fix) {
            if (fix.command && fix.command.arguments)
                await vs.commands.executeCommand(fix.command.command, ...fix.command.arguments); // eslint-disable-line @typescript-eslint/no-unsafe-argument
            else if (fix.edit)
                await vs.workspace.applyEdit(fix.edit);
            else
                console.error(`Flutter Outline fix was missing command/arguments`);
        }
        else {
            console.error(`Unable to find command for Flutter Outline: ${refactorType}`);
        }
    }
}
exports.FlutterOutlineCommands = FlutterOutlineCommands;


/***/ }),

/***/ 4243:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToSuperCommand = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const editors = __importStar(__webpack_require__(9451));
const outline_1 = __webpack_require__(8693);
class GoToSuperCommand {
    analyzer;
    disposables = [];
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    async goToSuper() {
        const editor = editors.getActiveDartEditor();
        if (!editor) {
            void vs.window.showWarningMessage("No active Dart editor.");
            return;
        }
        const document = editor.document;
        const position = editor.selection.start;
        const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position);
        const offset = outlineNode && outlineNode.element && outlineNode.element.location
            ? outlineNode.element.location.offset
            : document.offsetAt(position);
        const hierarchy = await this.analyzer.client.searchGetTypeHierarchy({
            file: (0, fs_1.fsPath)(document.uri),
            offset,
            superOnly: true,
        });
        if (!hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
            return;
        // The first item is the current node, so skip that one and walk up till we find a matching member.
        const isClass = !hierarchy.hierarchyItems[0].memberElement;
        const item = hierarchy.hierarchyItems.slice(1).find((h) => isClass ? !!h.classElement : !!h.memberElement);
        const element = isClass ? item && item.classElement : item && item.memberElement;
        if (!element || !element.location)
            return;
        const elementDocument = await vs.workspace.openTextDocument(element.location.file);
        const elementEditor = await vs.window.showTextDocument(elementDocument);
        const range = (0, utils_2.toRangeOnLine)(element.location);
        (0, utils_2.showCode)(elementEditor, range, range, range);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.GoToSuperCommand = GoToSuperCommand;


/***/ }),

/***/ 6444:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggingCommands = exports.isLogging = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const log_1 = __webpack_require__(7962);
exports.isLogging = false;
class LoggingCommands {
    logger;
    extensionLogPath;
    disposables = [];
    currentLogCompleter;
    onCaptureLogsEmitter = new vs.EventEmitter();
    onCaptureLogs = this.onCaptureLogsEmitter.event;
    constructor(logger, extensionLogPath) {
        this.logger = logger;
        this.extensionLogPath = extensionLogPath;
        this.disposables.push(vs.commands.registerCommand("dart.startLogging", this.startLoggingViaPicker, this), vs.commands.registerCommand("dart.startLoggingDebugging", this.startLoggingDebugging, this), vs.commands.registerCommand("dart.startLoggingAnalysisServer", this.startLoggingAnalysisServer, this), vs.commands.registerCommand("dart.startLoggingAnalysisServerTimings", this.startLoggingAnalysisServerTimings, this), vs.commands.registerCommand("dart.startLoggingExtensionOnly", this.startLoggingExtensionOnly, this), vs.commands.registerCommand("dart.openExtensionLog", this.openExtensionLog, this), vs.commands.registerCommand("dart.stopLogging", this.stopLogging, this));
    }
    async startLoggingViaPicker() {
        const selectedLogCategories = await vs.window.showQuickPick(Object.keys(log_1.userSelectableLogCategories).map((k) => ({
            label: k,
            logCategory: log_1.userSelectableLogCategories[k],
            picked: true,
        })), {
            canPickMany: true,
            placeHolder: "Select which categories to include in the log",
        });
        if (!selectedLogCategories || !selectedLogCategories.length)
            return;
        return this.startLogging(selectedLogCategories.map((s) => s.logCategory));
    }
    async startLoggingDebugging() {
        return this.startLogging(log_1.debuggingLogCategories);
    }
    async startLoggingAnalysisServer() {
        return this.startLogging(log_1.analysisServerLogCategories);
    }
    async startLoggingAnalysisServerTimings() {
        return this.startLogging([enums_1.LogCategory.AnalyzerTiming]);
    }
    async startLoggingExtensionOnly() {
        return this.startLogging(log_1.extensionsLogCategories);
    }
    async startLogging(categoriesToLog) {
        const logFilename = path.join((0, fs_1.forceWindowsDriveLetterToUppercase)(this.extensionLogPath), this.generateFilename());
        const logUri = vs.Uri.file(logFilename);
        (0, fs_1.createFolderForFile)(logFilename);
        const allLoggedCategories = [enums_1.LogCategory.General].concat(categoriesToLog);
        const logger = (0, logging_1.captureLogs)(this.logger, (0, fs_1.fsPath)(logUri), (0, log_1.getLogHeader)(), constants_1.captureLogsMaxLineLength, allLoggedCategories);
        exports.isLogging = true;
        this.onCaptureLogsEmitter.fire(exports.isLogging);
        this.disposables.push(logger);
        void vs.commands.executeCommand("setContext", constants_contexts_1.DART_IS_CAPTURING_LOGS_CONTEXT, true);
        const completer = new utils_1.PromiseCompleter();
        this.currentLogCompleter = completer;
        await vs.window.withProgress({
            cancellable: true,
            location: vs.ProgressLocation.Notification,
            title: `Dart and Flutter logs are being captured. Reproduce your issue then click Cancel.`,
        }, (_, token) => {
            token.onCancellationRequested(() => completer.resolve());
            return completer.promise;
        });
        exports.isLogging = false;
        this.onCaptureLogsEmitter.fire(exports.isLogging);
        await logger.dispose();
        const doc = await vs.workspace.openTextDocument(logUri);
        await vs.window.showTextDocument(doc);
        return logFilename;
    }
    async openExtensionLog() {
        const doc = await vs.workspace.openTextDocument(vs.Uri.file((0, log_1.getExtensionLogPath)()));
        await vs.window.showTextDocument(doc);
    }
    async stopLogging() {
        if (this.currentLogCompleter)
            this.currentLogCompleter.resolve();
    }
    generateFilename() {
        const pad = (s) => `0${s.toString()}`.slice(-2);
        const now = new Date();
        const formattedDate = `${now.getFullYear()}-${pad(now.getMonth())}-${pad(now.getDay())} ${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
        return `Dart-Code-Log-${formattedDate}.txt`;
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.LoggingCommands = LoggingCommands;


/***/ }),

/***/ 7875:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenInOtherEditorCommands = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const fs_1 = __webpack_require__(2587);
const misc_1 = __webpack_require__(1166);
const processes_1 = __webpack_require__(8141);
class OpenInOtherEditorCommands {
    logger;
    sdks;
    disposables = [];
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
        this.disposables.push(vs.commands.registerCommand("flutter.openInAndroidStudio", this.openInAndroidStudio, this), vs.commands.registerCommand("flutter.openInXcode", this.openInXcode, this));
    }
    async openInAndroidStudio(resource) {
        const folder = (0, fs_1.fsPath)(resource);
        let androidStudioDir = await this.getAndroidStudioDir(folder);
        if (!androidStudioDir) {
            void vs.window.showErrorMessage("Unable to find Android Studio");
            return;
        }
        if (constants_1.isMac && androidStudioDir.endsWith("/Contents")) {
            androidStudioDir = androidStudioDir.substr(0, androidStudioDir.length - "/Contents".length);
            (0, processes_1.safeToolSpawn)(folder, "open", ["-a", androidStudioDir, folder]);
            return;
        }
        else {
            for (const androidStudioPath of constants_1.androidStudioPaths) {
                const fullPath = path.join(androidStudioDir, androidStudioPath);
                if (fs.existsSync(fullPath)) {
                    (0, processes_1.safeToolSpawn)(folder, fullPath, [folder]);
                    return;
                }
            }
        }
        void vs.window.showErrorMessage("Unable to locate Android Studio executable");
    }
    async openInXcode(resource) {
        const folder = (0, fs_1.fsPath)(resource);
        const files = fs
            .readdirSync(folder, { withFileTypes: true })
            .filter((item) => item.isDirectory())
            .filter((item) => item.name.endsWith(".xcworkspace") || item.name.endsWith(".xcodeproj"))
            .sort((f1, f2) => f1.name.endsWith(".xcworkspace") ? -1 : 1);
        if (!files || !files.length) {
            const basename = path.basename(folder);
            void vs.window.showErrorMessage(`Unable to find an Xcode project in your '${basename}' folder`);
            return;
        }
        const file = path.join(folder, files[0].name);
        (0, processes_1.safeToolSpawn)(folder, "open", [file]);
    }
    async getAndroidStudioDir(folder) {
        return (0, misc_1.getFlutterConfigValue)(this.logger, this.sdks.flutter, folder, "android-studio-dir");
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.OpenInOtherEditorCommands = OpenInOtherEditorCommands;


/***/ }),

/***/ 4644:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCommands = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const pub_1 = __webpack_require__(8296);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const util = __importStar(__webpack_require__(279));
const utils_3 = __webpack_require__(279);
const projects_1 = __webpack_require__(6265);
const sdk_1 = __webpack_require__(7177);
let isFetchingPackages = false;
let runPubGetDelayTimer;
/// The reason for the last pubspec save. Resets to undefined after 1s so can
/// be used to tell if a watcher event was likely the result of an explicit in-IDE
/// save versus modified externally.
let lastPubspecSaveReason;
class PackageCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        this.disposables.push(vs.commands.registerCommand("dart.getPackages", this.getPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.getPackages.all", this.getPackagesForAllProjects, this));
        this.disposables.push(vs.commands.registerCommand("dart.listOutdatedPackages", this.listOutdatedPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages", this.upgradePackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages.majorVersions", this.upgradePackagesMajorVersions, this));
        // Pub commands.
        this.disposables.push(vs.commands.registerCommand("pub.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.get.all", (selection) => vs.commands.executeCommand("dart.getPackages.all", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Flutter commands.
        this.disposables.push(vs.commands.registerCommand("flutter.packages.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.get.all", (selection) => vs.commands.executeCommand("dart.getPackages.all", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Hook saving pubspec to run pub.get.
        this.setupPubspecWatcher();
    }
    async getPackages(uri) {
        if (!config_1.config.enablePub)
            return;
        if (Array.isArray(uri)) {
            for (const item of uri) {
                await this.getPackages(item);
            }
            return;
        }
        if (!uri || !(uri instanceof vs.Uri)) {
            uri = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to get packages for");
            // If the user cancelled, bail out (otherwise we'll prompt them again below).
            if (!uri)
                return;
        }
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        // Exclude folders we should never run pub get for.
        if (!(0, pub_1.isValidPubGetTarget)(uri).valid)
            return;
        const additionalArgs = [];
        if (config_1.config.offline)
            additionalArgs.push("--offline");
        if (this.dartCapabilities.needsNoExampleForPubGet)
            additionalArgs.push("--no-example");
        if (util.isInsideFlutterProject(uri)) {
            return this.runFlutter(["pub", "get", ...additionalArgs], uri);
        }
        else {
            return this.runPub(["get", ...additionalArgs], uri);
        }
    }
    async getPackagesForAllProjects() {
        if (!config_1.config.enablePub)
            return;
        const allFolders = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, sort: true, searchDepth: config_1.config.projectSearchDepth });
        const uriFolders = allFolders.map((f) => vs.Uri.file(f));
        await vs.commands.executeCommand("dart.getPackages", uriFolders);
    }
    async listOutdatedPackages(uri) {
        if (!config_1.config.enablePub)
            return;
        if (!uri || !(uri instanceof vs.Uri)) {
            uri = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to check for outdated packages");
            // If the user cancelled, bail out (otherwise we'll prompt them again below).
            if (!uri)
                return;
        }
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        if (util.isInsideFlutterProject(uri))
            return this.runFlutter(["pub", "outdated"], uri, true);
        else
            return this.runPub(["outdated"], uri, true);
    }
    async upgradePackages(uri) {
        if (!config_1.config.enablePub)
            return;
        if (Array.isArray(uri)) {
            for (const item of uri) {
                await this.upgradePackages(item);
            }
            return;
        }
        if (!uri || !(uri instanceof vs.Uri)) {
            uri = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages in");
            // If the user cancelled, bail out (otherwise we'll prompt them again below).
            if (!uri)
                return;
        }
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        // Exclude folders we should never run pub get for.
        if (!(0, pub_1.isValidPubGetTarget)(uri).valid)
            return;
        if (util.isInsideFlutterProject(uri))
            return this.runFlutter(["pub", "upgrade"], uri);
        else
            return this.runPub(["upgrade"], uri);
    }
    async upgradePackagesMajorVersions(uri) {
        if (!config_1.config.enablePub)
            return;
        if (!this.dartCapabilities.supportsPubUpgradeMajorVersions) {
            void vs.window.showErrorMessage("Your current Dart SDK does not support 'pub upgrade --major-versions'");
            return;
        }
        if (!this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation) {
            const resp = await vs.window.showWarningMessage("Running 'pub get --major-versions' will update your pubspec.yaml to match the 'resolvable' column reported in 'pub outdated'", constants_1.iUnderstandAction);
            if (resp !== constants_1.iUnderstandAction) {
                return;
            }
            this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation = true;
        }
        if (!uri || !(uri instanceof vs.Uri)) {
            uri = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages --major-versions in");
            // If the user cancelled, bail out (otherwise we'll prompt them again below).
            if (!uri)
                return;
        }
        if (typeof uri === "string")
            uri = vs.Uri.file(uri);
        if (util.isInsideFlutterProject(uri))
            return this.runFlutter(["pub", "upgrade", "--major-versions"], uri);
        else
            return this.runPub(["upgrade", "--major-versions"], uri);
    }
    setupPubspecWatcher() {
        // Create the watcher regardless of enablePub setting, because the handler will check
        // and then we don't have to create/destroy as settings change.
        this.disposables.push(vs.workspace.onWillSaveTextDocument((e) => {
            const name = path.basename((0, fs_1.fsPath)(e.document.uri)).toLowerCase();
            if (name === "pubspec.yaml" || name === "pubspec_overrides.yaml") {
                lastPubspecSaveReason = e.reason;
                setTimeout(() => lastPubspecSaveReason = undefined, 1000);
            }
        }));
        const watcher = vs.workspace.createFileSystemWatcher("**/pubspec{,_overrides}.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handlePubspecChange, this);
        watcher.onDidCreate(this.handlePubspecChange, this);
    }
    handlePubspecChange(uri) {
        if (!config_1.config.enablePub)
            return;
        const isManualSave = !!lastPubspecSaveReason;
        const filePath = (0, fs_1.fsPath)(uri);
        // Never do anything for files inside hidden or build folders.
        if (filePath.includes(`${path.sep}.`) || (!isManualSave && filePath.includes(`${path.sep}build${path.sep}`))) {
            this.logger.info(`Skipping pubspec change for ignored folder ${filePath}`);
            return;
        }
        this.logger.info(`Pubspec ${filePath} was modified`);
        const conf = config_1.config.for(uri);
        // Don't do anything if we're disabled.
        if (conf.runPubGetOnPubspecChanges === "never") {
            this.logger.info(`Automatically running "pub get" is disabled`);
            return;
        }
        // Or if the workspace config says we shouldn't run.
        if (this.workspace.config.disableAutomaticPub) {
            this.logger.info(`Workspace suppresses automatic "pub"`);
            return;
        }
        // Don't do anything if we're in the middle of creating projects, as packages
        // may  be fetched automatically.
        if (sdk_1.commandState.numProjectCreationsInProgress > 0) {
            this.logger.info("Skipping package fetch because project creation is in progress");
            return;
        }
        // Cancel any existing delayed timer.
        if (runPubGetDelayTimer) {
            clearTimeout(runPubGetDelayTimer);
        }
        // If the save was triggered by one of the auto-save options, then debounce longer.
        const debounceDuration = lastPubspecSaveReason === vs.TextDocumentSaveReason.FocusOut
            || lastPubspecSaveReason === vs.TextDocumentSaveReason.AfterDelay
            ? 10000
            : 1000;
        const projectUri = vs.Uri.file(path.dirname(filePath));
        runPubGetDelayTimer = setTimeout(() => {
            runPubGetDelayTimer = undefined;
            lastPubspecSaveReason = undefined;
            void this.fetchPackagesOrPrompt(projectUri, { alwaysPrompt: conf.runPubGetOnPubspecChanges === "prompt" });
        }, debounceDuration); // TODO: Does this need to be configurable?
    }
    async fetchPackagesOrPrompt(uri, options) {
        if (!config_1.config.enablePub)
            return;
        if (isFetchingPackages) {
            this.logger.info(`Already running pub get, skipping!`);
            return;
        }
        isFetchingPackages = true;
        // VS Code will hide any prompt after 10seconds, so if the user didn't respond within 10s we assume this prompt is not
        // going to be responded to and should clear the flag to avoid run-pub-get-on-save not working.
        setTimeout(() => isFetchingPackages = false, constants_1.tenSecondsInMs);
        // TODO: Extract this into a Pub class with the things in pub.ts.
        try {
            const forcePrompt = options && options.alwaysPrompt;
            // We debounced so we might get here and have multiple projects to fetch for
            // for ex. when we change Git branch we might change many files at once. So
            // check how many there are, and if there are:
            //   0 - then just use Uri
            //   1 - then just do that one
            //   more than 1 - prompt to do all
            const projectFolders = await (0, utils_2.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            const pubStatuses = (0, pub_1.getPubWorkspaceStatus)(this.sdks, this.logger, (0, utils_1.uniq)(projectFolders).map(vs.Uri.file).filter((uri) => config_1.config.for(uri).promptToGetPackages))
                .filter((result) => result.pubRequired);
            this.logger.info(`Found pub status for ${pubStatuses.length} folders:${pubStatuses.map((result) => `\n    ${(0, fs_1.fsPath)(result.folderUri)} (pubRequired?: ${result.pubRequired}, reason: ${result.reason})`).join("")}`);
            const someProjectsRequirePubUpgrade = pubStatuses.some((result) => result.pubRequired === "UPGRADE");
            const projectsRequiringPub = pubStatuses.map((result) => result.folderUri);
            if (options?.upgradeOnSdkChange && someProjectsRequirePubUpgrade)
                await (0, pub_1.promptToRunPubUpgrade)(projectsRequiringPub);
            else if (!forcePrompt && projectsRequiringPub.length === 0 && uri)
                await this.runPubGetWithRelatives(projectFolders, uri);
            else if (!forcePrompt && projectsRequiringPub.length === 1)
                await this.runPubGetWithRelatives(projectFolders, projectsRequiringPub[0]);
            else if (projectsRequiringPub.length)
                await (0, pub_1.promptToRunPubGet)(projectsRequiringPub);
        }
        finally {
            isFetchingPackages = false;
        }
    }
    async runPubGetWithRelatives(allProjectFolders, triggeredProjectUri) {
        const triggeredProjectFolder = (0, fs_1.fsPath)(triggeredProjectUri);
        const walkDirection = config_1.config.runPubGetOnNestedProjects;
        const fetchBoth = walkDirection === "both";
        const fetchUp = walkDirection === "above" || fetchBoth;
        const fetchDown = walkDirection === "below" || fetchBoth;
        let projectsToFetch = [triggeredProjectFolder];
        if (walkDirection) {
            for (const projectFolder of allProjectFolders) {
                if (fetchUp && triggeredProjectFolder.startsWith(projectFolder))
                    projectsToFetch.push(projectFolder);
                if (fetchDown && projectFolder.startsWith(triggeredProjectFolder))
                    projectsToFetch.push(projectFolder);
            }
        }
        projectsToFetch = (0, utils_1.uniq)(projectsToFetch);
        await (0, pub_1.runPubGet)(projectsToFetch.map((path) => vs.Uri.file(path)));
    }
}
exports.PackageCommands = PackageCommands;


/***/ }),

/***/ 2623:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCommands = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const config_1 = __webpack_require__(7678);
const edit_das_1 = __webpack_require__(3470);
const refactorOptions = {
    EXTRACT_LOCAL_VARIABLE: getExtractLocalVariableArgs,
    EXTRACT_METHOD: getExtractMethodArgs,
    EXTRACT_WIDGET: getExtractWidgetArgs,
};
class RefactorCommands {
    logger;
    context;
    analyzer;
    subscriptions = [];
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.subscriptions.push(vs.commands.registerCommand("_dart.performRefactor", this.performRefactor, this));
        if (analyzer.capabilities.supportsMoveFile && config_1.config.updateImportsOnRename)
            this.subscriptions.push(vs.workspace.onWillRenameFiles((e) => this.onWillRenameFiles(e)));
    }
    async performRefactor(document, range, refactorKind) {
        // Ensure the document is still valid.
        if (!document || document.isClosed)
            return;
        const originalDocumentVersion = document.version;
        // Validate that there are no problems if we execute this refactor.
        const validationResult = await this.getRefactor(document, refactorKind, range, true);
        if (this.shouldAbortRefactor(validationResult))
            return;
        // Request the options from the user if required.
        let options;
        if (refactorOptions[refactorKind]) {
            options = await refactorOptions[refactorKind](validationResult.feedback);
            if (!options)
                return;
        }
        // Send the request for the refactor edits and prompt to apply if required.
        const editResult = await this.getRefactor(document, refactorKind, range, false, options);
        const applyEdits = await this.shouldApplyEdits(editResult, document, originalDocumentVersion);
        if (applyEdits)
            await vs.commands.executeCommand("_dart.applySourceChange", document, editResult.change);
    }
    async getRefactor(document, refactorKind, range, validateOnly, options) {
        let remainingTries = 3;
        while (true) {
            try {
                remainingTries--;
                // await is important for the catch!
                return await this.analyzer.editGetRefactoring({
                    file: (0, fs_1.fsPath)(document.uri),
                    kind: refactorKind,
                    length: document.offsetAt(range.end) - document.offsetAt(range.start),
                    offset: document.offsetAt(range.start),
                    options,
                    validateOnly,
                });
            }
            catch (e) {
                this.logger.error(e);
                if (remainingTries <= 0 || e.code !== "REFACTORING_REQUEST_CANCELLED")
                    throw e;
                else
                    this.logger.info(`getRefactor failed, will try ${remainingTries} more times...`);
            }
        }
    }
    shouldAbortRefactor(validationResult) {
        const validationProblems = validationResult.initialProblems
            .concat(validationResult.optionsProblems)
            .concat(validationResult.finalProblems)
            .filter((e) => e.severity === "FATAL");
        if (validationProblems.length) {
            void vs.window.showErrorMessage(validationProblems[0].message);
            return true;
        }
        return false;
    }
    async shouldApplyEdits(editResult, document, originalDocumentVersion) {
        const allProblems = editResult.initialProblems
            .concat(editResult.optionsProblems)
            .concat(editResult.finalProblems);
        const editFatals = allProblems.filter((e) => e.severity === "FATAL");
        const editWarnings = allProblems.filter((e) => e.severity === "ERROR" || e.severity === "WARNING");
        const hasErrors = !!allProblems.find((e) => e.severity === "ERROR");
        // Fatal errors can never be applied, just tell the user and quit.
        if (editFatals.length) {
            void vs.window.showErrorMessage((0, array_1.unique)(editFatals.map((e) => e.message)).join("\n\n") + "\n\nYour refactor was not applied.");
            return false;
        }
        // If we somehow got here with no change, we also cannot apply them.
        if (!editResult.change)
            return false;
        let applyEdits = true;
        // If we have warnings/errors, the user can decide whether to go ahead.
        if (editWarnings.length) {
            const show = hasErrors ? vs.window.showErrorMessage : vs.window.showWarningMessage;
            applyEdits = (constants_1.REFACTOR_ANYWAY === await show((0, array_1.unique)(editWarnings.map((w) => w.message)).join("\n\n"), constants_1.REFACTOR_ANYWAY));
        }
        // If we're trying to apply changes but the document is modified, we have to quit.
        if (applyEdits && document && document.version !== originalDocumentVersion) {
            void vs.window.showErrorMessage(constants_1.REFACTOR_FAILED_DOC_MODIFIED);
            return false;
        }
        return applyEdits;
    }
    isProcessingMoveEvent = false;
    onWillRenameFiles(e) {
        // TODO: VS Code always calls this once-per-file, concurrently for multiple files moved at once
        // which currently results in REFACTOR_CANCELLED for all but the first since the server doesn't
        // support multiple refactors at the same time. Running them sequentially fixes this, however it
        // hits an issue in VS Code (https://github.com/microsoft/vscode/issues/98309) so for now, we will
        // only process a single event at a time.
        if (this.isProcessingMoveEvent) {
            this.logger.info(`Skipping rename event for some files because another is in progress`);
            return;
        }
        try {
            const filesToRename = (0, utils_1.flatMap)(e.files, (f) => this.getResourcesToRename({ oldPath: (0, fs_1.fsPath)(f.oldUri), newPath: (0, fs_1.fsPath)(f.newUri) }))
                // Renames are only supported for Dart files, so filter out anything else to avoid producing an edit that will
                // trigger VS Code to show the rename dialog.
                .filter((f) => path.extname(f.oldPath).toLowerCase() === ".dart");
            if (filesToRename.length === 0)
                return;
            this.isProcessingMoveEvent = true;
            const edits = this.getRenameEdits(filesToRename);
            e.waitUntil(edits.finally(() => this.isProcessingMoveEvent = false));
        }
        catch (e) {
            this.isProcessingMoveEvent = false;
        }
    }
    /// Server only supports one refactoring at a time, so we need to ensure we
    /// wait for any previous one to finish before sending this.
    inProgressRefactor = promises_1.resolvedPromise;
    async runSequentially(func) {
        this.inProgressRefactor = this.inProgressRefactor.then(() => func());
        return this.inProgressRefactor;
    }
    async getRenameEdits(filesToRename) {
        const changes = new vs.WorkspaceEdit();
        for (const file of filesToRename) {
            const editResult = await this.runSequentially(() => this.analyzer.editGetRefactoring({
                file: file.oldPath,
                kind: "MOVE_FILE",
                length: 0, // Not used for MOVE_FILE
                offset: 0, // Not used for MOVE_FILE
                options: { newFile: file.newPath },
                validateOnly: false,
            }));
            if (!editResult.change)
                continue;
            const applyEdits = await this.shouldApplyEdits(editResult);
            if (!applyEdits)
                continue;
            if ((0, edit_das_1.hasOverlappingEdits)(editResult.change)) {
                void vs.window.showErrorMessage("Unable to update references; edits contain ambiguous positions.");
                this.logger.error(`Unable to apply MOVE_FILE edits due to ambiguous edits:\n\n${JSON.stringify(editResult.change, undefined, 4)}`);
                return;
            }
            for (const edit of editResult.change.edits) {
                for (const e of edit.edits) {
                    const uri = vs.Uri.file(edit.file);
                    const document = await vs.workspace.openTextDocument(uri);
                    changes.replace(vs.Uri.file(edit.file), new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                }
            }
        }
        if (changes.size === 0)
            return;
        return changes;
    }
    getResourcesToRename(rename) {
        const filesToRename = [];
        if (fs.statSync(rename.oldPath).isFile()) {
            // TODO: if (isAnalyzableAndInWorkspace(rename.oldPath))
            filesToRename.push(rename);
        }
        return filesToRename;
    }
    dispose() {
        for (const command of this.subscriptions)
            command.dispose();
    }
}
exports.RefactorCommands = RefactorCommands;
async function getExtractLocalVariableArgs(f) {
    const feedback = f;
    const proposedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : "x";
    return { name: proposedName, extractAll: false };
}
async function getExtractMethodArgs(f) {
    const feedback = f;
    const suggestedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : undefined;
    const name = await vs.window.showInputBox({ prompt: "Enter a name for the method", value: suggestedName });
    if (!name)
        return;
    return {
        createGetter: false,
        extractAll: false,
        name,
        parameters: feedback && feedback.parameters,
        returnType: feedback && feedback.returnType,
    };
}
async function getExtractWidgetArgs(f) {
    const name = await vs.window.showInputBox({ prompt: "Enter a name for the widget" });
    return name ? { name } : undefined;
}


/***/ }),

/***/ 7177:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdkCommands = exports.BaseSdkCommands = exports.commandState = exports.packageNameRegex = void 0;
exports.markProjectCreationStarted = markProjectCreationStarted;
exports.markProjectCreationEnded = markProjectCreationEnded;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const processes_1 = __webpack_require__(4917);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
const sdk_manager_1 = __webpack_require__(6357);
const util = __importStar(__webpack_require__(279));
const processes_2 = __webpack_require__(8141);
const projects_1 = __webpack_require__(6265);
const channels = __importStar(__webpack_require__(269));
exports.packageNameRegex = new RegExp("^[a-z][a-z0-9_]*$");
// TODO: Find a better way/place for this.
exports.commandState = {
    numProjectCreationsInProgress: 0,
    promptToReloadOnVersionChanges: true,
};
class BaseSdkCommands {
    logger;
    context;
    workspace;
    dartCapabilities;
    sdks;
    disposables = [];
    // A map of any in-progress commands so we can terminate them if we want to run another.
    runningCommands = {};
    constructor(logger, context, workspace, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.workspace = workspace;
        this.dartCapabilities = dartCapabilities;
        this.sdks = workspace.sdks;
    }
    async runCommandForWorkspace(handler, placeHolder, args, selection, alwaysShowOutput = false) {
        const folderToRunCommandIn = await (0, projects_1.getFolderToRunCommandIn)(this.logger, placeHolder, selection);
        if (!folderToRunCommandIn)
            return;
        const containingWorkspace = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderToRunCommandIn));
        if (!containingWorkspace) {
            this.logger.error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
            throw new Error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
        }
        const containingWorkspacePath = (0, fs_1.fsPath)(containingWorkspace.uri);
        // Display the relative path from the workspace root to the folder we're running, or if they're
        // the same then the folder name we're running in.
        const shortPath = path.relative(containingWorkspacePath, folderToRunCommandIn)
            || path.basename(folderToRunCommandIn);
        return handler(folderToRunCommandIn, args, shortPath, alwaysShowOutput);
    }
    runFlutter(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runFlutterInFolder.bind(this), `Select the folder to run "flutter ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runFlutterInFolder(folder, args, shortPath, alwaysShowOutput = false, customScript) {
        if (!this.sdks.flutter)
            throw new Error("Flutter SDK not available");
        const execution = (0, utils_1.usingCustomScript)(path.join(this.sdks.flutter, constants_1.flutterPath), args, customScript);
        const allArgs = (0, processes_2.getGlobalFlutterArgs)()
            .concat(config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs)
            .concat(execution.args);
        return this.runCommandInFolder(shortPath, folder, execution.executable, allArgs, alwaysShowOutput);
    }
    runPub(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runPubInFolder.bind(this), `Select the folder to run "pub ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runPubInFolder(folder, args, shortPath, alwaysShowOutput = false) {
        if (!this.sdks.dart)
            throw new Error("Dart SDK not available");
        args = args.concat(...config_1.config.for(vs.Uri.file(folder)).pubAdditionalArgs);
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return this.runCommandInFolder(shortPath, folder, pubExecution.executable, pubExecution.args, alwaysShowOutput);
    }
    runCommandInFolder(shortPath, folder, binPath, args, alwaysShowOutput) {
        shortPath = shortPath || path.basename(folder);
        const commandName = path.basename(binPath).split(".")[0]; // Trim file extension.
        const channel = channels.getOutputChannel(`${commandName} (${shortPath})`, true);
        if (alwaysShowOutput)
            channel.show();
        // Figure out if there's already one of this command running, in which case we'll chain off the
        // end of it.
        const commandId = `${folder}|${commandName}|${args}`;
        const existingProcess = this.runningCommands[commandId];
        if (existingProcess && !existingProcess.hasStarted) {
            // We already have a queued version of this command so there's no value in queueing another
            // just bail.
            return Promise.resolve(undefined);
        }
        return vs.window.withProgress({
            cancellable: true,
            location: vs.ProgressLocation.Notification,
            title: `${commandName} ${args.join(" ")}`,
        }, (progress, token) => {
            if (existingProcess) {
                progress.report({ message: "terminating previous command..." });
                existingProcess.cancel();
            }
            else {
                channel.clear();
            }
            const process = new ChainedProcess(() => {
                channel.appendLine(`[${shortPath}] ${commandName} ${args.join(" ")}`);
                progress.report({ message: "running..." });
                const proc = (0, processes_2.safeToolSpawn)(folder, binPath, args);
                channels.runProcessInOutputChannel(proc, channel);
                this.logger.info(`(PROC ${proc.pid}) Spawned ${binPath} ${args.join(" ")} in ${folder}`, enums_1.LogCategory.CommandProcesses);
                (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
                // If we complete with a non-zero code, or don't complete within 10s, we should show
                // the output pane.
                const completedWithErrorPromise = new Promise((resolve) => proc.on("close", resolve));
                const timedOutPromise = new Promise((resolve) => setTimeout(() => resolve(true), 10000));
                void Promise.race([completedWithErrorPromise, timedOutPromise]).then((showOutput) => {
                    if (showOutput)
                        channel.show(true);
                });
                return proc;
            }, existingProcess);
            this.runningCommands[commandId] = process;
            token.onCancellationRequested(() => process.cancel());
            return process.completed;
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.BaseSdkCommands = BaseSdkCommands;
class SdkCommands extends BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        const dartSdkManager = new sdk_manager_1.DartSdkManager(this.logger, this.workspace.sdks);
        this.disposables.push(vs.commands.registerCommand("dart.changeSdk", () => dartSdkManager.changeSdk()));
        if (workspace.hasAnyFlutterProjects) {
            const flutterSdkManager = new sdk_manager_1.FlutterSdkManager(this.logger, workspace.sdks);
            this.disposables.push(vs.commands.registerCommand("dart.changeFlutterSdk", () => flutterSdkManager.changeSdk()));
        }
        // Monitor version files for SDK upgrades.
        void this.setupVersionWatcher();
    }
    async setupVersionWatcher() {
        // On Windows, the watcher sometimes fires even if the file wasn't modified (could be when
        // accessed), so we need to filter those out. We can't just check the modified time is "recent"
        // because the unzip preserves the modification dates of the SDK. Instead, we'll capture the mtime
        // of the file at start, and then fire only if that time actually changes.
        const versionFile = path.join(this.sdks.dart, "version");
        const getModifiedTimeMs = async () => {
            try {
                return (await fs.promises.stat(versionFile)).mtime.getTime();
            }
            catch (error) {
                this.logger.warn(`Failed to check modification time on version file. ${error}`);
                return;
            }
        };
        let lastModifiedTime = await getModifiedTimeMs();
        // If we couldn't get the initial modified time, we can't track this.
        if (!lastModifiedTime)
            return;
        const watcher = fs.watch(versionFile, { persistent: false }, async (eventType) => {
            if (!exports.commandState.promptToReloadOnVersionChanges)
                return;
            const newModifiedTime = await getModifiedTimeMs();
            // Bail if we couldn't get a new modified time, or it was the same as the last one.
            if (!newModifiedTime || newModifiedTime === lastModifiedTime)
                return;
            lastModifiedTime = newModifiedTime;
            // Ensure we don't fire too often as some OSes may generate multiple events.
            exports.commandState.promptToReloadOnVersionChanges = false;
            // Allow it again in 60 seconds.
            setTimeout(() => exports.commandState.promptToReloadOnVersionChanges = true, 60000);
            // Wait a short period before prompting.
            setTimeout(() => util.promptToReloadExtension("Your Dart SDK has been updated. Reload using the new SDK?", undefined, false), 1000);
        });
        this.disposables.push({ dispose() { watcher.close(); } });
    }
}
exports.SdkCommands = SdkCommands;
function markProjectCreationStarted() {
    exports.commandState.numProjectCreationsInProgress++;
}
function markProjectCreationEnded() {
    exports.commandState.numProjectCreationsInProgress--;
}
class ChainedProcess {
    spawn;
    static processNumber = 1;
    processNumber = ChainedProcess.processNumber++;
    completer = new utils_1.PromiseCompleter();
    completed = this.completer.promise;
    process;
    isCancelled = false;
    get hasStarted() {
        return this.process !== undefined;
    }
    constructor(spawn, parent) {
        this.spawn = spawn;
        // We'll either start immediately, or if given a parent process only when it completes.
        if (parent) {
            void parent.completed.then(() => this.start());
        }
        else {
            this.start();
        }
    }
    start() {
        if (this.process)
            throw new Error(`${this.processNumber} Can't start an already started process!`);
        if (this.isCancelled) {
            this.completer.resolve(undefined);
            return;
        }
        this.process = this.spawn();
        this.process.on("close", (code) => this.completer.resolve((0, utils_1.nullToUndefined)(code)));
    }
    cancel() {
        this.isCancelled = true;
    }
}


/***/ }),

/***/ 2320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsCommands = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
class SettingsCommands {
    logger;
    wsContext;
    disposables = [];
    constructor(logger, wsContext) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.disposables.push(vs.commands.registerCommand("_dart.settings.openDartTestAdditionalArgs", () => this.openSettings("dart.testAdditionalArgs")));
        this.disposables.push(vs.commands.registerCommand("_dart.settings.openFlutterTestAdditionalArgs", () => this.openSettings("dart.flutterTestAdditionalArgs")));
    }
    async openSettings(settingName) {
        await vs.commands.executeCommand("workbench.action.openSettings2", {
            query: settingName,
            // https://github.com/microsoft/vscode/issues/226071
            // target: vs.ConfigurationTarget.Workspace,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.SettingsCommands = SettingsCommands;


/***/ }),

/***/ 4001:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCommands = exports.isInImplementationFileThatCanHaveTest = exports.isInTestFileThatHasImplementation = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_uri_1 = __webpack_require__(8945);
const constants_1 = __webpack_require__(6709);
const test_model_1 = __webpack_require__(5871);
const version_1 = __webpack_require__(7149);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const test_1 = __webpack_require__(672);
const debugger_1 = __webpack_require__(7976);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const editors_1 = __webpack_require__(9451);
const project_1 = __webpack_require__(5143);
const utils_3 = __webpack_require__(279);
const CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION = "dart-code:canGoToTestOrImplementationFile";
// HACK: Used for testing since we can't read contexts?
exports.isInTestFileThatHasImplementation = false;
exports.isInImplementationFileThatCanHaveTest = false;
class TestCommands {
    logger;
    testModel;
    wsContext;
    vsCodeTestController;
    dartCapabilities;
    flutterCapabilities;
    disposables = [];
    constructor(logger, testModel, wsContext, vsCodeTestController, dartCapabilities, flutterCapabilities) {
        this.logger = logger;
        this.testModel = testModel;
        this.wsContext = wsContext;
        this.vsCodeTestController = vsCodeTestController;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables.push(vs.commands.registerCommand("_dart.startDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(false, test, launchTemplate)), vs.commands.registerCommand("_dart.startWithoutDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(true, test, launchTemplate)), vs.commands.registerCommand("_dart.startDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPrompts, testRun) => this.runTestsForNode(suiteData, treeNodes, true, suppressPrompts, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("_dart.startWithoutDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPrompts, testRun) => this.runTestsForNode(suiteData, treeNodes, false, suppressPrompts, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("_dart.runAllTestsWithoutDebugging", (suitesToRun, nodesToExclude, testRun, isRunningAll) => this.runAllTestsWithoutDebugging(suitesToRun, nodesToExclude, testRun, isRunningAll)), vs.commands.registerCommand("dart.goToTests", (resource) => this.goToTestOrImplementationFile(resource), this), vs.commands.registerCommand("dart.goToTestOrImplementationFile", () => this.goToTestOrImplementationFile(), this), vs.commands.registerCommand("dart.findTestOrImplementationFile", () => this.findTestOrImplementationFile(), this), vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
    }
    async runAllTestsWithoutDebugging(suites, exclusions, testRun, isRunningAll) {
        // To run multiple folders/suites, we can pass the first as `program` and the rest as `args` which
        // will be appended immediately after `program`. However, this only works for things in the same project
        // as the first one that runs will be used for resolving package: URIs etc. We also can't mix and match
        // integration tests with non-integration tests.
        // So, fetch all project folders, then if we have suites in them, group them by that folders (and whether
        // they're integration/non-integration), and otherwise use their 'test'/'integration_test' folders.
        const projectFolders = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
        // Sort folders by length descending so that for any given suite, we know the first one that contains
        // it is the closest parent, so we can avoid running the same test multiple times if it's in a nested
        // project.
        (0, array_1.sortBy)(projectFolders, (f) => -1 * f.length);
        function closestProjectFolder(suitePath) {
            return projectFolders.find((f) => (0, fs_1.isWithinPath)(suitePath, f));
        }
        const projectsWithTests = [];
        function addTestItemsForProject(projectFolder, integrationTests) {
            if (!suites)
                return;
            let testPaths = suites
                .map((suite) => suite.suiteData.path)
                .filter((suitePath) => (0, fs_1.isWithinPath)(suitePath, projectFolder))
                .filter((suitePath) => (0, utils_3.isInsideFolderNamed)(suitePath, "integration_test") === integrationTests)
                .filter((suitePath) => closestProjectFolder(suitePath) === projectFolder);
            // If we might be running all, compute if there are any exclusions in this project. If not, we
            // can drop passing all the test names to "dart test" and just run the whole top level folder.
            const hasExclusions = isRunningAll && exclusions?.length && !!exclusions
                .map((node) => node.suiteData.path)
                .filter((suitePath) => (0, fs_1.isWithinPath)(suitePath, projectFolder))
                .filter((suitePath) => (0, utils_3.isInsideFolderNamed)(suitePath, "integration_test") === integrationTests)
                .find((suitePath) => closestProjectFolder(suitePath) === projectFolder);
            if (testPaths.length) {
                const projectName = path.basename(projectFolder);
                const testType = integrationTests ? "Integration Tests" : "Tests";
                const name = `${projectName} ${testType}`;
                // Use relative paths.
                testPaths = testPaths.map((suitePath) => path.relative(projectFolder, suitePath));
                // To avoid making a huge list of suite names that may trigger
                // "The command line is too long" on Windows, if we know we're running them
                // _all_ we can simplify the list of test names to just the top-level folders
                // that contain each.
                if (isRunningAll && !hasExclusions)
                    testPaths = (0, utils_1.uniq)(testPaths.map((suitePath) => suitePath.split(path.sep)[0]));
                projectsWithTests.push({ projectFolder, name, relativeTestPaths: testPaths });
            }
        }
        for (const projectFolder of projectFolders) {
            addTestItemsForProject(projectFolder, false);
            addTestItemsForProject(projectFolder, true);
        }
        if (projectsWithTests.length === 0) {
            void vs.window.showErrorMessage("Unable to find any test folders");
            return;
        }
        await Promise.all(projectsWithTests.map((projectWithTests) => this.runTests({
            debug: false,
            isFlutter: undefined, // unknown, runTests will compute
            launchTemplate: {
                args: projectWithTests.relativeTestPaths.slice(1),
                cwd: projectWithTests.projectFolder,
                name: projectWithTests.name,
            },
            programPath: path.join(projectWithTests.projectFolder, projectWithTests.relativeTestPaths[0]),
            shouldRunSkippedTests: false,
            suppressPrompts: suites?.length !== 1,
            testRun,
            testSelection: undefined,
            token: undefined,
            useLaunchJsonTestTemplate: true,
        })));
    }
    async runTestsForNode(suiteData, nodes, debug, suppressPrompts, runSkippedTests, token, testRun) {
        const testSelection = (0, test_1.getTestSelectionForNodes)(nodes);
        const programPath = (0, fs_1.fsPath)(vscode_uri_1.URI.file(suiteData.path));
        const isFlutter = (0, utils_3.isInsideFlutterProject)(vs.Uri.file(suiteData.path));
        const canRunSkippedTest = this.flutterCapabilities.supportsRunSkippedTests || !isFlutter;
        const shouldRunSkippedTests = runSkippedTests && canRunSkippedTest;
        return this.runTests({
            debug,
            isFlutter,
            launchTemplate: undefined,
            programPath,
            shouldRunSkippedTests,
            suppressPrompts,
            testRun,
            testSelection,
            token,
            useLaunchJsonTestTemplate: true,
        });
    }
    async runTests({ programPath, debug, testSelection, shouldRunSkippedTests, suppressPrompts, launchTemplate, testRun, token, useLaunchJsonTestTemplate, isFlutter }) {
        if (useLaunchJsonTestTemplate) {
            // Get the default Run/Debug template for running/debugging tests and use that as a base.
            const template = (0, debugger_1.getLaunchConfigDefaultTemplate)(vs.Uri.file(programPath), debug);
            if (template)
                launchTemplate = Object.assign({}, template, launchTemplate);
        }
        let shouldRunTestsByLine = false;
        // Determine wheher we can and should run tests by line number.
        if (testSelection?.length && config_1.config.testInvocationMode === "line") {
            isFlutter = isFlutter ?? (0, utils_3.isPathInsideFlutterProject)(programPath);
            if (isFlutter) {
                shouldRunTestsByLine = this.flutterCapabilities.supportsRunTestsByLine;
            }
            else {
                const projectFolderPath = (0, project_1.locateBestProjectRoot)(programPath);
                if (projectFolderPath) {
                    const testCapabilities = await (0, version_1.getPackageTestCapabilities)(this.logger, this.wsContext, projectFolderPath);
                    if (testCapabilities.supportsRunTestsByLine) {
                        shouldRunTestsByLine = true;
                    }
                }
            }
        }
        const subs = [];
        return new Promise(async (resolve, reject) => {
            let testsName = path.basename(programPath);
            // Handle when running whole test folder.
            if (testsName === "test")
                testsName = path.basename(path.dirname(programPath));
            const launchConfiguration = {
                suppressPrompts,
                ...(0, test_1.getLaunchConfig)(!debug, programPath, testSelection, shouldRunTestsByLine, shouldRunSkippedTests, launchTemplate),
                name: launchTemplate?.name ?? `${path.basename(programPath)} tests`,
            };
            // Ensure we have a unique ID for this session so we can track when it completes.
            const dartCodeDebugSessionID = (0, utils_3.ensureDebugLaunchUniqueId)(launchConfiguration);
            // If we were given a test to use by VS Code, use it. Otherwise we'll lazily create one at the
            // other end.
            if (testRun)
                this.vsCodeTestController?.registerTestRun(dartCodeDebugSessionID, testRun, false);
            if (token) {
                subs.push(vs.debug.onDidStartDebugSession((e) => {
                    if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                        subs.push(token.onCancellationRequested(() => e.customRequest("disconnect")));
                }));
            }
            subs.push(vs.debug.onDidTerminateDebugSession((e) => {
                if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                    resolve(true);
            }));
            const didStart = await vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(programPath)), launchConfiguration);
            if (!didStart) {
                // Failures to start will trigger their own messages (from debug_config_provider) so we
                // should not reject() here, as VS Code will show an additional (less helpful) error
                // message.
                resolve(false);
            }
        }).finally(() => {
            (0, utils_1.disposeAll)(subs);
        });
    }
    startTestFromOutline(noDebug, test, launchTemplate) {
        const isFlutter = (0, utils_3.isInsideFlutterProject)(vs.Uri.file(test.file));
        const canRunSkippedTest = (this.flutterCapabilities.supportsRunSkippedTests || !isFlutter);
        const shouldRunSkippedTests = canRunSkippedTest; // These are the same when running directly, since we always run skipped.
        return this.runTests({
            debug: !noDebug,
            isFlutter,
            launchTemplate,
            programPath: test.file,
            shouldRunSkippedTests,
            suppressPrompts: false,
            testRun: undefined,
            testSelection: [(0, test_1.getTestSelectionForOutline)(test)],
            token: undefined,
        });
    }
    async goToTestOrImplementationFile(resource) {
        return this.locateTestOrImplementationFile(resource);
    }
    async findTestOrImplementationFile() {
        return this.locateTestOrImplementationFile(undefined, { showFindDialogIfNoMatches: true });
    }
    async locateTestOrImplementationFile(resource, { showFindDialogIfNoMatches } = {}) {
        const doc = resource
            ? await vs.workspace.openTextDocument(resource)
            : (0, editors_1.getActiveRealFileEditor)()?.document;
        if (!doc || !(0, editors_1.isDartDocument)(doc))
            return;
        const filePath = (0, fs_1.fsPath)(doc.uri);
        const isTest = (0, utils_3.isTestFile)(filePath);
        const candidateFiles = isTest
            ? this.getCandidateImplementationFiles(filePath)
            : this.getCandidateTestFiles(filePath);
        let otherExistingFile = candidateFiles.find(fs.existsSync);
        const otherFile = otherExistingFile ?? (candidateFiles.length ? candidateFiles[0] : undefined);
        // If no match and we want to search, search...
        if (!otherExistingFile && showFindDialogIfNoMatches)
            return this.showSearchResults(filePath, isTest);
        let selectionOffset;
        let selectionLength;
        // Offer to create files.
        if (!otherExistingFile && otherFile) {
            // But not if we're a test... we can create test files, but not implementations.
            if (isTest)
                return;
            const relativePath = vs.workspace.asRelativePath(otherFile, false);
            const yesAction = (0, test_1.createTestFileAction)(relativePath);
            const response = await vs.window.showInformationMessage(`Would you like to create a test file at ${relativePath}?`, yesAction, constants_1.noAction);
            if (response !== yesAction)
                return;
            otherExistingFile = otherFile;
            (0, fs_1.mkDirRecursive)(path.dirname(otherExistingFile));
            const testFileInfo = (0, test_1.defaultTestFileContents)(this.wsContext.hasAnyFlutterProjects, (0, utils_1.escapeDartString)((0, utils_1.generateTestNameFromFileName)(relativePath)));
            fs.writeFileSync(otherExistingFile, testFileInfo.contents);
            selectionOffset = testFileInfo.selectionOffset;
            selectionLength = testFileInfo.selectionLength;
        }
        const document = await vs.workspace.openTextDocument(otherExistingFile);
        const editor = await vs.window.showTextDocument(document);
        if (selectionOffset && selectionLength)
            editor.selection = new vs.Selection(document.positionAt(selectionOffset), document.positionAt(selectionOffset + selectionLength));
    }
    showSearchResults(filePath, isTest) {
        const sourceFileBaseName = path.parse(filePath).name;
        const targetFileBaseName = isTest
            ? (sourceFileBaseName.endsWith("_test") ? sourceFileBaseName.substring(0, sourceFileBaseName.length - "_test".length) : sourceFileBaseName)
            : `${sourceFileBaseName}_test`;
        void vs.commands.executeCommand("workbench.action.quickOpen", `${targetFileBaseName}.dart`);
    }
    updateEditorContexts(e) {
        exports.isInTestFileThatHasImplementation = false;
        exports.isInImplementationFileThatCanHaveTest = false;
        if (e && e.document && (0, editors_1.isDartDocument)(e.document)) {
            const filePath = (0, fs_1.fsPath)(e.document.uri);
            if ((0, utils_3.isTestFile)(filePath)) {
                // Implementation files must exist.
                const implementationFilePath = this.getCandidateImplementationFiles(filePath).find(fs.existsSync);
                exports.isInTestFileThatHasImplementation = !!implementationFilePath && fs.existsSync(implementationFilePath);
            }
            else {
                exports.isInImplementationFileThatCanHaveTest = this.getCandidateTestFiles(filePath).length > 0;
            }
        }
        void vs.commands.executeCommand("setContext", CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION, exports.isInTestFileThatHasImplementation || exports.isInImplementationFileThatCanHaveTest);
    }
    getCandidateImplementationFiles(filePath) {
        const candidates = [];
        const pathSegments = filePath.split(path.sep);
        const testFolderIndex = pathSegments.lastIndexOf("test");
        // Remove _test from the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/_test\.dart/, ".dart");
        // Add a copy with test -> lib
        if (testFolderIndex !== -1) {
            const temp = [...pathSegments];
            temp[testFolderIndex] = "lib";
            candidates.push(temp.join(path.sep));
            // Also add a copy with test -> lib/src to match what we do the other way
            temp.splice(testFolderIndex + 1, 0, "src");
            candidates.push(temp.join(path.sep));
        }
        // Add the original path to support files alongside.
        candidates.push(pathSegments.join(path.sep));
        return candidates;
    }
    getCandidateTestFiles(filePath) {
        const candidates = [];
        const pathSegments = filePath.split(path.sep);
        const libFolderIndex = pathSegments.lastIndexOf("lib");
        // Add _test to the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/\.dart/, "_test.dart");
        // Add a copy with lib -> test
        if (libFolderIndex !== -1) {
            const temp = [...pathSegments];
            temp[libFolderIndex] = "test";
            candidates.push(temp.join(path.sep));
            // If we're in lib/src, also add a copy in the corresponding test folder without
            // the src/ since sometimes src/ is omitted in the test paths.
            if (temp[libFolderIndex + 1] === "src") {
                temp.splice(libFolderIndex + 1, 1);
                candidates.push(temp.join(path.sep));
            }
        }
        // Add the original path to support files alongside.
        candidates.push(pathSegments.join(path.sep));
        return candidates;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCommands = TestCommands;


/***/ }),

/***/ 5933:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyCommand = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const editors = __importStar(__webpack_require__(9451));
class TypeHierarchyCommand {
    logger;
    analyzer;
    disposables = [];
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(vs.commands.registerCommand("dart.showTypeHierarchy", this.showTypeHierarchy, this));
    }
    async showTypeHierarchy() {
        const editor = editors.getActiveDartEditor();
        if (!editor) {
            void vs.window.showWarningMessage("No active Dart editor.");
            return;
        }
        const document = editor.document;
        const originalSelection = editor.selection;
        const response = await this.analyzer.searchGetTypeHierarchy({
            file: (0, fs_1.fsPath)(document.uri),
            offset: document.offsetAt(editor.selection.active),
        });
        const items = response.hierarchyItems;
        if (!items) {
            void vs.window.showInformationMessage("Type hierarchy not available.");
            return;
        }
        const options = {
            onDidSelectItem: (item) => this.openLocation(item, true),
            placeHolder: name(items, 0),
        };
        // TODO: How / where to show implements?
        const tree = [];
        const startItem = items[0];
        tree.push(startItem);
        addParents(items, tree, startItem);
        addChildren(items, tree, startItem);
        const result = await vs.window.showQuickPick(tree.map((item) => itemToPick(item, items)), options);
        if (result && result.location) {
            await this.openLocation(result);
        }
        else {
            // Move the use back to where they were.
            const ed = await vs.window.showTextDocument(document);
            ed.revealRange(editor.selection, vs.TextEditorRevealType.InCenterIfOutsideViewport);
            ed.selection = originalSelection;
        }
    }
    async openLocation(result, asPreview = false) {
        if (!result.location) {
            this.logger.warn(`Unable to open item with no location`);
            return;
        }
        const location = result.location;
        const document = await vs.workspace.openTextDocument(location.file);
        const editor = await vs.window.showTextDocument(document, {
            preserveFocus: asPreview,
            preview: asPreview,
        });
        const range = (0, utils_2.toRangeOnLine)(location);
        (0, utils_2.showCode)(editor, range, range, range);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TypeHierarchyCommand = TypeHierarchyCommand;
function addParents(items, tree, item) {
    if (item.superclass) {
        const parent = items[item.superclass];
        if (parent.classElement.name !== "Object") {
            tree.unshift(parent);
            addParents(items, tree, parent);
        }
    }
}
function addChildren(items, tree, item) {
    // Handle direct children.
    for (const index of item.subclasses) {
        const child = items[index];
        tree.push(child);
    }
    // Handle grandchildren.
    for (const index of item.subclasses) {
        const child = items[index];
        if (child.subclasses.length > 0)
            addChildren(items, tree, child);
    }
}
function itemToPick(item, items) {
    let desc = "";
    // extends
    if (item.superclass !== undefined && name(items, item.superclass) !== "Object")
        desc += `extends ${name(items, item.superclass)}`;
    // implements
    if (item.interfaces.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `implements ${item.interfaces.map((i) => name(items, i)).join(", ")}`;
    }
    // with
    if (item.mixins.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `with ${item.mixins.map((i) => name(items, i)).join(", ")}`;
    }
    const result = {
        description: desc,
        label: item.classElement.name,
        location: item.classElement.location,
    };
    return result;
}
function name(items, index) {
    return items[index].classElement.name;
}


/***/ }),

/***/ 7678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.ResourceConfig = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const utils_3 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
class Config {
    config;
    constructor() {
        vscode_1.workspace.onDidChangeConfiguration((e) => this.reloadConfig());
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    reloadConfig() {
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    getConfig(key, defaultValue) {
        const value = this.config.get(key, defaultValue);
        return (0, utils_1.nullToUndefined)(value);
    }
    getWorkspaceConfig(key) {
        const c = this.config.inspect(key);
        if (c && c.workspaceValue)
            return c.workspaceValue;
        if (c && c.workspaceFolderValue) {
            return c.workspaceFolderValue;
        }
        return undefined;
    }
    hasExplicitSetting(key) {
        const result = this.config.inspect(key);
        return result?.globalValue !== undefined
            || result?.workspaceValue !== undefined
            || result?.workspaceValue !== undefined;
    }
    async setConfig(key, value, target) {
        await this.config.update(key, value, target);
    }
    get addSdkToTerminalPath() { return this.getConfig("addSdkToTerminalPath", true); }
    get additionalAnalyzerFileExtensions() { return this.getConfig("additionalAnalyzerFileExtensions", []); }
    get allowAnalytics() { return this.getConfig("allowAnalytics", true); }
    get allowFlutterForcedDebugMode() { return this.getConfig("allowFlutterForcedDebugMode", true); }
    get allowTestsOutsideTestFolder() { return this.getConfig("allowTestsOutsideTestFolder", false); }
    get analysisServerFolding() { return this.getConfig("analysisServerFolding", true); }
    get analyzeAngularTemplates() { return this.getConfig("analyzeAngularTemplates", true); }
    get analyzerAdditionalArgs() { return this.getConfig("analyzerAdditionalArgs", []); }
    get analyzerDiagnosticsPort() { return this.getConfig("analyzerDiagnosticsPort", null); }
    get analyzerInstrumentationLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null)))); }
    get analyzerLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null)))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get analyzerSshHost() { return this.getConfig("analyzerSshHost", null); }
    get analyzerVmAdditionalArgs() { return this.getConfig("analyzerVmAdditionalArgs", []); }
    get analyzerVmServicePort() { return this.getConfig("analyzerVmServicePort", null); }
    get autoImportCompletions() { return this.getConfig("autoImportCompletions", true); }
    get automaticCommentSlashes() { return this.getConfig("automaticCommentSlashes", "tripleSlash"); }
    get buildRunnerAdditionalArgs() { return this.getConfig("buildRunnerAdditionalArgs", []); }
    get checkForSdkUpdates() { return this.getConfig("checkForSdkUpdates", true); }
    get cliConsole() { return this.getConfig("cliConsole", "debugConsole"); }
    get closeDevTools() { return this.getConfig("closeDevTools", "never"); }
    get closingLabels() { return this.getConfig("closingLabels", true); }
    get closingLabelsPrefix() { return this.getConfig("closingLabelsPrefix", " // "); }
    get closingLabelsTextStyle() { return this.getConfig("closingLabelsTextStyle", "normal"); }
    get completionBudgetMilliseconds() { return this.getConfig("completionBudgetMilliseconds", undefined); }
    get customDartDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customDartDapPath", null)); }
    get customDevToolsUri() { return this.getConfig("customDevToolsUri", undefined); }
    get customDevTools() { return this.getConfig("customDevTools", null); }
    get customFlutterDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customFlutterDapPath", null)); }
    get dapLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null)))); }
    get dartTestLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null)))); }
    get daemonPort() { return this.getConfig("daemonPort", null); }
    get debugExtensionBackendProtocol() { return this.getConfig("debugExtensionBackendProtocol", "ws"); }
    get debugExternalPackageLibraries() { return this.getConfig("debugExternalPackageLibraries", false); }
    get debugSdkLibraries() { return this.getConfig("debugSdkLibraries", false); }
    get devToolsBrowser() { return this.getConfig("devToolsBrowser", "chrome"); }
    get devToolsLocation() {
        const defaultValue = { default: "beside" };
        const configValue = this.getConfig("devToolsLocation", defaultValue);
        if (!defaultValue)
            return defaultValue;
        // Legacy string value.
        if (typeof configValue === "string")
            return { default: configValue };
        // Otherwise, user defined (but force default value).
        return {
            default: "beside", // Ensure default if not user-supplied.
            ...configValue,
        };
    }
    get devToolsLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null)))); }
    get devToolsPort() { return this.getConfig("devToolsPort", null); }
    get devToolsReuseWindows() { return this.getConfig("devToolsReuseWindows", true); }
    get devToolsTheme() { return this.getConfig("devToolsTheme", "dark"); }
    get documentation() { return this.getConfig("documentation", null); }
    get enablePub() { return this.getConfig("enablePub", true); }
    get enableSdkFormatter() { return this.getConfig("enableSdkFormatter", true); }
    get enableServerSnippets() { return this.getConfig("enableServerSnippets", true); }
    get enableSnippets() { return this.getConfig("enableSnippets", true); }
    get env() { return this.getConfig("env", {}); }
    get evaluateToStringInDebugViews() { return this.getConfig("evaluateToStringInDebugViews", true); }
    get experimentalRefactors() { return this.getConfig("experimentalRefactors", false); }
    get experimentalTestRunnerInSdk() { return this.getConfig("experimentalTestRunnerInSdk", false); }
    get extensionLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null)))); }
    get flutterAdbConnectOnChromeOs() { return this.getConfig("flutterAdbConnectOnChromeOs", false); }
    get flutterCreateAndroidLanguage() { return this.getConfig("flutterCreateAndroidLanguage", "kotlin"); }
    get flutterCreateIOSLanguage() { return this.getConfig("flutterCreateIOSLanguage", "swift"); }
    get flutterCreateOffline() { return this.getConfig("flutterCreateOffline", false); }
    get flutterCreateOrganization() { return this.getConfig("flutterCreateOrganization", null); }
    get flutterCreatePlatforms() { return this.getConfig("flutterCreatePlatforms", undefined); }
    get flutterCustomEmulators() { return this.getConfig("flutterCustomEmulators", []); }
    get flutterDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null)))); }
    get flutterGenerateLocalizationsOnSave() { return this.getConfig("flutterGenerateLocalizationsOnSave", "never"); }
    get flutterGutterIcons() { return this.getConfig("flutterGutterIcons", true); }
    get flutterHotReloadOnSave() {
        const value = this.getConfig("flutterHotReloadOnSave", "manual");
        // Convert the legacy values to new values, if required.
        if (value === true)
            return "manual";
        else if (value === false)
            return "never";
        else if (value === "always")
            return "all";
        else
            return value;
    }
    get flutterOutline() { return this.getConfig("flutterOutline", true); }
    get flutterRememberSelectedDevice() { return this.getConfig("flutterRememberSelectedDevice", true); }
    get flutterRunLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null)))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterSelectDeviceWhenConnected() { return this.getConfig("flutterSelectDeviceWhenConnected", true); }
    get flutterShowEmulators() { return this.getConfig("flutterShowEmulators", "local"); }
    get flutterShowWebServerDevice() { return this.getConfig("flutterShowWebServerDevice", "remote"); }
    get flutterTestLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null)))); }
    get flutterWebRenderer() { return this.getConfig("flutterWebRenderer", "flutter-default"); }
    get getDartSdkCommand() { return this.getConfig("getDartSdkCommand", null); }
    get getFlutterSdkCommand() { return this.getConfig("getFlutterSdkCommand", null); }
    get hotReloadOnSave() {
        const value = this.getConfig("hotReloadOnSave", "never");
        if (value === "always")
            return "all";
        else
            return value;
    }
    get hotReloadProgress() { return this.getConfig("hotReloadProgress", "notification"); }
    get includeDependenciesInWorkspaceSymbols() { return this.getConfig("includeDependenciesInWorkspaceSymbols", true); }
    get lspSnippetTextEdits() { return this.getConfig("lspSnippetTextEdits", true); }
    get maxCompletionItems() { return this.getConfig("maxCompletionItems", null); }
    get maxLogLineLength() { return this.getConfig("maxLogLineLength", 2000); }
    get normalizeFileCasing() { return this.getConfig("normalizeFileCasing", false); }
    get notifyAnalyzerErrors() { return this.getConfig("notifyAnalyzerErrors", true); }
    get offline() { return this.getConfig("offline", false); }
    get onlyAnalyzeProjectsWithOpenFiles() { return this.getConfig("onlyAnalyzeProjectsWithOpenFiles", false); }
    get openDevTools() { return this.getConfig("openDevTools", "never"); }
    get openTestView() { return this.getConfig("openTestView", ["testRunStart"]); }
    get previewCommitCharacters() { return this.getConfig("previewCommitCharacters", false); }
    // TODO(dantup): When removing this flag, be sure to update the test
    // "should expose LSP methods via the analyzer"
    get previewDtdLspIntegration() { return this.getConfig("previewDtdLspIntegration", false); }
    get experimentalDtdHandlers() { return this.getConfig("experimentalDtdHandlers", false); }
    get experimentalPropertyEditor() { return this.getConfig("experimentalPropertyEditor", false); }
    get dtdEditorActiveLocationDelay() { return this.getConfig("dtdEditorActiveLocationDelay", 200); }
    get previewFlutterUiGuides() { return this.getConfig("previewFlutterUiGuides", false); }
    get previewFlutterUiGuidesCustomTracking() { return this.getConfig("previewFlutterUiGuidesCustomTracking", false); }
    get previewHotReloadOnSaveWatcher() { return this.getConfig("previewHotReloadOnSaveWatcher", false); }
    get projectSearchDepth() { return this.getConfig("projectSearchDepth", 5); }
    get promptToRunIfErrors() { return this.getConfig("promptToRunIfErrors", true); }
    get renameFilesWithClasses() { return this.getConfig("renameFilesWithClasses", "never"); }
    get runPubGetOnNestedProjects() { return this.getConfig("runPubGetOnNestedProjects", "none"); }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get sdkSwitchingTarget() { return this.getConfig("sdkSwitchingTarget", "workspace"); }
    get shareDevToolsWithFlutter() { return this.getConfig("shareDevToolsWithFlutter", true); }
    get showDartPadSampleCodeLens() { return this.getConfig("showDartPadSampleCodeLens", true); }
    get showDebuggerNumbersAsHex() { return this.getConfig("showDebuggerNumbersAsHex", false); }
    get showDevToolsDebugToolBarButtons() { return this.getConfig("showDevToolsDebugToolBarButtons", true); }
    get showExtensionRecommendations() { return this.getConfig("showExtensionRecommendations", true); }
    get showInspectorNotificationsForWidgetErrors() { return this.getConfig("showInspectorNotificationsForWidgetErrors", true); }
    get showMainCodeLens() { return this.getConfig("showMainCodeLens", true); }
    get showSkippedTests() { return this.getConfig("showSkippedTests", true); }
    get showTestCodeLens() { return this.getConfig("showTestCodeLens", true); }
    get showTodos() { return this.getConfig("showTodos", true); }
    get testInvocationMode() { return this.getConfig("testInvocationMode", "name"); }
    get toolingDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("toolingDaemonLogFile", null)))); }
    get updateDevTools() { return this.getConfig("updateDevTools", true); }
    get updateImportsOnRename() { return this.getConfig("updateImportsOnRename", true); }
    get useLegacyAnalyzerProtocol() { return this.getConfig("useLegacyAnalyzerProtocol", false); }
    get useLegacyDebugAdapters() { return this.getConfig("useLegacyDebugAdapters", null); }
    get vmServiceLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null)))); }
    get warnWhenEditingFilesInPubCache() { return this.getConfig("warnWhenEditingFilesInPubCache", true); }
    get warnWhenEditingFilesOutsideWorkspace() { return this.getConfig("warnWhenEditingFilesOutsideWorkspace", true); }
    get webDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null)))); }
    // Helpers
    get useDevToolsDarkTheme() { return this.devToolsTheme === "dark"; }
    get openTestViewOnFailure() { return this.openTestView.includes("testFailure"); }
    get openTestViewOnStart() { return this.openTestView.includes("testRunStart"); }
    get workspaceSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("sdkPath")); }
    get workspaceFlutterSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("flutterSdkPath")); }
    get workspaceGetDartSdkCommand() { return this.getWorkspaceConfig("getDartSdkCommand"); }
    get workspaceGetFlutterSdkCommand() { return this.getWorkspaceConfig("getFlutterSdkCommand"); }
    get hasExplicitShowTodosSetting() {
        return this.hasExplicitSetting("showTodos");
    }
    // Options that can be set programatically.
    setShowDebuggerNumbersAsHex(value) { return this.setConfig("showDebuggerNumbersAsHex", value, vscode_1.ConfigurationTarget.Global); }
    setCheckForSdkUpdates(value) { return this.setConfig("checkForSdkUpdates", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateOrganization(value) { return this.setConfig("flutterCreateOrganization", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateAndroidLanguage(value) { return this.setConfig("flutterCreateAndroidLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateIOSLanguage(value) { return this.setConfig("flutterCreateIOSLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreatePlatforms(value) { return this.setConfig("flutterCreatePlatforms", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterSdkPath(value, target) { return this.setConfig("flutterSdkPath", value, target); }
    setGlobalDartSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugSdkLibraries(value) { return this.setConfig("debugSdkLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugExternalPackageLibraries(value) { return this.setConfig("debugExternalPackageLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setOffline(value) { return this.setConfig("offline", value, vscode_1.ConfigurationTarget.Global); }
    setOpenDevTools(value) { return this.setConfig("openDevTools", value, vscode_1.ConfigurationTarget.Global); }
    setShowInspectorNotificationsForWidgetErrors(value) { return this.setConfig("showInspectorNotificationsForWidgetErrors", value, vscode_1.ConfigurationTarget.Global); }
    setShowTodos(value, target) { return this.setConfig("showTodos", value, target); }
    setSdkPath(value, target) { return this.setConfig("sdkPath", value, target); }
    setWarnWhenEditingFilesOutsideWorkspace(value) { return this.setConfig("warnWhenEditingFilesOutsideWorkspace", value, vscode_1.ConfigurationTarget.Global); }
    setWarnWhenEditingFilesInPubCache(value) { return this.setConfig("warnWhenEditingFilesInPubCache", value, vscode_1.ConfigurationTarget.Global); }
    // Experiments that aren't in package.json.
    // get experimentalMacroSupport(): boolean { return this.getConfig<boolean>("experimentalMacroSupport", false); }
    resolved = new ResolvedConfig();
    for(uri) {
        return new ResourceConfig(uri);
    }
}
class ResolvedConfig {
    dummyDartFile = vscode_1.Uri.parse("untitled:foo.dart");
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
    dartConfig = vscode_1.workspace.getConfiguration("", this.dummyDartFile).get("[dart]");
    getAppliedConfig(section, key, isResourceScoped = true) {
        const dartValue = this.dartConfig ? this.dartConfig[`${section}.${key}`] : undefined;
        return dartValue !== undefined && dartValue !== null
            ? dartValue
            : vscode_1.workspace.getConfiguration(section, isResourceScoped ? this.dummyDartFile : undefined).get(key);
    }
}
class ResourceConfig {
    uri;
    config;
    constructor(uri) {
        this.uri = uri;
        this.config = vscode_1.workspace.getConfiguration("dart", this.uri);
    }
    getConfig(key, defaultValue) {
        return (0, utils_1.nullToUndefined)(this.config.get(key, defaultValue));
    }
    get analysisExcludedFolders() { return this.getConfig("analysisExcludedFolders", []); }
    get analyzerInstrumentationLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null)))); }
    get analyzerLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null)))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get cliAdditionalArgs() { return this.getConfig("cliAdditionalArgs", []); }
    get completeFunctionCalls() { return this.getConfig("completeFunctionCalls", true); }
    get customDartDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customDartDapPath", null)); }
    get customDevTools() { return this.getConfig("customDevTools", null); }
    get customFlutterDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customFlutterDapPath", null)); }
    get daemonPort() { return this.getConfig("daemonPort", null); }
    get dapLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null)))); }
    get dartTestLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null)))); }
    get devToolsLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null)))); }
    get doNotFormat() { return this.getConfig("doNotFormat", []); }
    get enableCompletionCommitCharacters() { return this.getConfig("enableCompletionCommitCharacters", false); }
    get evaluateGettersInDebugViews() { return this.getConfig("evaluateGettersInDebugViews", true); }
    get extensionLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null)))); }
    get flutterAdditionalArgs() { return this.getConfig("flutterAdditionalArgs", []); }
    get flutterAttachAdditionalArgs() { return this.getConfig("flutterAttachAdditionalArgs", []); }
    get flutterDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null)))); }
    get flutterRunAdditionalArgs() { return this.getConfig("flutterRunAdditionalArgs", []); }
    get flutterRunLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null)))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterTestAdditionalArgs() { return this.getConfig("flutterTestAdditionalArgs", []); }
    get flutterTestLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null)))); }
    get flutterTrackWidgetCreation() { return this.getConfig("flutterTrackWidgetCreation", true); }
    get hotReloadPatterns() { return this.getConfig("hotReloadPatterns", []); }
    get insertArgumentPlaceholders() { return this.getConfig("insertArgumentPlaceholders", true); }
    get lineLength() { return this.getConfig("lineLength", 80); }
    get promptToGetPackages() { return this.getConfig("promptToGetPackages", true); }
    get pubAdditionalArgs() { return this.getConfig("pubAdditionalArgs", []); }
    get runPubGetOnPubspecChanges() {
        let value = this.getConfig("runPubGetOnPubspecChanges", "always");
        if (value === true)
            value = "always";
        if (value === false)
            value = "never";
        return value;
    }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get showDartDeveloperLogs() { return this.getConfig("showDartDeveloperLogs", true); }
    get showGettersInDebugViews() { return this.getConfig("showGettersInDebugViews", true); }
    get suppressTestTimeouts() { return this.getConfig("suppressTestTimeouts", "never"); }
    get testAdditionalArgs() { return this.getConfig("testAdditionalArgs", []); }
    get toolingDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("toolingDaemonLogFile", null)))); }
    get vmAdditionalArgs() { return this.getConfig("vmAdditionalArgs", []); }
    get vmServiceLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null)))); }
    get webDaemonLogFile() { return (0, fs_1.createFolderForFile)((0, utils_3.insertWorkspaceName)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null)))); }
}
exports.ResourceConfig = ResourceConfig;
exports.config = new Config();


/***/ }),

/***/ 8641:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTaskProvider = exports.BaseTaskProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const project_1 = __webpack_require__(5143);
const util = __importStar(__webpack_require__(279));
const processes_1 = __webpack_require__(8141);
const projects_1 = __webpack_require__(6265);
const buildRunnerProblemMatcher = "$dart-build_runner";
const buildRunnerBuildOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Build, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const buildRunnerTestOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Test, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const flutterBuildOptions = { isBackground: true, group: vs.TaskGroup.Build };
const taskOptions = [
    // test must come first so it matches before the next catch-all one
    [["pub", "run", "build_runner", "test"], buildRunnerTestOptions],
    [["pub", "run", "build_runner"], buildRunnerBuildOptions],
    [["build"], flutterBuildOptions],
];
class BaseTaskProvider {
    logger;
    context;
    sdks;
    constructor(logger, context, sdks) {
        this.logger = logger;
        this.context = context;
        this.sdks = sdks;
    }
    /// Tasks that will either be run by Dart or Flutter depending on the project type.
    createSharedTasks(workspaceFolder, projectFolder) {
        const promises = [];
        if (config_1.config.enablePub) {
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["get"]));
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["upgrade"]));
            if ((0, fs_1.referencesBuildRunner)((0, fs_1.fsPath)(projectFolder))) {
                promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "watch"]));
                promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "build"]));
                promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "serve"]));
                promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "test"]));
            }
        }
        return promises;
    }
    async resolveTask(task, token) {
        const scope = task.scope;
        const workspaceFolderPath = "uri" in scope ? (0, fs_1.fsPath)(scope.uri) : undefined;
        const definitionCwd = task.definition.cwd;
        const cwd = workspaceFolderPath && definitionCwd ? path.join(workspaceFolderPath, definitionCwd) : task.definition.cwd ?? workspaceFolderPath;
        const definition = task.definition;
        // Pub commands should be run through Flutter if a Flutter project.
        if (definition.command === "pub" && (0, fs_1.isFlutterProjectFolder)(cwd)) {
            definition.command = "flutter";
            definition.args = ["pub", ...(definition.args ?? [])];
        }
        const options = this.getOptions(definition);
        if (options?.runtimeArgs) {
            definition.args = (definition.args ?? []).concat((await options?.runtimeArgs()) ?? []);
        }
        await this.injectArgs(definition);
        // We *must* return a new Task here, otherwise the task cannot be customised
        // in task.json.
        // https://github.com/microsoft/vscode/issues/58836#issuecomment-696620105
        const newTask = new vs.Task(definition, 
        // This should never be undefined, but the type allows it but the constructor
        // arg does not.
        task.scope || vs.TaskScope.Workspace, task.name, task.source, await this.createTaskExecution(this.sdks, definition, cwd), undefined);
        newTask.detail = task.detail;
        newTask.problemMatchers = (newTask.problemMatchers && newTask.problemMatchers.length ? newTask.problemMatchers : options?.problemMatchers) ?? [];
        newTask.group = task.group ?? options?.group;
        newTask.isBackground = task.isBackground || (options?.isBackground ?? false);
        return newTask;
    }
    injectArgs(_) {
    }
    getOptions(def) {
        let taskCommand = [def.command, ...(def.args ?? [])];
        // Strip ""dart" or flutter" from the front for easier matching.
        if (taskCommand[0] === "flutter" || taskCommand[0] === "dart")
            taskCommand = taskCommand.slice(1);
        for (const knownOption of taskOptions) {
            const [command, options] = knownOption;
            if ((0, array_1.arrayStartsWith)(taskCommand, command))
                return options;
        }
    }
    createTaskStub(workspaceFolder, projectFolder, command, args) {
        const workspaceFolderPath = (0, fs_1.fsPath)(workspaceFolder.uri);
        const projectPath = (0, fs_1.fsPath)(projectFolder);
        const relativePath = path.relative(workspaceFolderPath, projectPath);
        const task = new vs.Task({ type: this.type, cwd: relativePath, command, args }, workspaceFolder, [command, ...args].join(" "), this.type, undefined, undefined);
        task.detail = relativePath;
        return task;
    }
    async createTask(workspaceFolder, projectFolder, command, args) {
        const task = this.createTaskStub(workspaceFolder, projectFolder, command, args);
        return this.resolveTask(task);
    }
    async runProjectTask(uri, command, args) {
        const projectRoot = uri ? (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(uri)) : undefined;
        const projectRootUri = projectRoot ? vs.Uri.file(projectRoot) : undefined;
        return this.runTask(projectRootUri, command, args);
    }
    async runTask(uri, command, args) {
        let projectFolder = uri;
        let workspaceFolder = uri ? vs.workspace.getWorkspaceFolder(uri) : undefined;
        if (!workspaceFolder) {
            const folderPath = await (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which project to run the command for");
            if (!folderPath)
                return;
            projectFolder = vs.Uri.file(folderPath);
            workspaceFolder = vs.workspace.getWorkspaceFolder(projectFolder);
        }
        if (!workspaceFolder)
            return;
        const task = await this.createTask(workspaceFolder, projectFolder, command, args);
        return vs.tasks.executeTask(task);
    }
    async createTaskExecution(sdks, definition, cwd) {
        if (!definition.command)
            return;
        const sdk = definition.command === "flutter" && sdks.flutter ? sdks.flutter : sdks.dart;
        const executable = (0, constants_1.getExecutableName)(definition.command);
        const program = path.join(sdk, "bin", executable);
        let args = definition.args ?? [];
        if (definition.runtimeArgs) {
            const runtimeArgs = await definition.runtimeArgs();
            if (runtimeArgs)
                args = args.concat(runtimeArgs);
        }
        return new vs.ProcessExecution(program, args || [], { cwd, env: (0, processes_1.getToolEnv)() });
    }
}
exports.BaseTaskProvider = BaseTaskProvider;
class DartTaskProvider extends BaseTaskProvider {
    dartCapabilities;
    static type = "dart"; // also referenced in package.json
    constructor(logger, context, sdks, dartCapabilities) {
        super(logger, context, sdks);
        this.dartCapabilities = dartCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("dart.task.dartdoc", (uri) => this.runTask(uri, this.dartDocCommand, this.dartDocArguments)));
    }
    get dartDocCommand() { return this.dartCapabilities.supportsDartDoc ? "dart" : "dartdoc"; }
    get dartDocArguments() { return this.dartCapabilities.supportsDartDoc ? ["doc", "."] : ["."]; }
    get type() { return DartTaskProvider.type; }
    async provideTasks(token) {
        const projectFolders = await (0, utils_1.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
        const promises = [];
        projectFolders.forEach((folder) => {
            const folderUri = vs.Uri.file(folder);
            const workspaceFolder = vs.workspace.getWorkspaceFolder(folderUri);
            const isFlutter = (0, fs_1.isFlutterProjectFolder)(folder);
            if (!isFlutter)
                promises.push(...this.createSharedTasks(workspaceFolder, folderUri));
            promises.push(this.createTask(workspaceFolder, folderUri, this.dartDocCommand, this.dartDocArguments));
            // For testing...
            // tasks.push(this.createTask(folder, "--version"));
        });
        const tasks = (await Promise.all(promises));
        return tasks;
    }
    createPubTask(workspaceFolder, projectFolder, args) {
        if (this.dartCapabilities.supportsDartRunForPub && args && args.length && args[0] === "run")
            return this.createTask(workspaceFolder, projectFolder, "dart", [...args]);
        else if (this.dartCapabilities.supportsDartPub)
            return this.createTask(workspaceFolder, projectFolder, "dart", ["pub", ...args]);
        else
            return this.createTask(workspaceFolder, projectFolder, "pub", args);
    }
}
exports.DartTaskProvider = DartTaskProvider;


/***/ }),

/***/ 6074:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HotReloadOnSaveHandler = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
const utils_2 = __webpack_require__(279);
class HotReloadOnSaveHandler {
    debugCommands;
    flutterCapabilities;
    disposables = [];
    flutterHotReloadDelayTimer;
    dartHotReloadDelayTimer;
    // Track save reason so we can avoid hot reloading on auto-saves.
    lastSaveReason;
    // And whether any saved file was dirty to support `..ifDirty` settings.
    isSavingDirtyFile = false;
    constructor(debugCommands, flutterCapabilities) {
        this.debugCommands = debugCommands;
        this.flutterCapabilities = flutterCapabilities;
        // Non-FS-watcher version (onDidSave).
        this.disposables.push(vscode_1.workspace.onWillSaveTextDocument((e) => {
            if (!this.isReloadableFile(e.document))
                return;
            this.lastSaveReason = e.reason;
            this.isSavingDirtyFile = this.isSavingDirtyFile || e.document.isDirty;
        }));
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            // Bail if we're using fs-watcher instead. We still wire this
            // handler up so we don't need to reload for this setting change.
            if (config_1.config.previewHotReloadOnSaveWatcher)
                return;
            this.triggerReload(td);
        }));
        // FS-watcher version.
        // TODO: Make this support everything that shouldHotReloadFor() does.
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/*.dart");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handleFileSystemChange, this);
        watcher.onDidCreate(this.handleFileSystemChange, this);
    }
    handleFileSystemChange(uri) {
        // Bail if we're not using fs-watcher instead. We still wire this
        // handler up so we don't need to reload for this setting change.
        if (!config_1.config.previewHotReloadOnSaveWatcher)
            return;
        this.triggerReload({ uri });
    }
    triggerReload(file) {
        const isAutoSave = this.lastSaveReason === vscode_1.TextDocumentSaveReason.FocusOut ||
            this.lastSaveReason === vscode_1.TextDocumentSaveReason.AfterDelay;
        // Never do anything for files inside .dart_tool folders.
        if (!this.isReloadableFile(file))
            return;
        const isDirty = this.isSavingDirtyFile;
        this.isSavingDirtyFile = false;
        // Don't do if we have errors for the saved file.
        const errors = vscode_1.languages.getDiagnostics(file.uri);
        const hasErrors = errors && !!errors.find((d) => d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Error);
        if (hasErrors)
            return;
        this.reloadDart({ isAutoSave, isDirty });
        this.reloadFlutter({ isAutoSave, isDirty });
    }
    isReloadableFile(file) {
        // Never do anything for files inside .dart_tool folders.
        if ((0, fs_1.fsPath)(file.uri).includes(`${path.sep}.dart_tool${path.sep}`))
            return false;
        // Bail out if we're in an external file, or not Dart.
        if (!(0, utils_2.isWithinWorkspace)((0, fs_1.fsPath)(file.uri)) || !(0, utils_2.shouldHotReloadFor)(file))
            return false;
        return true;
    }
    reloadDart({ isAutoSave, isDirty }) {
        const configSetting = config_1.config.hotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "dart.hotReload";
        const args = {
            onlyDart: true,
            reason: constants_1.restartReasonSave,
        };
        // Debounce to avoid reloading multiple times during multi-file-save (Save All).
        // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
        if (this.dartHotReloadDelayTimer) {
            clearTimeout(this.dartHotReloadDelayTimer);
        }
        this.dartHotReloadDelayTimer = setTimeout(() => {
            this.dartHotReloadDelayTimer = undefined;
            void vscode_1.commands.executeCommand(commandToRun, args);
        }, 200);
    }
    reloadFlutter({ isAutoSave, isDirty }) {
        const configSetting = config_1.config.flutterHotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "dart.hotReload";
        const args = {
            debounce: this.flutterCapabilities.supportsRestartDebounce,
            onlyFlutter: true,
            reason: constants_1.restartReasonSave,
        };
        if (this.flutterCapabilities.supportsRestartDebounce) {
            void vscode_1.commands.executeCommand(commandToRun, args);
        }
        else {
            // Debounce to avoid reloading multiple times during multi-file-save (Save All).
            // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
            if (this.flutterHotReloadDelayTimer) {
                clearTimeout(this.flutterHotReloadDelayTimer);
            }
            this.flutterHotReloadDelayTimer = setTimeout(() => {
                this.flutterHotReloadDelayTimer = undefined;
                void vscode_1.commands.executeCommand(commandToRun, args);
            }, 200);
        }
    }
    dispose() {
        if (this.dartHotReloadDelayTimer)
            clearTimeout(this.dartHotReloadDelayTimer);
        if (this.flutterHotReloadDelayTimer)
            clearTimeout(this.flutterHotReloadDelayTimer);
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.HotReloadOnSaveHandler = HotReloadOnSaveHandler;


/***/ }),

/***/ 7623:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VsCodeDartToolingDaemon = void 0;
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const tooling_daemon_1 = __webpack_require__(6517);
const tooling_daemon_services_1 = __webpack_require__(5845);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const constants_2 = __webpack_require__(5706);
const status_bar_1 = __webpack_require__(719);
const utils_2 = __webpack_require__(1894);
const debug_1 = __webpack_require__(394);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
class VsCodeDartToolingDaemon extends tooling_daemon_1.DartToolingDaemon {
    statusBarItem = (0, status_bar_1.getLanguageStatusItem)("dart.toolingDaemon", constants_2.ANALYSIS_FILTERS);
    editorServices;
    sendActiveLocationDebounceTimer;
    activeLocationDebounceTimeMs = config_1.config.dtdEditorActiveLocationDelay;
    constructor(context, logger, sdks, deviceManager) {
        super(logger, sdks, config_1.config.maxLogLineLength, processes_1.getToolEnv, (prompt, buttonText, offerLog) => (0, utils_3.promptToReloadExtension)(prompt, buttonText, offerLog, config_1.config.toolingDaemonLogFile));
        context.subscriptions.push(this);
        this.editorServices = new EditorServices(this, deviceManager);
        this.setUpStatusBarAndCommand(context);
        // Subscribe to event + send current/initial folders.
        context.subscriptions.push(vscode_1.workspace.onDidChangeWorkspaceFolders(() => this.sendWorkspaceRootsToDaemon()));
        this.sendWorkspaceRootsToDaemon();
        // Handle sending the current active location.
        context.subscriptions.push(vscode_1.window.onDidChangeActiveTextEditor((e) => this.queueActiveLocationChange(e)));
        context.subscriptions.push(vscode_1.window.onDidChangeTextEditorSelection((e) => this.queueActiveLocationChange(e.textEditor)));
        context.subscriptions.push(vscode_1.workspace.onDidChangeTextDocument((e) => {
            // If the active document changed, this is implicitly a location change because
            // the document is different now.
            if (e.document === vscode_1.window.activeTextEditor?.document)
                this.queueActiveLocationChange(vscode_1.window.activeTextEditor);
        }));
        this.queueActiveLocationChange(vscode_1.window.activeTextEditor);
        // Register services that we support.
        void this.connected.then(() => this.registerServices()).catch((e) => logger.error(e));
    }
    setUpStatusBarAndCommand(context) {
        const copyUriCommand = {
            command: "dart.copyDtdUri",
            title: "copy uri",
            tooltip: "Copies the DTD endpoint URI to the clipboard",
        };
        context.subscriptions.push(vscode_1.commands.registerCommand("dart.copyDtdUri", async () => {
            await vscode_1.env.clipboard.writeText((await this.dtdUri) ?? "<dtd not available>");
            const statusBarItem = this.statusBarItem;
            statusBarItem.command = { ...copyUriCommand, title: "copied!" };
            setTimeout(() => statusBarItem.command = copyUriCommand, 1000);
        }));
        const statusBarItem = this.statusBarItem;
        statusBarItem.name = "Dart Tooling Daemon";
        statusBarItem.text = "Dart Tooling Daemon Starting…";
        void this.connected.then((connectionInfo) => {
            if (connectionInfo) {
                void vscode_1.commands.executeCommand("setContext", constants_contexts_1.DTD_AVAILABLE, true);
                statusBarItem.text = "Dart Tooling Daemon";
                statusBarItem.command = copyUriCommand;
            }
        });
    }
    async registerServices() {
        await Promise.all([
            this.editorServices.register(),
        ]);
    }
    handleClose() {
        // If we failed to start up, overwrite the "Starting..." label and provide a restart option.
        const statusBarItem = this.statusBarItem;
        statusBarItem.text = "Dart Tooling Daemon Terminated";
        statusBarItem.command = {
            command: "_dart.reloadExtension",
            title: "restart",
        };
        super.handleClose();
    }
    sendWorkspaceRootsToDaemon() {
        const workspaceFolderRootUris = (0, utils_2.getDartWorkspaceFolders)().map((wf) => wf.uri.toString());
        void this.sendWorkspaceFolders(workspaceFolderRootUris);
    }
    queueActiveLocationChange(editor) {
        // We currently assume we only want this when the preview flag for LSP is enabled.
        if (!config_1.config.previewDtdLspIntegration)
            return;
        if (this.sendActiveLocationDebounceTimer)
            clearTimeout(this.sendActiveLocationDebounceTimer);
        this.sendActiveLocationDebounceTimer = setTimeout(() => this.sendActiveLocationChange(editor), this.activeLocationDebounceTimeMs);
    }
    sendActiveLocationChange(editor) {
        // Usually we only send the change if the editor whose selection changed is still
        // the active editor. However, if the active editor is a "non-editor" (for example an Output pane
        // or embedded Widget Inspector), we will still allow this, to support selection changes triggered
        // by the inspector when the inspector retains focus.
        if (vscode_1.window.activeTextEditor && editor !== vscode_1.window.activeTextEditor) {
            return;
        }
        const document = editor?.document;
        const location = {
            kind: tooling_daemon_services_1.EventKind.activeLocationChanged,
            selections: editor?.selections.map((s) => ({
                active: {
                    character: s.active.character,
                    line: s.active.line,
                },
                anchor: {
                    character: s.anchor.character,
                    line: s.anchor.line,
                },
            })) ?? [],
            textDocument: document ? {
                uri: (0, fs_1.forceWindowsDriveLetterToUppercaseInUriString)(document.uri.toString()),
                version: document.version,
            } : undefined,
        };
        void this.sendActiveLocation(location);
    }
    dispose() {
        void vscode_1.commands.executeCommand("setContext", constants_contexts_1.DTD_AVAILABLE, false);
        super.dispose();
    }
}
exports.VsCodeDartToolingDaemon = VsCodeDartToolingDaemon;
class EditorServices {
    daemon;
    deviceManager;
    disposables = [];
    constructor(daemon, deviceManager) {
        this.daemon = daemon;
        this.deviceManager = deviceManager;
    }
    async register() {
        if (this.deviceManager) {
            this.disposables.push(this.deviceManager.onDeviceAdded(async (device) => {
                const supportedTypes = await this.deviceManager?.getSupportedPlatformsForWorkspace();
                const isSupported = (d) => this.deviceManager?.isSupported(supportedTypes, d) ?? true;
                this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.deviceAdded, device: this.asDtdEditorDevice(device, isSupported(device)) });
            }, this));
            this.disposables.push(this.deviceManager.onDeviceRemoved((deviceId) => {
                this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.deviceRemoved, deviceId });
            }, this));
            this.disposables.push(this.deviceManager.onDeviceChanged(async (device) => {
                const supportedTypes = await this.deviceManager?.getSupportedPlatformsForWorkspace();
                const isSupported = (d) => this.deviceManager?.isSupported(supportedTypes, d) ?? true;
                this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.deviceChanged, device: this.asDtdEditorDevice(device, isSupported(device)) });
            }, this));
            this.disposables.push(this.deviceManager.onCurrentDeviceChanged((device) => {
                this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.deviceSelected, deviceId: device?.id });
            }, this));
        }
        this.disposables.push((0, debug_1.debugSessionStarted)((session) => {
            this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.debugSessionStarted, debugSession: this.asDtdEditorDebugSession(session) });
        }, this));
        this.disposables.push((0, debug_1.debugSessionStopped)((session) => {
            this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.debugSessionStopped, debugSessionId: session.session.id });
        }, this));
        this.disposables.push((0, debug_1.debugSessionChanged)((session) => {
            this.daemon.sendEvent(tooling_daemon_services_1.Stream.Editor, { kind: tooling_daemon_services_1.EventKind.debugSessionChanged, debugSession: this.asDtdEditorDebugSession(session) });
        }, this));
        await Promise.all([
            this.deviceManager
                ? this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "getDevices", undefined, async () => {
                    const supportedTypes = await this.deviceManager?.getSupportedPlatformsForWorkspace();
                    const isSupported = (d) => this.deviceManager?.isSupported(supportedTypes, d) ?? true;
                    return {
                        devices: this.deviceManager?.getDevicesSortedByName().map((d) => this.asDtdEditorDevice(d, isSupported(d))) ?? [],
                        selectedDeviceId: this.deviceManager?.currentDevice?.id,
                        type: "GetDevicesResult",
                    };
                })
                : undefined,
            this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "getDebugSessions", undefined, () => ({
                debugSessions: debug_1.debugSessions.map((d) => this.asDtdEditorDebugSession(d)),
                type: "GetDebugSessionsResult",
            })),
            this.deviceManager
                ? this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "selectDevice", undefined, async (params) => {
                    await this.deviceManager?.selectDeviceById(params.deviceId);
                    return { type: "Success" };
                })
                : undefined,
            this.deviceManager
                ? this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "enablePlatformType", undefined, async (params) => {
                    await this.deviceManager?.enablePlatformType(params.platformType);
                    return { type: "Success" };
                })
                : undefined, ,
            this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "hotReload", undefined, async (params) => {
                const session = debug_1.debugSessions.find((s) => s.session.id === params.debugSessionId);
                if (session)
                    await session.session.customRequest("hotReload", { reason: constants_1.restartReasonManual });
                return { type: "Success" };
            }),
            this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "hotRestart", undefined, async (params) => {
                const session = debug_1.debugSessions.find((s) => s.session.id === params.debugSessionId);
                if (session)
                    await session.session.customRequest("hotRestart", { reason: constants_1.restartReasonManual });
                return { type: "Success" };
            }),
            this.daemon.registerService(tooling_daemon_services_1.Service.Editor, "openDevToolsPage", {
                supportsForceExternal: true,
            }, async (params) => {
                const location = params.forceExternal ? "external" : undefined;
                await vscode_1.commands.executeCommand("dart.openDevTools", {
                    commandSource: constants_1.CommandSource.dtdServiceRequest,
                    debugSessionId: params.debugSessionId,
                    location,
                    pageId: params.page,
                    prefersDebugSession: params.prefersDebugSession,
                    requiresDebugSession: params.requiresDebugSession,
                });
                return { type: "Success" };
            }),
        ]);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
    asDtdEditorDevice(device, supported) {
        return {
            category: (0, utils_1.nullToUndefined)(device.category),
            emulator: !!device.emulator,
            emulatorId: (0, utils_1.nullToUndefined)(device.emulatorId),
            ephemeral: !!device.ephemeral,
            id: device.id,
            name: this.deviceManager?.friendlyNameForDevice(device) ?? device.name,
            platform: device.platform,
            platformType: (0, utils_1.nullToUndefined)(device.platformType),
            rawDeviceName: device.name,
            supported,
        };
    }
    asDtdEditorDebugSession(session) {
        return {
            debuggerType: enums_1.DebuggerType[session.debuggerType],
            flutterDeviceId: session.flutterDeviceId,
            flutterMode: session.flutterMode,
            id: session.session.id,
            name: session.session.name,
            projectRootPath: session.projectRootPath,
            vmServiceUri: session.vmServiceUri,
        };
    }
}


/***/ }),

/***/ 4283:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosingLabelsDecorations = exports.validLastCharacters = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
const utils_2 = __webpack_require__(279);
exports.validLastCharacters = [")", "]"];
class ClosingLabelsDecorations {
    analyzer;
    subscriptions = [];
    activeEditor;
    closingLabels;
    decorationType;
    closingLabelsPrefix;
    buildDecorationType() {
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                fontStyle: config_1.config.closingLabelsTextStyle,
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
    }
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.closingLabelsPrefix = config_1.config.closingLabelsPrefix;
        this.buildDecorationType();
        this.subscriptions.push(this.analyzer.registerForAnalysisClosingLabels((n) => {
            if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.closingLabels = n;
                this.update();
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        this.subscriptions.push(vs.workspace.onDidChangeConfiguration((e) => {
            let needsUpdate = false;
            if (e.affectsConfiguration("dart.closingLabelsPrefix")) {
                needsUpdate = true;
                this.closingLabelsPrefix = config_1.config.closingLabelsPrefix;
            }
            if (e.affectsConfiguration("dart.closingLabels") || e.affectsConfiguration("dart.closingLabelsTextStyle")) {
                needsUpdate = true;
                this.decorationType.dispose();
                this.buildDecorationType();
            }
            if (needsUpdate) {
                this.update();
            }
        }));
        if (vs.window.activeTextEditor)
            this.setTrackingFile(vs.window.activeTextEditor);
    }
    update() {
        if (!this.closingLabels || !this.activeEditor || this.closingLabels.file !== (0, fs_1.fsPath)(this.activeEditor.document.uri))
            return;
        const decorations = [];
        for (const r of this.closingLabels.labels) {
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = this.activeEditor.document.positionAt(r.offset + r.length);
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = this.activeEditor.document.getText(finalCharacterRange);
            if (!exports.validLastCharacters.includes(finalCharacterText))
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = this.activeEditor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = this.closingLabelsPrefix + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(this.activeEditor.document.positionAt(r.offset), endOfLine),
                    renderOptions: { after: { contentText: this.closingLabelsPrefix + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.activeEditor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    setTrackingFile(editor) {
        if (!editor || !(0, utils_2.isAnalyzable)(editor.document))
            return;
        if (editor !== this.activeEditor)
            this.activeEditor?.setDecorations(this.decorationType, []);
        if (editor) {
            this.activeEditor = editor;
            this.closingLabels = undefined;
            this.analyzer.forceNotificationsFor((0, fs_1.fsPath)(editor.document.uri));
        }
        else {
            this.activeEditor = undefined;
            this.closingLabels = undefined;
        }
    }
    dispose() {
        this.activeEditor?.setDecorations(this.decorationType, []);
        this.activeEditor = undefined;
        this.decorationType.dispose();
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.ClosingLabelsDecorations = ClosingLabelsDecorations;


/***/ }),

/***/ 8502:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorations = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const extension_utils_1 = __webpack_require__(6584);
const utils_2 = __webpack_require__(279);
class FlutterIconDecorations {
    logger;
    subscriptions = [];
    activeEditor;
    decorationTypes = {};
    constructor(logger) {
        this.logger = logger;
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        setImmediate(() => {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        });
    }
    render(results) {
        if (!this.activeEditor)
            return;
        // Each icon type needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const iconName of Object.keys(results)) {
            if (!this.decorationTypes[iconName])
                this.decorationTypes[iconName] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.parse(extension_utils_1.docsIconPathFormat.replace("$1", iconName)),
                    gutterIconSize: "75%",
                });
        }
        for (const iconName of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[iconName], results[iconName] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_2.isAnalyzable)(editor.document))
            this.activeEditor = editor;
        else
            this.activeEditor = undefined;
    }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterIconDecorations = FlutterIconDecorations;


/***/ }),

/***/ 7133:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsDas = void 0;
const fs_1 = __webpack_require__(2587);
const icon_range_computer_1 = __webpack_require__(7034);
const flutter_icon_decorations_1 = __webpack_require__(8502);
class FlutterIconDecorationsDas extends flutter_icon_decorations_1.FlutterIconDecorations {
    analyzer;
    computer;
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputer(logger);
        this.subscriptions.push(this.analyzer.client.registerForFlutterOutline(async (n) => {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === n.file) {
                this.update(n.outline);
            }
        }));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(this.activeEditor.document, outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsDas = FlutterIconDecorationsDas;


/***/ }),

/***/ 5286:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsLsp = void 0;
const vs = __importStar(__webpack_require__(1398));
const fs_1 = __webpack_require__(2587);
const icon_range_computer_1 = __webpack_require__(7034);
const flutter_icon_decorations_1 = __webpack_require__(8502);
class FlutterIconDecorationsLsp extends flutter_icon_decorations_1.FlutterIconDecorations {
    analyzer;
    computer;
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputerLsp(logger);
        this.subscriptions.push(this.analyzer.fileTracker.onFlutterOutline(async (op) => {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri))) {
                this.update(op.outline);
            }
        }));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsLsp = FlutterIconDecorationsLsp;


/***/ }),

/***/ 2365:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetGuide = exports.FlutterUiGuideDecorations = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const trackers_1 = __webpack_require__(2834);
const config_1 = __webpack_require__(7678);
const nonBreakingSpace = "\xa0";
const verticalLine = "│";
const horizontalLine = "─";
const bottomCorner = "╰";
const middleCorner = "├";
class FlutterUiGuideDecorations {
    disposables = [];
    tracker;
    borderDecoration = vs.window.createTextEditorDecorationType({
        rangeBehavior: vs.DecorationRangeBehavior.OpenOpen,
    });
    constructor() {
        // Update any editor that becomes active.
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.buildForTextEditor(e)));
        if (config_1.config.previewFlutterUiGuidesCustomTracking) {
            this.tracker = new WidgetGuideTracker();
            this.disposables.push(this.tracker);
            // Subscribe to updates from the tracker so we can update on keypress without
            // waiting for new Outlines.
            this.tracker.onGuidesChanged(([doc, guides]) => this.buildFromUpdatedGuides(doc, guides));
        }
        // Update the current visible editor when we were registered.
        setImmediate(() => this.buildForTextEditor(vs.window.activeTextEditor));
    }
    buildFromUpdatedGuides(doc, guides) {
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document === doc)
            this.renderGuides(vs.window.activeTextEditor, guides);
    }
    renderGuides(editor, guides) {
        const color = new vs.ThemeColor("dart.flutterUiGuides");
        const guidesByLine = {};
        for (const guide of guides) {
            for (let line = guide.start.line; line <= guide.end.line; line++) {
                guidesByLine[line] = guidesByLine[line] || [];
                guidesByLine[line].push(guide);
            }
        }
        const decorations = this.buildDecorations(editor.document, editor.options.tabSize, guidesByLine, color);
        editor.setDecorations(this.borderDecoration, decorations);
    }
    buildDecorations(doc, tabSize, guidesByLine, color) {
        const decorations = [];
        for (const line of Object.keys(guidesByLine).map((k) => parseInt(k, 10))) {
            const lineInfo = doc.lineAt(line);
            const firstGuideChar = Math.min(...guidesByLine[line].map((g) => Math.min(g.start.character, g.end.character)));
            const lastGuideChar = Math.max(...guidesByLine[line].map((g) => Math.max(g.start.character, g.end.character)));
            const lastLineCharacter = lineInfo.range.end.character;
            const anchorPoint = Math.max(lastLineCharacter < firstGuideChar ? 0 : firstGuideChar, 0);
            const decorationString = new Array(lastGuideChar).fill(nonBreakingSpace);
            for (const guide of guidesByLine[line]) {
                if (line !== guide.end.line) {
                    // Only put a vertical line in if we haven't already o
                    if (decorationString[guide.start.character] === nonBreakingSpace)
                        decorationString[guide.start.character] = verticalLine;
                    else if (decorationString[guide.start.character] === bottomCorner)
                        decorationString[guide.start.character] = middleCorner;
                }
                else {
                    for (let c = guide.start.character; c <= guide.end.character; c++) {
                        if (c === guide.start.character) {
                            decorationString[c] = bottomCorner;
                        }
                        else {
                            decorationString[c] = horizontalLine;
                        }
                    }
                }
            }
            // For any characters that have users text in them, we should not
            // render any guides.
            decorationString.fill(nonBreakingSpace, lineInfo.firstNonWhitespaceCharacterIndex, lineInfo.range.end.character);
            decorationString.splice(0, anchorPoint);
            // For any tabs in the document string, we need to multiply up the characters
            // by the tab width, since everything up to this point is based on the text line
            // character indexes, but rendering needs to obey tab size.
            const tabAdjustedDecorationString = [];
            for (let i = 0; i < decorationString.length; i++) {
                tabAdjustedDecorationString.push(decorationString[i]);
                if (lineInfo.text[anchorPoint + i] === "\t") {
                    const padCharacter = decorationString[i] === horizontalLine || decorationString[i] === bottomCorner || decorationString[i] === middleCorner
                        ? horizontalLine
                        : nonBreakingSpace;
                    for (let c = 0; c < tabSize - 1; c++)
                        tabAdjustedDecorationString.push(padCharacter);
                }
            }
            decorations.push({
                range: new vs.Range(new vs.Position(line, anchorPoint), new vs.Position(line, anchorPoint)),
                renderOptions: {
                    before: {
                        color,
                        contentText: tabAdjustedDecorationString.join(""),
                        fontStyle: "normal",
                        margin: "0 1px 0 -1px",
                        width: "0",
                    },
                },
            });
        }
        return decorations;
    }
    firstNonWhitespace(document, lineNumber) {
        return new vs.Position(lineNumber, document.lineAt(lineNumber).firstNonWhitespaceCharacterIndex);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterUiGuideDecorations = FlutterUiGuideDecorations;
class WidgetGuide {
    start;
    end;
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
exports.WidgetGuide = WidgetGuide;
class WidgetGuideTracker {
    disposables = [];
    tracker = new trackers_1.DocumentPositionTracker();
    guideMap = new Map();
    onGuidesChangedEmitter = new vs.EventEmitter();
    onGuidesChanged = this.onGuidesChangedEmitter.event;
    constructor() {
        this.disposables.push(this.tracker);
        this.tracker.onPositionsChanged(([doc, positions]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newGuides = [];
            for (const guide of this.guideMap.keys()) {
                const data = this.guideMap.get(guide);
                const currentStartPos = data[0];
                const currentEndPos = data[1];
                const newStartPos = positions.get(currentStartPos);
                const newEndPos = positions.get(currentEndPos);
                if (newStartPos && newEndPos)
                    newGuides.push(new WidgetGuide(newStartPos, newEndPos));
            }
            this.onGuidesChangedEmitter.fire([doc, newGuides]);
        });
    }
    clear() {
        this.guideMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, guides) {
        // Stash all guides as tuples containing their positions.
        this.guideMap.clear();
        for (const guide of guides)
            this.guideMap.set(guide, [guide.start, guide.end]);
        // Extract a flat list of positions to track.
        const positions = (0, utils_1.flatMap)([...this.guideMap.values()], (g) => [g[0], g[1]]);
        this.tracker.trackDoc(document, positions);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}


/***/ }),

/***/ 8970:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsDas = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const flutter_ui_guides_decorations_1 = __webpack_require__(2365);
class FlutterUiGuideDecorationsDas extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    analyzer;
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.client.registerForFlutterOutline((on) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === on.file)
                this.buildFromOutline(editor, on.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        if (editor.document.getText().length !== outline.length)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = document.positionAt(node.offset).line;
            const childLines = node.children && node.children
                .map((c) => document.positionAt(c.offset).line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsDas = FlutterUiGuideDecorationsDas;


/***/ }),

/***/ 4285:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsLsp = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const flutter_ui_guides_decorations_1 = __webpack_require__(2365);
class FlutterUiGuideDecorationsLsp extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    analyzer;
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.fileTracker.onFlutterOutline((op) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri)))
                this.buildFromOutline(editor, op.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        const outlineLength = editor.document.offsetAt((0, utils_2.lspToPosition)(outline.range.end));
        if (editor.document.getText().length !== outlineLength)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = node.codeRange.start.line;
            const childLines = node.children && node.children
                .map((c) => c.codeRange.start.line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsLsp = FlutterUiGuideDecorationsLsp;


/***/ }),

/***/ 7076:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticReport = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(279);
const log_1 = __webpack_require__(7962);
const processes_1 = __webpack_require__(8141);
class DiagnosticReport {
    logger;
    workspaceContext;
    rebuildLogHeaders;
    disposables = [];
    output = [];
    emptyReporter = (message) => { };
    report = this.emptyReporter;
    constructor(logger, workspaceContext, rebuildLogHeaders) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.rebuildLogHeaders = rebuildLogHeaders;
        this.disposables.push(vs.commands.registerCommand("dart.generateDiagnosticReport", () => this.generateDiagnosticReportWithProgress()));
    }
    async generateDiagnosticReportWithProgress() {
        this.output.length = 0;
        return vs.window.withProgress({
            cancellable: true,
            location: vs.ProgressLocation.Notification,
            title: "Collecting Diagnostic Information",
        }, async (progress, token) => {
            this.report = (message) => progress.report({ message });
            await this.generateDiagnosticReport(progress, token);
            this.report = this.emptyReporter;
        });
    }
    append(message) {
        this.output.push(message.trimEnd());
    }
    async generateDiagnosticReport(progress, token) {
        this.rebuildLogHeaders();
        this.append("**!! ⚠️ PLEASE REVIEW THIS REPORT FOR SENSITIVE INFORMATION BEFORE SHARING ⚠️ !!**");
        try {
            this.append("<details>");
            this.append("<summary><strong>Workspace Environment</strong></summary>");
            this.append(`\`\`\`text\n${(0, log_1.getLogHeader)(true)}\n\`\`\``);
            this.append("</details>");
            if (token.isCancellationRequested)
                return;
            // TODO(dantup): Add summary of SDK search?
            await this.appendDartCommandOutput("dart info", ["info"]);
            if (token.isCancellationRequested)
                return;
            if (this.workspaceContext.hasAnyFlutterProjects) {
                await this.appendFlutterCommandOutput("flutter doctor", ["doctor", "-v"]);
            }
        }
        catch (e) {
            this.append(`Failed to generate log: ${e}`);
        }
        if (token.isCancellationRequested)
            return;
        await (0, utils_2.openLogContents)("md", this.output.join("\n\n"));
    }
    async appendDartCommandOutput(name, args) {
        const dartExecutable = path.join(this.workspaceContext.sdks.dart, constants_1.dartVMPath);
        await this.appendCommandOutput(name, dartExecutable, args);
    }
    async appendFlutterCommandOutput(name, args) {
        const flutterSdkPath = this.workspaceContext.sdks.flutter;
        if (!flutterSdkPath)
            return;
        const flutterExecutable = path.join(flutterSdkPath, constants_1.flutterPath);
        await this.appendCommandOutput(name, flutterExecutable, args, { prefix: "```text\n", suffix: "\n```" });
    }
    async appendCommandOutput(name, executable, args, { prefix, suffix } = {}) {
        prefix ??= "";
        suffix ??= "";
        const workspaceUri = vs.workspace.workspaceFolders?.find((wf) => wf.uri.scheme === "file")?.uri;
        const workingDirectory = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
        this.report(`${name}…`);
        this.append("<details>");
        this.append(`<summary><strong>Output from '${name}'</strong></summary>`);
        this.append(`\`${executable} ${args.join(" ")}\``);
        const results = await (0, processes_1.runToolProcess)(this.logger, workingDirectory, executable, args);
        if (!results.exitCode) {
            this.append(`${prefix}${results.stdout.trim()}${suffix}`);
        }
        else {
            this.append(`
**Failed to run ${name} (exit code ${results.exitCode}):**

#### STDOUT
\`\`\`text
${results.stdout.trim()}
\`\`\`

#### STDERR
\`\`\`text
${results.stderr.trim()}
\`\`\`
			`.trim());
        }
        this.append("</details>");
        this.report(undefined);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DiagnosticReport = DiagnosticReport;


/***/ }),

/***/ 9451:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isDartDocument = isDartDocument;
exports.getActiveDartEditor = getActiveDartEditor;
exports.getActiveRealFileEditor = getActiveRealFileEditor;
const vs = __importStar(__webpack_require__(1398));
function isDartDocument(document) {
    return document && document.languageId === "dart";
}
function getActiveDartEditor() {
    const editor = vs.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "dart")
        return undefined;
    return editor;
}
/// Gets the "active" file:// TextEditor, excluding any output: panes that
/// might be in the list.
function getActiveRealFileEditor() {
    let editor = vs.window.activeTextEditor;
    // It's possible the "active editor" is actually an Output pane, so
    // try falling back to a single visible (file-scheme) editor if there is one.
    if (editor?.document.uri.scheme !== "file") {
        const fileEditors = vs.window.visibleTextEditors.filter((e) => e.document.uri.scheme === "file");
        if (fileEditors.length === 1) {
            console.log(`Falling back from ${editor?.document.uri} to ${fileEditors[0].document.uri}`);
            editor = fileEditors[0];
        }
    }
    return editor?.document.uri.scheme === "file"
        ? editor
        : undefined;
}


/***/ }),

/***/ 6442:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExperiments = getExperiments;
const fs_1 = __webpack_require__(2587);
// Used for testing. DO NOT COMMIT AS TRUE.
const clearAllExperiments = false;
function getExperiments(logger, workspaceContext, context) {
    return {
        // example: new ExampleExperiment(logger, workspaceContext, context),
        dartSdkDaps: new SdkDapExperiment(logger, workspaceContext, context, 100), // TODO(dantup): Remove when happy we don't need to reduce.
        flutterSdkDaps: new SdkDapExperiment(logger, workspaceContext, context, 100),
        flutterSdkDapsLegacy: new SdkDapExperiment(logger, workspaceContext, context, 10), // DO NOT CHANGE LEGACY.
    };
}
// class ExampleExperiment extends Experiment {
// 	constructor(logger: Logger, workspaceContext: WorkspaceContext, context: Context) {
// 		super(logger, workspaceContext, context, "example", 10);
// 	}
// }
class Experiment {
    logger;
    workspaceContext;
    context;
    id;
    currentPercent;
    randomNumber;
    constructor(logger, workspaceContext, context, id, currentPercent) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.context = context;
        this.id = id;
        this.currentPercent = currentPercent;
        // If this is the first time we've seen this experiment, generate a random number
        // from 1-100.
        const contextKey = `experiment-${id}`;
        const contextHasActivatedKey = `${contextKey}-hasActivated`;
        if (clearAllExperiments) {
            context.update(contextKey, undefined);
            context.update(contextHasActivatedKey, undefined);
        }
        this.randomNumber = context.get(contextKey);
        if (!this.randomNumber) {
            this.randomNumber = (0, fs_1.getRandomInt)(1, 100);
            context.update(contextKey, this.randomNumber);
            logger.info(`Generated random number ${this.randomNumber} for new experiment '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        else {
            logger.info(`Experiment random number is ${this.randomNumber} for experiment '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        if (this.applies) {
            const isFirst = !context.get(contextHasActivatedKey);
            context.update(contextHasActivatedKey, true);
            logger.info(`Experiment '${id}' is activating (${isFirst ? "first time" : "not first time"})`);
            void this.activate(isFirst)
                // Activate is allowed to return false if it skipped activating (eg. not relevant) so
                // first activation can re-run in future.
                .then((v) => {
                if (v === false) {
                    logger.info(`Experiment '${id}' aborted. Clearing hasActivated flag`);
                    context.update(contextHasActivatedKey, undefined);
                }
            });
        }
        else {
            logger.info(`Experiment '${id}' does not apply and will not be activated`);
        }
    }
    get applies() { return this.randomNumber <= this.currentPercent; }
    /// Activates the experiment. If returns false, resets the hasActivated flag so it
    /// is not considered to have run.
    async activate(isFirstActivation) { return; }
}
class SdkDapExperiment extends Experiment {
    constructor(logger, workspaceContext, context, percentEnabled) {
        super(logger, workspaceContext, context, "sdkDaps", percentEnabled);
    }
    get applies() { return super.applies; }
}


/***/ }),

/***/ 291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ringLog = void 0;
exports.activate = activate;
exports.deactivate = deactivate;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const dart_1 = __webpack_require__(6854);
const flutter_1 = __webpack_require__(8997);
const vscode_1 = __webpack_require__(2461);
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const fetch_1 = __webpack_require__(924);
const logging_1 = __webpack_require__(5045);
const api_1 = __webpack_require__(4908);
const symbols_1 = __webpack_require__(2905);
const coordinator_1 = __webpack_require__(5879);
const test_model_1 = __webpack_require__(5871);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const constants_2 = __webpack_require__(5706);
const device_manager_1 = __webpack_require__(1105);
const extension_utils_1 = __webpack_require__(6584);
const uri_handler_1 = __webpack_require__(9499);
const utils_2 = __webpack_require__(1894);
const workspace_1 = __webpack_require__(7946);
const analyzer_das_1 = __webpack_require__(5476);
const analyzer_lsp_1 = __webpack_require__(135);
const analyzer_status_reporter_1 = __webpack_require__(562);
const file_change_handler_1 = __webpack_require__(377);
const file_change_warnings_1 = __webpack_require__(2488);
const analytics_1 = __webpack_require__(5922);
const extension_api_1 = __webpack_require__(1603);
const flutter_dartpad_samples_1 = __webpack_require__(9488);
const flutter_dartpad_samples_lsp_1 = __webpack_require__(6296);
const main_code_lens_provider_1 = __webpack_require__(7520);
const main_code_lens_provider_lsp_1 = __webpack_require__(387);
const test_code_lens_provider_1 = __webpack_require__(3928);
const test_code_lens_provider_lsp_1 = __webpack_require__(7107);
const add_dependency_1 = __webpack_require__(6616);
const add_sdk_to_path_1 = __webpack_require__(439);
const analyzer_1 = __webpack_require__(5591);
const channels_1 = __webpack_require__(269);
const dart_2 = __webpack_require__(5068);
const debug_1 = __webpack_require__(394);
const edit_1 = __webpack_require__(1777);
const edit_das_1 = __webpack_require__(3470);
const edit_lsp_1 = __webpack_require__(8049);
const flutter_2 = __webpack_require__(8787);
const flutter_outline_1 = __webpack_require__(5074);
const go_to_super_1 = __webpack_require__(4243);
const logging_2 = __webpack_require__(6444);
const open_in_other_editors_1 = __webpack_require__(7875);
const packages_1 = __webpack_require__(4644);
const refactor_1 = __webpack_require__(2623);
const sdk_1 = __webpack_require__(7177);
const settings_1 = __webpack_require__(2320);
const test_1 = __webpack_require__(4001);
const type_hierarchy_1 = __webpack_require__(5933);
const config_1 = __webpack_require__(7678);
const dart_task_provider_1 = __webpack_require__(8641);
const hot_reload_save_handler_1 = __webpack_require__(6074);
const tooling_daemon_1 = __webpack_require__(7623);
const closing_labels_decorations_1 = __webpack_require__(4283);
const flutter_icon_decorations_das_1 = __webpack_require__(7133);
const flutter_icon_decorations_lsp_1 = __webpack_require__(5286);
const flutter_ui_guides_decorations_das_1 = __webpack_require__(8970);
const flutter_ui_guides_decorations_lsp_1 = __webpack_require__(4285);
const diagnostic_report_1 = __webpack_require__(7076);
const experiments_1 = __webpack_require__(6442);
const daemon_message_handler_1 = __webpack_require__(5656);
const flutter_daemon_1 = __webpack_require__(6547);
const flutter_outline_view_1 = __webpack_require__(7866);
const flutter_task_provider_1 = __webpack_require__(4261);
const generate_localizations_on_save_handler_1 = __webpack_require__(2338);
const analyzer_status_reporter_2 = __webpack_require__(7431);
const closing_labels_decorations_2 = __webpack_require__(1683);
const go_to_1 = __webpack_require__(7164);
const test_discoverer_1 = __webpack_require__(867);
const add_dependency_code_action_provider_1 = __webpack_require__(4709);
const assist_code_action_provider_1 = __webpack_require__(3895);
const dart_completion_item_provider_1 = __webpack_require__(6541);
const dart_diagnostic_provider_1 = __webpack_require__(7763);
const dart_document_symbol_provider_1 = __webpack_require__(4067);
const dart_folding_provider_1 = __webpack_require__(1890);
const dart_formatting_edit_provider_1 = __webpack_require__(7777);
const dart_highlighting_provider_1 = __webpack_require__(5137);
const dart_hover_provider_1 = __webpack_require__(6755);
const dart_implementation_provider_1 = __webpack_require__(947);
const dart_language_configuration_1 = __webpack_require__(9138);
const dart_reference_provider_1 = __webpack_require__(2294);
const dart_rename_provider_1 = __webpack_require__(3523);
const dart_signature_help_provider_1 = __webpack_require__(3157);
const dart_workspace_symbol_provider_1 = __webpack_require__(3847);
const debug_adapter_descriptor_factory_1 = __webpack_require__(687);
const debug_adapter_forced_ansi_color_support_1 = __webpack_require__(7966);
const debug_adapter_forced_debug_mode_factory_1 = __webpack_require__(2011);
const debug_adapter_forced_single_thread_1 = __webpack_require__(1836);
const debug_adapter_global_evaluation_context_factory_1 = __webpack_require__(8652);
const debug_adapter_hex_view_factory_1 = __webpack_require__(5985);
const debug_adapter_launch_status_factory_1 = __webpack_require__(5196);
const debug_adapter_logger_factory_1 = __webpack_require__(166);
const debug_adapter_remove_error_showUser_factory_1 = __webpack_require__(9154);
const debug_adapter_support_uris_factory_1 = __webpack_require__(5129);
const debug_config_provider_1 = __webpack_require__(4905);
const fix_code_action_provider_1 = __webpack_require__(6807);
const legacy_dart_workspace_symbol_provider_1 = __webpack_require__(4975);
const ranking_code_action_provider_1 = __webpack_require__(9160);
const refactor_code_action_provider_1 = __webpack_require__(6244);
const snippet_completion_item_provider_1 = __webpack_require__(2393);
const source_code_action_provider_1 = __webpack_require__(4565);
const global_1 = __webpack_require__(3107);
const recommendations_1 = __webpack_require__(4241);
const manager_1 = __webpack_require__(4494);
const status_bar_version_tracker_1 = __webpack_require__(2049);
const update_check_1 = __webpack_require__(7663);
const utils_3 = __webpack_require__(7200);
const file_uri_link_provider_1 = __webpack_require__(3295);
const package_uri_link_provider_1 = __webpack_require__(4693);
const vs_test_controller_1 = __webpack_require__(2250);
const user_prompts_1 = __webpack_require__(3411);
const util = __importStar(__webpack_require__(279));
const utils_4 = __webpack_require__(279);
const log_1 = __webpack_require__(7962);
const processes_1 = __webpack_require__(8141);
const sidebar_1 = __webpack_require__(5792);
const property_editor_1 = __webpack_require__(2305);
const sidebar_2 = __webpack_require__(2470);
const packages_view_1 = __webpack_require__(5684);
const packages_view_legacy_1 = __webpack_require__(8028);
let analyzer;
let flutterDaemon;
let deviceManager;
const dartCapabilities = dart_1.DartCapabilities.empty;
const flutterCapabilities = flutter_1.FlutterCapabilities.empty;
let analysisRoots = [];
let analytics;
let showTodos;
let previousSettings;
let experiments;
const loggers = [];
let ringLogger;
const logger = new logging_1.EmittingLogger();
let extensionLog;
// Keep a running in-memory buffer of last 200 log events we can give to the
// user when something crashed even if they don't have disk-logging enabled.
exports.ringLog = new logging_1.RingLog(200);
async function activate(context, isRestart = false) {
    // Ring logger is only set up once and presist over silent restarts.
    if (!ringLogger)
        ringLogger = logger.onLog((message) => exports.ringLog.log(message.toLine(500)));
    if (extension_utils_1.isDevExtension)
        context.subscriptions.push((0, logging_1.logToConsole)(logger));
    void vs.commands.executeCommand("setContext", constants_contexts_1.IS_RUNNING_LOCALLY_CONTEXT, utils_2.isRunningLocally);
    buildLogHeaders();
    if (!extensionLog)
        extensionLog = setupLog((0, log_1.getExtensionLogPath)(), enums_1.LogCategory.General, false);
    const webClient = new fetch_1.WebClient(extension_utils_1.extensionVersion);
    util.logTime("Code called activate");
    // Wire up a reload command that will re-initialise everything.
    context.subscriptions.push(vs.commands.registerCommand("_dart.reloadExtension", async () => {
        logger.info("Performing silent extension reload...");
        await deactivate(true);
        (0, utils_1.disposeAll)(context.subscriptions);
        await activate(context, true);
        logger.info("Done!");
    }));
    showTodos = config_1.config.showTodos;
    previousSettings = getSettingsThatRequireRestart();
    util.logTime();
    analytics = new analytics_1.Analytics(logger);
    const sdkUtils = new utils_3.SdkUtils(logger, context, analytics);
    const workspaceContextUnverified = await sdkUtils.scanWorkspace();
    analytics.workspaceContext = workspaceContextUnverified;
    util.logTime("initWorkspace");
    // Set up log files.
    setupLog(config_1.config.analyzerLogFile, enums_1.LogCategory.Analyzer);
    setupLog(config_1.config.flutterDaemonLogFile, enums_1.LogCategory.FlutterDaemon);
    setupLog(config_1.config.toolingDaemonLogFile, enums_1.LogCategory.DartToolingDaemon);
    setupLog(config_1.config.devToolsLogFile, enums_1.LogCategory.DevTools);
    if (!workspaceContextUnverified.sdks.dart || (workspaceContextUnverified.hasAnyFlutterProjects && !workspaceContextUnverified.sdks.flutter)) {
        // Don't set anything else up; we can't work like this!
        return sdkUtils.handleMissingSdks(workspaceContextUnverified);
    }
    const workspaceContext = workspaceContextUnverified;
    const extContext = workspace_1.Context.for(context, workspaceContext);
    const sdks = workspaceContext.sdks;
    const writableConfig = workspaceContext.config;
    // Record the Flutter SDK path so we can set FLUTTER_ROOT for spawned processes.
    if (workspaceContext.hasAnyFlutterProjects && workspaceContext.sdks.flutter)
        (0, processes_1.setFlutterRoot)(workspaceContext.sdks.flutter);
    (0, processes_1.setupToolEnv)(config_1.config.env);
    void vs.commands.executeCommand("setContext", constants_contexts_1.SDK_IS_PRE_RELEASE, sdks.isPreReleaseSdk);
    const rebuildLogHeaders = () => buildLogHeaders(logger, workspaceContext);
    // Add the PATHs to the Terminal environment so if the user runs commands
    // there they match the versions (and can be resolved, if not already on PATH).
    if (config_1.config.addSdkToTerminalPath) {
        const baseSdk = workspaceContext.hasAnyFlutterProjects
            ? sdks.flutter
            : sdks.dart;
        const envPathPrefix = [baseSdk, "bin", path.delimiter].join(path.sep);
        context.environmentVariableCollection.prepend("PATH", envPathPrefix);
    }
    else {
        // Since the value persists (which we want, so upon reload we don't miss
        // any terminals that were already restored before we activated), we need
        // to explicitly remove the path when the setting is disabled.
        context.environmentVariableCollection.clear();
    }
    // TODO: Move these capabilities into WorkspaceContext.
    if (sdks.dartVersion) {
        dartCapabilities.version = sdks.dartVersion;
        analytics.sdkVersion = sdks.dartVersion;
        void (0, update_check_1.checkForStandardDartSdkUpdates)(logger, workspaceContext);
    }
    if (sdks.flutterVersion) {
        flutterCapabilities.version = sdks.flutterVersion;
        analytics.flutterSdkVersion = sdks.flutterVersion;
        // If we're going to pass the DevTools URL to Flutter, we need to eagerly start it
        // so it's already running.
        if (workspaceContext.hasAnyFlutterProjects && config_1.config.shareDevToolsWithFlutter && flutterCapabilities.supportsDevToolsServerAddress) {
            writableConfig.startDevToolsServerEagerly = true;
        }
    }
    try {
        if (!experiments)
            experiments = (0, experiments_1.getExperiments)(logger, workspaceContext, extContext);
    }
    catch (e) {
        logger.error(e);
    }
    const isVirtualWorkspace = vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.every((f) => f.uri.scheme !== "file");
    function shouldUseLsp() {
        // Never use LSP if the LSP client would reject the current VS Code version or the Dart SDK doesn't support it.
        if (!vscode_1.vsCodeVersion.supportsLatestLspClient || !dartCapabilities.canDefaultLsp)
            return false;
        // If DART_CODE_FORCE_LSP is set to true/false it always overrides.
        if (process.env.DART_CODE_FORCE_LSP === "true")
            return true;
        if (process.env.DART_CODE_FORCE_LSP === "false")
            return false;
        // In virtual workspaces, we always use LSP because it will have non-file resources
        // and we only handle them properly in LSP.
        if (isVirtualWorkspace)
            return true;
        return !(config_1.config.useLegacyAnalyzerProtocol && dartCapabilities.supportsLegacyAnalyzerProtocol);
    }
    const isUsingLsp = shouldUseLsp();
    writableConfig.useLegacyProtocol = !isUsingLsp;
    void vs.commands.executeCommand("setContext", constants_contexts_1.IS_LSP_CONTEXT, isUsingLsp);
    // Build log headers now we know analyzer type.
    rebuildLogHeaders();
    // Show the SDK version in the status bar.
    if (sdks.dartVersion)
        context.subscriptions.push(new status_bar_version_tracker_1.StatusBarVersionTracker(workspaceContext, isUsingLsp));
    if (isVirtualWorkspace && !dartCapabilities.supportsNonFileSchemeWorkspaces) {
        void vs.window.showWarningMessage("Please upgrade to the latest Dart/Flutter SDK to prevent errors in workspaces with virtual folders");
    }
    void vs.commands.executeCommand("setContext", constants_contexts_1.PUB_OUTDATED_SUPPORTED_CONTEXT, dartCapabilities.supportsPubOutdated);
    void vs.commands.executeCommand("setContext", constants_contexts_1.GO_TO_IMPORTS_SUPPORTED_CONTEXT, dartCapabilities.supportsGoToImports);
    void vs.commands.executeCommand("setContext", constants_contexts_1.FLUTTER_SIDEBAR_SUPPORTED_CONTEXT, dartCapabilities.supportsFlutterSidebar);
    // Fire up Flutter daemon if required.
    if (workspaceContext.hasAnyFlutterProjects && sdks.flutter) {
        let runIfNoDevices;
        let hasRunNoDevicesMessage = false;
        let portFromLocalExtension;
        if (workspaceContext.config.forceFlutterWorkspace && workspaceContext.config.restartMacDaemonMessage) {
            runIfNoDevices = () => {
                if (!hasRunNoDevicesMessage) {
                    const instruction = workspaceContext.config.restartMacDaemonMessage;
                    void (0, utils_4.promptToReloadExtension)(`${instruction} (Settings currently expect port: ${config_1.config.daemonPort}.)`, `Reopen this workspace`);
                    hasRunNoDevicesMessage = true;
                }
            };
        }
        if (workspaceContext.config.forceFlutterWorkspace && !utils_2.isRunningLocally) {
            let resultFromLocalExtension = null;
            const command = vs.commands.executeCommand("flutter-local-device-exposer.startDaemon", { script: workspaceContext.config.flutterToolsScript?.script, command: "expose_devices", workingDirectory: workspaceContext.config.flutterSdkHome });
            try {
                resultFromLocalExtension = await (0, utils_1.withTimeout)(command, `The local extension to expose devices timed out. ${workspaceContext.config.localDeviceCommandAdviceMessage ?? ""}`, 10);
            }
            catch (e) {
                // Command won't be available if dartlocaldevice isn't installed.
                logger.error(e);
            }
            if (resultFromLocalExtension !== null) {
                const resultMessage = resultFromLocalExtension.toString();
                const results = resultMessage.match(/Device daemon is available on remote port: (\d+)/i);
                if (results !== null && results?.length > 1) {
                    portFromLocalExtension = parseInt(results[1]);
                }
                else if (resultMessage !== null) {
                    const displayError = `The local extension to expose devices failed: ${resultMessage}. ${workspaceContext.config.localDeviceCommandAdviceMessage ?? ""}`;
                    void vs.window.showErrorMessage(displayError);
                }
            }
        }
        flutterDaemon = new flutter_daemon_1.FlutterDaemon(logger, analytics, workspaceContext, flutterCapabilities, runIfNoDevices, portFromLocalExtension);
        deviceManager = new device_manager_1.FlutterDeviceManager(logger, flutterDaemon, config_1.config, workspaceContext, extContext, runIfNoDevices, portFromLocalExtension);
        context.subscriptions.push(deviceManager);
        context.subscriptions.push(flutterDaemon);
        (0, daemon_message_handler_1.setUpDaemonMessageHandler)(logger, context, flutterDaemon);
        // Exposed for use in user-tasks.
        context.subscriptions.push(vs.commands.registerCommand("flutter.getSelectedDeviceId", () => deviceManager?.currentDevice?.id));
        context.subscriptions.push(vs.commands.registerCommand("flutter.selectDevice", deviceManager.showDevicePicker, deviceManager));
        context.subscriptions.push(vs.commands.registerCommand("flutter.launchEmulator", deviceManager.promptForAndLaunchEmulator, deviceManager));
    }
    // Dart Tooling Daemon.
    const dartToolingDaemon = dartCapabilities.supportsToolingDaemon && !workspaceContext.config.disableDartToolingDaemon
        ? new tooling_daemon_1.VsCodeDartToolingDaemon(context, logger, sdks, deviceManager)
        : undefined;
    if (workspaceContext.config.forceFlutterWorkspace && utils_2.isRunningLocally && constants_1.isMac && workspaceContext.config.localMacWarningMessage) {
        void vs.window.showInformationMessage(workspaceContext.config.localMacWarningMessage.toString());
    }
    context.subscriptions.push(new add_sdk_to_path_1.AddSdkToPathCommands(logger, context, workspaceContext, analytics));
    const pubApi = new api_1.PubApi(webClient);
    const pubGlobal = new global_1.PubGlobal(logger, dartCapabilities, extContext, sdks, pubApi);
    const sdkCommands = new sdk_1.SdkCommands(logger, extContext, workspaceContext, dartCapabilities);
    const dartCommands = new dart_2.DartCommands(logger, extContext, workspaceContext, sdkUtils, pubGlobal, dartCapabilities, analytics);
    const flutterCommands = new flutter_2.FlutterCommands(logger, extContext, workspaceContext, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager, analytics);
    const packageCommands = new packages_1.PackageCommands(logger, extContext, workspaceContext, dartCapabilities);
    const addDependencyCommand = new add_dependency_1.AddDependencyCommand(logger, extContext, workspaceContext, dartCapabilities, pubApi, analytics);
    context.subscriptions.push(sdkCommands);
    context.subscriptions.push(dartCommands);
    context.subscriptions.push(flutterCommands);
    context.subscriptions.push(packageCommands);
    context.subscriptions.push(addDependencyCommand);
    // Handle new projects before creating the analyer to avoid a few issues with
    // showing errors while packages are fetched, plus issues like
    // https://github.com/Dart-Code/Dart-Code/issues/2793 which occur if the analyzer
    // is created too early.
    if (!isRestart)
        await (0, user_prompts_1.handleNewProjects)(logger, extContext);
    // Fire up the analyzer process.
    analyzer = isUsingLsp
        ? new analyzer_lsp_1.LspAnalyzer(logger, sdks, dartCapabilities, workspaceContext, dartToolingDaemon)
        : new analyzer_das_1.DasAnalyzer(logger, analytics, sdks, dartCapabilities, workspaceContext);
    const lspAnalyzer = isUsingLsp ? analyzer : undefined;
    const dasAnalyzer = isUsingLsp ? undefined : analyzer;
    const dasClient = dasAnalyzer ? dasAnalyzer.client : undefined;
    const lspClient = dasClient ? undefined : analyzer.client;
    context.subscriptions.push(analyzer);
    void analyzer.onReady.then(() => {
        if (config_1.config.analyzerVmServicePort) {
            void vs.window.showInformationMessage("The Dart Analysis server is running with the debugger accessible. Unset the dart.analyzerVmServicePort setting when no longer required.");
        }
    });
    // Log analysis server first analysis completion time when it completes.
    let analysisStartTime;
    const analysisCompleteEvents = analyzer.onAnalysisStatusChange((status) => {
        // Analysis started for the first time.
        if (status.isAnalyzing && !analysisStartTime)
            analysisStartTime = new Date();
        // Analysis ends for the first time.
        if (!status.isAnalyzing && analysisStartTime) {
            void analysisCompleteEvents.dispose();
        }
    });
    // Set up providers.
    // TODO: Do we need to push all these to subscriptions?!
    if (lspClient)
        context.subscriptions.push(new closing_labels_decorations_2.LspClosingLabelsDecorations(lspClient));
    const completionItemProvider = isUsingLsp || !dasClient ? undefined : new dart_completion_item_provider_1.DartCompletionItemProvider(logger, dasClient);
    const referenceProvider = isUsingLsp || !dasClient || !dasAnalyzer ? undefined : new dart_reference_provider_1.DartReferenceProvider(dasClient, dasAnalyzer.fileTracker);
    const activeFileFilters = [...constants_2.DART_MODE];
    // Analyze Angular2 templates, requires the angular_analyzer_plugin.
    if (config_1.config.analyzeAngularTemplates) {
        activeFileFilters.push(constants_2.HTML_MODE);
    }
    // Analyze files supported by plugins.
    for (const ext of (0, utils_1.uniq)(config_1.config.additionalAnalyzerFileExtensions)) {
        // We can't check that these don't overlap with the existing language filters
        // because vs.languages.match() won't take an extension, only a TextDocument.
        // So we'll just manually exclude file names we know for sure overlap with them.
        if (ext === "dart" || (config_1.config.analyzeAngularTemplates && (ext === "htm" || ext === "html")))
            continue;
        activeFileFilters.push({ scheme: "file", pattern: `**/*.${ext}` });
    }
    // This is registered with VS Code further down, so it's metadata can be collected from all
    // registered providers.
    const rankingCodeActionProvider = new ranking_code_action_provider_1.RankingCodeActionProvider();
    rankingCodeActionProvider.registerProvider(new add_dependency_code_action_provider_1.AddDependencyCodeActionProvider(constants_2.DART_MODE));
    const triggerCharacters = ".(${'\"/\\".split("");
    if (!isUsingLsp && dasClient) {
        context.subscriptions.push(vs.languages.registerHoverProvider(activeFileFilters, new dart_hover_provider_1.DartHoverProvider(logger, dasClient)));
        const formattingEditProvider = new dart_formatting_edit_provider_1.DartFormattingEditProvider(logger, dasClient, extContext);
        context.subscriptions.push(formattingEditProvider);
        formattingEditProvider.registerDocumentFormatter(activeFileFilters);
        // Only for Dart.
        formattingEditProvider.registerTypingFormatter(constants_2.DART_MODE, "}", ";");
    }
    if (completionItemProvider)
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(activeFileFilters, completionItemProvider, ...triggerCharacters));
    if (referenceProvider) {
        context.subscriptions.push(vs.languages.registerDefinitionProvider(activeFileFilters, referenceProvider));
        context.subscriptions.push(vs.languages.registerReferenceProvider(activeFileFilters, referenceProvider));
    }
    let renameProvider;
    if (!isUsingLsp && dasClient && dasAnalyzer) {
        context.subscriptions.push(vs.languages.registerDocumentHighlightProvider(activeFileFilters, new dart_highlighting_provider_1.DartDocumentHighlightProvider(dasAnalyzer.fileTracker)));
        rankingCodeActionProvider.registerProvider(new assist_code_action_provider_1.AssistCodeActionProvider(logger, activeFileFilters, dasClient));
        rankingCodeActionProvider.registerProvider(new fix_code_action_provider_1.FixCodeActionProvider(logger, activeFileFilters, dasClient));
        rankingCodeActionProvider.registerProvider(new refactor_code_action_provider_1.RefactorCodeActionProvider(activeFileFilters, dasClient));
        renameProvider = new dart_rename_provider_1.DartRenameProvider(dasClient);
        context.subscriptions.push(vs.languages.registerRenameProvider(activeFileFilters, renameProvider));
        // Dart only.
        context.subscriptions.push(vs.languages.registerCodeActionsProvider(constants_2.DART_MODE, new source_code_action_provider_1.SourceCodeActionProvider(), source_code_action_provider_1.SourceCodeActionProvider.metadata));
        context.subscriptions.push(vs.languages.registerImplementationProvider(constants_2.DART_MODE, new dart_implementation_provider_1.DartImplementationProvider(dasAnalyzer)));
        if (config_1.config.showMainCodeLens) {
            const codeLensProvider = new main_code_lens_provider_1.MainCodeLensProvider(logger, dasAnalyzer);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
        if (config_1.config.showTestCodeLens) {
            const codeLensProvider = new test_code_lens_provider_1.TestCodeLensProvider(logger, dasAnalyzer);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
        if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
            const codeLensProvider = new flutter_dartpad_samples_1.FlutterDartPadSamplesCodeLensProvider(logger, dasAnalyzer, sdks);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
    }
    if (isUsingLsp && lspClient && lspAnalyzer) {
        if (config_1.config.showMainCodeLens) {
            const codeLensProvider = new main_code_lens_provider_lsp_1.LspMainCodeLensProvider(logger, lspAnalyzer);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
        if (config_1.config.showTestCodeLens) {
            const codeLensProvider = new test_code_lens_provider_lsp_1.LspTestCodeLensProvider(logger, lspAnalyzer);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
        if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
            const codeLensProvider = new flutter_dartpad_samples_lsp_1.LspFlutterDartPadSamplesCodeLensProvider(logger, lspAnalyzer, sdks);
            context.subscriptions.push(codeLensProvider);
            context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
        }
    }
    const loggingCommands = new logging_2.LoggingCommands(logger, context.logPath);
    context.subscriptions.push(loggingCommands);
    // Register the ranking provider from VS Code now that it has all of its delegates.
    context.subscriptions.push(vs.languages.registerCodeActionsProvider(activeFileFilters, rankingCodeActionProvider, rankingCodeActionProvider.metadata));
    const extensionRecommendations = new recommendations_1.ExtensionRecommentations(analytics, extContext);
    const devTools = new manager_1.DevToolsManager(logger, extContext, analytics, pubGlobal, dartToolingDaemon, dartCapabilities, flutterCapabilities, extensionRecommendations);
    context.subscriptions.push(devTools);
    // Debug commands.
    const debugCommands = new debug_1.DebugCommands(logger, lspAnalyzer?.fileTracker, extContext, workspaceContext, dartCapabilities, flutterCapabilities, devTools, loggingCommands);
    context.subscriptions.push(debugCommands);
    // Task handlers.
    context.subscriptions.push(vs.tasks.registerTaskProvider(dart_task_provider_1.DartTaskProvider.type, new dart_task_provider_1.DartTaskProvider(logger, context, sdks, dartCapabilities)));
    context.subscriptions.push(vs.tasks.registerTaskProvider(flutter_task_provider_1.FlutterTaskProvider.type, new flutter_task_provider_1.FlutterTaskProvider(logger, context, sdks, flutterCapabilities)));
    // Snippets are language-specific
    context.subscriptions.push(vs.languages.registerCompletionItemProvider(constants_2.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider(isUsingLsp, dartCapabilities, "snippets/dart.json", () => true)));
    context.subscriptions.push(vs.languages.registerCompletionItemProvider(constants_2.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider(isUsingLsp, dartCapabilities, "snippets/flutter.json", (uri) => util.isInsideFlutterProject(uri))));
    context.subscriptions.push(vs.languages.setLanguageConfiguration(constants_2.DART_LANGUAGE, new dart_language_configuration_1.DartLanguageConfiguration()));
    // TODO: Push the differences into the Analyzer classes so we can have one reporter.
    if (lspClient)
        // tslint:disable-next-line: no-unused-expression
        new analyzer_status_reporter_2.LspAnalyzerStatusReporter(analyzer);
    if (dasClient)
        // tslint:disable-next-line: no-unused-expression
        new analyzer_status_reporter_1.AnalyzerStatusReporter(logger, dasClient, workspaceContext, analytics);
    context.subscriptions.push(new file_change_warnings_1.FileChangeWarnings());
    context.subscriptions.push(new diagnostic_report_1.DiagnosticReport(logger, workspaceContext, rebuildLogHeaders));
    // Set up diagnostics.
    if (!isUsingLsp && dasClient) {
        const diagnostics = vs.languages.createDiagnosticCollection("dart");
        context.subscriptions.push(diagnostics);
        const diagnosticsProvider = new dart_diagnostic_provider_1.DartDiagnosticProvider(dasClient, diagnostics);
        // TODO: Currently calculating analysis roots requires the version to check if
        // we need the package workaround. In future if we stop supporting server < 1.20.1 we
        // can unwrap this call so that it'll start sooner.
        const serverConnected = dasClient.registerForServerConnected((sc) => {
            serverConnected.dispose();
            if (vs.workspace.workspaceFolders)
                recalculateDasAnalysisRoots();
            // Set up a handler to warn the user if they open a Dart file and we
            // never set up the analyzer
            let hasWarnedAboutLooseDartFiles = false;
            const handleOpenFile = (d) => {
                if (!hasWarnedAboutLooseDartFiles && d.languageId === "dart" && d.uri.scheme === "file" && analysisRoots.length === 0) {
                    hasWarnedAboutLooseDartFiles = true;
                    void vs.window.showWarningMessage("For full Dart language support, please open a folder containing your Dart files instead of individual loose files");
                }
            };
            context.subscriptions.push(vs.workspace.onDidOpenTextDocument((d) => handleOpenFile(d)));
            // Fire for editors already visible at the time this code runs.
            vs.window.visibleTextEditors.forEach((e) => handleOpenFile(e.document));
        });
        // Hook editor changes to send updated contents to analyzer.
        context.subscriptions.push(new file_change_handler_1.FileChangeHandler(dasClient));
    }
    util.logTime("All other stuff before debugger..");
    const testModel = new test_model_1.TestModel(config_1.config, util.isPathInsideFlutterProject);
    const testCoordinator = new coordinator_1.TestSessionCoordinator(logger, testModel, lspAnalyzer?.fileTracker);
    context.subscriptions.push(testCoordinator, vs.debug.onDidReceiveDebugSessionCustomEvent((e) => testCoordinator.handleDebugSessionCustomEvent(e.session.id, e.session.configuration.dartCodeDebugSessionID, e.event, e.body)), vs.debug.onDidTerminateDebugSession((session) => testCoordinator.handleDebugSessionEnd(session.id, session.configuration.dartCodeDebugSessionID)), vs.workspace.onDidChangeConfiguration((e) => testModel.handleConfigChange()));
    const testDiscoverer = lspAnalyzer ? new test_discoverer_1.TestDiscoverer(logger, lspAnalyzer.fileTracker, testModel) : undefined;
    if (testDiscoverer)
        context.subscriptions.push(testDiscoverer);
    const vsCodeTestController = vs.tests?.createTestController !== undefined // Feature-detect for Theia
        ? new vs_test_controller_1.VsCodeTestController(logger, testModel, testDiscoverer)
        : undefined;
    if (vsCodeTestController)
        context.subscriptions.push(vsCodeTestController);
    const analyzerCommands = new analyzer_1.AnalyzerCommands(context, logger, analyzer, analytics);
    // Set up debug stuff.
    const debugProvider = new debug_config_provider_1.DebugConfigProvider(logger, workspaceContext, pubGlobal, testModel, flutterDaemon, deviceManager, devTools, flutterCapabilities);
    context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", debugProvider));
    // Debug trackers
    const globalEvaluationContext = new debug_adapter_global_evaluation_context_factory_1.DartDebugAdapterGlobalEvaluationContextFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", globalEvaluationContext));
    const hexFormatter = new debug_adapter_hex_view_factory_1.DartDebugAdapterHexViewFactory(logger);
    context.subscriptions.push(hexFormatter);
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", hexFormatter));
    const forcedDebugMode = new debug_adapter_forced_debug_mode_factory_1.DartDebugForcedDebugModeFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", forcedDebugMode));
    const forcedAnsiColors = new debug_adapter_forced_ansi_color_support_1.DartDebugForcedAnsiColorSupportFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", forcedAnsiColors));
    const forcedSingleThread = new debug_adapter_forced_single_thread_1.DartDebugForcedSingleThreadFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", forcedSingleThread));
    const removeErrorShowUser = new debug_adapter_remove_error_showUser_factory_1.DartDebugAdapterRemoveErrorShowUserFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", removeErrorShowUser));
    const supportUris = new debug_adapter_support_uris_factory_1.DartDebugAdapterSupportsUrisFactory(dartCapabilities);
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", supportUris));
    const launchStatus = new debug_adapter_launch_status_factory_1.DartDebugAdapterLaunchStatusFactory();
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", launchStatus));
    // Logger goes last, so it logs any mutations made by the above.
    const debugLogger = new debug_adapter_logger_factory_1.DartDebugAdapterLoggerFactory(logger);
    context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", debugLogger));
    const trackerFactories = [globalEvaluationContext, hexFormatter, forcedDebugMode, forcedAnsiColors, forcedSingleThread, removeErrorShowUser, supportUris, launchStatus, debugLogger];
    const debugAdapterDescriptorFactory = new debug_adapter_descriptor_factory_1.DartDebugAdapterDescriptorFactory(analytics, sdks, logger, extContext, dartCapabilities, flutterCapabilities, workspaceContext, experiments);
    context.subscriptions.push(vs.debug.registerDebugAdapterDescriptorFactory("dart", debugAdapterDescriptorFactory));
    // Also the providers for the initial configs.
    if (vs.DebugConfigurationProviderTriggerKind) { // Temporary workaround for GitPod/Theia not having this enum.
        context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.InitialLaunchJsonDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Initial));
        context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.DynamicDebugConfigProvider(logger, deviceManager), vs.DebugConfigurationProviderTriggerKind.Dynamic));
    }
    if (!isUsingLsp && dasClient && dasAnalyzer) {
        if (config_1.config.previewFlutterUiGuides)
            context.subscriptions.push(new flutter_ui_guides_decorations_das_1.FlutterUiGuideDecorationsDas(dasAnalyzer));
        if (config_1.config.flutterGutterIcons)
            context.subscriptions.push(new flutter_icon_decorations_das_1.FlutterIconDecorationsDas(logger, dasAnalyzer));
        // Setup that requires server version/capabilities.
        const connectedSetup = dasClient.registerForServerConnected(async (sc) => {
            connectedSetup.dispose();
            context.subscriptions.push(new refactor_1.RefactorCommands(logger, context, dasClient));
            if (dasClient.capabilities.supportsClosingLabels && config_1.config.closingLabels) {
                context.subscriptions.push(new closing_labels_decorations_1.ClosingLabelsDecorations(dasClient));
            }
            if (dasClient.capabilities.supportsGetDeclerations) {
                context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new dart_workspace_symbol_provider_1.DartWorkspaceSymbolProvider(logger, dasClient, dartCapabilities)));
            }
            else {
                context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new legacy_dart_workspace_symbol_provider_1.LegacyDartWorkspaceSymbolProvider(logger, dasClient)));
            }
            if (dasClient.capabilities.supportsCustomFolding && config_1.config.analysisServerFolding)
                context.subscriptions.push(vs.languages.registerFoldingRangeProvider(activeFileFilters, new dart_folding_provider_1.DartFoldingProvider(dasAnalyzer)));
            if (dasClient.capabilities.supportsGetSignature)
                context.subscriptions.push(vs.languages.registerSignatureHelpProvider(constants_2.DART_MODE, new dart_signature_help_provider_1.DartSignatureHelpProvider(dasClient)));
            const documentSymbolProvider = new dart_document_symbol_provider_1.DartDocumentSymbolProvider(logger, dasAnalyzer.fileTracker);
            activeFileFilters.forEach((filter) => {
                context.subscriptions.push(vs.languages.registerDocumentSymbolProvider(filter, documentSymbolProvider));
            });
            // Set up completions for unimported items.
            if (dasClient.capabilities.supportsAvailableSuggestions && config_1.config.autoImportCompletions) {
                await dasClient.completionSetSubscriptions({
                    subscriptions: ["AVAILABLE_SUGGESTION_SETS"],
                });
            }
        });
    }
    else if (isUsingLsp && lspClient && lspAnalyzer) {
        if (config_1.config.previewFlutterUiGuides)
            context.subscriptions.push(new flutter_ui_guides_decorations_lsp_1.FlutterUiGuideDecorationsLsp(lspAnalyzer));
        if (config_1.config.flutterGutterIcons)
            context.subscriptions.push(new flutter_icon_decorations_lsp_1.FlutterIconDecorationsLsp(logger, lspAnalyzer));
    }
    // Handle config changes so we can reanalyze if necessary.
    context.subscriptions.push(vs.workspace.onDidChangeConfiguration(() => handleConfigurationChange(sdks)));
    // Wire up handling of On-Save handlers.
    context.subscriptions.push(new hot_reload_save_handler_1.HotReloadOnSaveHandler(debugCommands, flutterCapabilities));
    if (workspaceContext.hasAnyFlutterProjects && sdks.flutter) {
        context.subscriptions.push(new generate_localizations_on_save_handler_1.GenerateLocalizationsOnSaveHandler());
    }
    // Register URI handler.
    context.subscriptions.push(vs.window.registerUriHandler(new uri_handler_1.DartUriHandler(flutterCapabilities)));
    context.subscriptions.push(new open_in_other_editors_1.OpenInOtherEditorCommands(logger, sdks));
    context.subscriptions.push(new settings_1.SettingsCommands(logger, workspaceContext));
    context.subscriptions.push(new test_1.TestCommands(logger, testModel, workspaceContext, vsCodeTestController, dartCapabilities, flutterCapabilities));
    if (lspClient && lspAnalyzer) {
        context.subscriptions.push(new go_to_1.LspGoToLocationCommand(lspAnalyzer));
        context.subscriptions.push(new go_to_1.LspGoToSuperCommand(lspAnalyzer));
        context.subscriptions.push(new go_to_1.LspGoToAugmentedCommand(lspAnalyzer));
        context.subscriptions.push(new go_to_1.LspGoToAugmentationCommand(lspAnalyzer));
        context.subscriptions.push(new go_to_1.LspGoToImportsCommand(lspAnalyzer));
    }
    // Set up commands for Dart editors.
    context.subscriptions.push(new edit_1.EditCommands());
    if (dasClient && dasAnalyzer) {
        context.subscriptions.push(new edit_das_1.DasEditCommands(logger, context, dasClient));
        context.subscriptions.push(new type_hierarchy_1.TypeHierarchyCommand(logger, dasClient));
        context.subscriptions.push(new go_to_super_1.GoToSuperCommand(dasAnalyzer));
    }
    else if (lspClient && lspAnalyzer) {
        context.subscriptions.push(new edit_lsp_1.LspEditCommands(lspAnalyzer));
    }
    const packageLinkProvider = new package_uri_link_provider_1.DartPackageUriLinkProvider(logger, workspaceContext);
    const fileLinkProvider = new file_uri_link_provider_1.DartFileUriLinkProvider();
    if (vs.window.registerTerminalLinkProvider) { // Workaround for GitPod/Theia not having this.
        context.subscriptions.push(vs.window.registerTerminalLinkProvider(packageLinkProvider));
        context.subscriptions.push(vs.window.registerTerminalLinkProvider(fileLinkProvider));
    }
    if (vs.languages.registerDocumentLinkProvider) {
        vs.languages.registerDocumentLinkProvider({ scheme: "vscode-test-data" }, packageLinkProvider);
        vs.languages.registerDocumentLinkProvider({ scheme: "vscode-test-data" }, fileLinkProvider);
    }
    // Register our view providers.
    const dartPackagesProvider = dartCapabilities.supportsPubDepsJson
        ? new packages_view_1.DartPackagesProvider(logger, workspaceContext, dartCapabilities)
        : new packages_view_legacy_1.DartPackagesProviderLegacy(logger, workspaceContext, dartCapabilities);
    context.subscriptions.push(dartPackagesProvider);
    const packagesTreeView = vs.window.createTreeView("dartDependencyTree", { treeDataProvider: dartPackagesProvider });
    context.subscriptions.push(packagesTreeView);
    let flutterOutlineTreeProvider;
    if (config_1.config.flutterOutline) {
        // TODO: Extract this out - it's become messy since TreeView was added in.
        flutterOutlineTreeProvider = dasAnalyzer ? new flutter_outline_view_1.DasFlutterOutlineProvider(analytics, dasAnalyzer) : new flutter_outline_view_1.LspFlutterOutlineProvider(analytics, lspAnalyzer);
        const tree = vs.window.createTreeView("dartFlutterOutline", { treeDataProvider: flutterOutlineTreeProvider, showCollapseAll: true });
        tree.onDidChangeSelection(async (e) => {
            if (!flutterOutlineTreeProvider.isSelectingBecauseOfEditor)
                analytics.logFlutterOutlineActivated();
            // TODO: This should be in a tree, not the data provider.
            await flutterOutlineTreeProvider.handleSelection(e.selection);
        });
        context.subscriptions.push(vs.window.onDidChangeTextEditorSelection(async (e) => {
            if (e.selections && e.selections.length) {
                const node = flutterOutlineTreeProvider.getNodeAt(e.textEditor.document.uri, e.selections[0].start);
                if (node && tree.visible) {
                    flutterOutlineTreeProvider.isSelectingBecauseOfEditor = true;
                    await tree.reveal(node, { select: true, focus: false, expand: true });
                    flutterOutlineTreeProvider.isSelectingBecauseOfEditor = false;
                }
            }
        }));
        context.subscriptions.push(tree);
        context.subscriptions.push(flutterOutlineTreeProvider);
        // TODO: This doesn't work for LSP!
        const flutterOutlineCommands = new flutter_outline_1.FlutterOutlineCommands(tree, context);
    }
    if (dartToolingDaemon && dartCapabilities.supportsDevToolsDtdSidebar)
        context.subscriptions.push(new sidebar_2.FlutterDtdSidebar(devTools, dartCapabilities));
    else
        context.subscriptions.push(new sidebar_1.FlutterPostMessageSidebar(devTools, deviceManager, dartCapabilities));
    // When switching from config to capability, also update package.json "when" condition for the view
    // and implement the Context flag
    // (see "_whenForFutureWhenSwitchFromExperimentalFlagToCapabilities" and "FLUTTER_SIDEBAR_SUPPORTED_CONTEXT").
    if (dartToolingDaemon /* && dartCapabilities.supportsPropertyEditor */ && config_1.config.experimentalPropertyEditor)
        context.subscriptions.push(new property_editor_1.PropertyEditor(devTools, dartCapabilities));
    context.subscriptions.push(vs.commands.registerCommand("dart.package.openFile", (filePath) => {
        if (!filePath)
            return;
        vs.workspace.openTextDocument(filePath).then((document) => {
            void vs.window.showTextDocument(document, { preview: true });
        }, (error) => logger.error(error));
    }));
    // Warn the user if they've opened a folder with mismatched casing.
    if (vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length) {
        for (const wf of vs.workspace.workspaceFolders) {
            if ((0, utils_2.warnIfPathCaseMismatch)(logger, (0, fs_1.fsPath)(wf.uri), "the open workspace folder", "re-open the folder using the File Open dialog"))
                break;
        }
    }
    // Prompt user for any special config we might want to set.
    if (!isRestart)
        void (0, user_prompts_1.showUserPrompts)(logger, extContext, webClient, analytics, workspaceContext, dartCapabilities, extensionRecommendations);
    // Turn on all the commands.
    setCommandVisiblity(true, workspaceContext);
    void vs.commands.executeCommand("setContext", constants_contexts_1.DART_PLATFORM_NAME, constants_1.dartPlatformName);
    // Prompt for pub get/upgrade if required
    function checkForPackages() {
        // Don't prompt for package updates in the Fuchsia tree/Dart SDK repo.
        if (workspaceContext.config.disableAutomaticPub)
            return;
        void packageCommands.fetchPackagesOrPrompt(undefined, { alwaysPrompt: true, upgradeOnSdkChange: true });
    }
    checkForPackages();
    // Begin activating dependant packages.
    if (workspaceContext.shouldLoadFlutterExtension) {
        const flutterExtension = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
        if (flutterExtension) {
            logger.info(`Activating Flutter extension for ${workspaceContext.workspaceTypeDescription} project...`);
            // Do NOT await this.. the Flutter extension needs to wait for the Dart extension to finish activating
            // so that it can call its exported API, therefore we'll deadlock if we wait for the Flutter extension
            // to finish activating.
            void flutterExtension.activate()
                // Then rebuild log because it includes whether we activated Flutter.
                .then(() => rebuildLogHeaders());
        }
    }
    if (isRestart) {
        analytics.logExtensionRestart();
    }
    else {
        analytics.logExtensionActivated();
    }
    // Handle changes to the workspace.
    // Set the roots, handling project changes that might affect SDKs.
    context.subscriptions.push(vs.workspace.onDidChangeWorkspaceFolders(async (f) => {
        // First check if something changed that will affect our SDK, in which case
        // we'll perform a silent restart so that we do new SDK searches.
        const newWorkspaceContext = await sdkUtils.scanWorkspace();
        if (newWorkspaceContext.hasAnyFlutterProjects !== workspaceContext.hasAnyFlutterProjects
            || newWorkspaceContext.hasProjectsInFuchsiaTree !== workspaceContext.hasProjectsInFuchsiaTree) {
            void util.promptToReloadExtension();
            return;
        }
        workspaceContext.events.onPackageMapChange.fire();
        if (!isUsingLsp)
            recalculateDasAnalysisRoots();
        checkForPackages();
    }));
    context.subscriptions.push((0, utils_2.createWatcher)("**/.packages", workspaceContext.events.onPackageMapChange));
    context.subscriptions.push((0, utils_2.createWatcher)("**/.dart_tool/package_config.json", workspaceContext.events.onPackageMapChange));
    workspaceContext.events.onPackageMapChange.fire();
    // TODO(dantup): We should only expose the private API required for testing when in test runs, however
    //  some extensions are currently using this for access to the analyzer. We should provide a replacement
    //  before removing this to avoid breaking them.
    // if (!isDartCodeTestRun) {
    // 	return new DartExtensionApi();
    // } else {
    const privateApi = {
        addDependencyCommand,
        analyzer,
        analyzerCapabilities: dasClient && dasClient.capabilities,
        cancelAllAnalysisRequests: () => dasClient && dasClient.cancelAllRequests(),
        completionItemProvider,
        context: extContext,
        currentAnalysis: () => analyzer.onCurrentAnalysisComplete,
        daemonCapabilities: flutterDaemon ? flutterDaemon.capabilities : flutter_1.DaemonCapabilities.empty,
        dartCapabilities,
        debugAdapterDescriptorFactory,
        debugCommands,
        debugProvider,
        debugSessions: debug_1.debugSessions,
        devTools,
        deviceManager,
        envUtils: utils_2.envUtils,
        fileTracker: dasAnalyzer ? dasAnalyzer.fileTracker : (lspAnalyzer ? lspAnalyzer.fileTracker : undefined),
        flutterCapabilities,
        flutterOutlineTreeProvider,
        get isInImplementationFileThatCanHaveTest() { return test_1.isInImplementationFileThatCanHaveTest; },
        get isInTestFileThatHasImplementation() { return test_1.isInTestFileThatHasImplementation; },
        getLogHeader: log_1.getLogHeader,
        getOutputChannel: channels_1.getOutputChannel,
        getToolEnv: processes_1.getToolEnv,
        initialAnalysis: analyzer.onInitialAnalysis,
        interactiveRefactors: lspAnalyzer?.refactors,
        isLsp: isUsingLsp,
        logger,
        nextAnalysis: () => analyzer.onNextAnalysisComplete,
        packagesTreeProvider: dartPackagesProvider,
        pubGlobal,
        renameProvider,
        safeToolSpawn: processes_1.safeToolSpawn,
        testController: vsCodeTestController,
        testCoordinator,
        testDiscoverer,
        testModel,
        toolingDaemon: constants_1.isDartCodeTestRun ? dartToolingDaemon : undefined,
        trackerFactories,
        webClient,
        workspaceContext,
    };
    return {
        ...new extension_api_1.DartExtensionApi(),
        [symbols_1.internalApiSymbol]: Object.assign(privateApi, constants_1.isDartCodeTestRun ? { sdkUtils } : {}),
    };
    // }
}
function setupLog(logFile, category, autoDispose = true) {
    if (logFile) {
        const fileLogger = (0, logging_1.captureLogs)(logger, logFile, (0, log_1.getLogHeader)(), config_1.config.maxLogLineLength, [category]);
        if (autoDispose)
            loggers.push(fileLogger);
        return fileLogger;
    }
}
function buildLogHeaders(logger, workspaceContext) {
    (0, log_1.clearLogHeader)();
    (0, log_1.addToLogHeader)(() => `Dart Code extension: ${extension_utils_1.extensionVersion}`);
    (0, log_1.addToLogHeader)(() => {
        const ext = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
        return `Flutter extension: ${ext.packageJSON.version} (${ext.isActive ? "" : "not "}activated)`;
    });
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `App: ${vs.env.appName}`);
    if (vs.env.appHost)
        (0, log_1.addToLogHeader)(() => `App Host: ${vs.env.appHost}`);
    if (vs.env.remoteName)
        (0, log_1.addToLogHeader)(() => `Remote: ${vs.env.remoteName}`);
    if (utils_2.hostKind)
        (0, log_1.addToLogHeader)(() => `Host Kind: ${utils_2.hostKind}`);
    (0, log_1.addToLogHeader)(() => `Version: ${constants_1.platformDisplayName} ${vs.version}`);
    if (workspaceContext) {
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Workspace type: ${workspaceContext.workspaceTypeDescription} (${workspaceContext.config.useLegacyProtocol ? "DAS" : "LSP"})${vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length > 1 ? " (Multiroot)" : ""}`);
        (0, log_1.addToLogHeader)(() => `Workspace name: ${vs.workspace.name}`);
        const sdks = workspaceContext.sdks;
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Dart (${sdks.dartVersion}): ${sdks.dart}`);
        const deviceInfo = deviceManager?.currentDevice ? `${deviceManager?.currentDevice?.name} (${deviceManager?.currentDevice?.platform}/${deviceManager?.currentDevice?.platformType})` : `No device`;
        (0, log_1.addToLogHeader)(() => `Flutter (${sdks.flutterVersion}): ${sdks.flutter} (${deviceInfo})`);
    }
    (0, log_1.addToLogHeader)(() => ``);
    if (process.env.HTTP_PROXY || process.env.NO_PROXY)
        (0, log_1.addToLogHeader)(() => `HTTP_PROXY: ${process.env.HTTP_PROXY}, NO_PROXY: ${process.env.NO_PROXY}`);
    // Any time the log headers are rebuilt, we should re-log them.
    logger?.info((0, log_1.getLogHeader)());
}
function recalculateDasAnalysisRoots() {
    const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
    analysisRoots = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
    // Sometimes people open their home directories as the workspace root and
    // have all sorts of performance issues because of PubCache and AppData folders
    // so we will exclude them if the user has opened a parent folder (opening a
    // child of these directly will still work).
    const excludeFolders = [];
    if (constants_1.isWin) {
        const addExcludeIfRequired = (folder) => {
            if (!folder || !path.isAbsolute(folder))
                return;
            const containingRoot = analysisRoots.find((root) => (0, fs_1.isWithinPath)(folder, root));
            if (containingRoot) {
                logger.info(`Excluding folder ${folder} from analysis roots as it is a child of analysis root ${containingRoot} and may cause performance issues.`);
                excludeFolders.push(folder);
            }
        };
        addExcludeIfRequired(process.env.PUB_CACHE);
        addExcludeIfRequired(process.env.APPDATA);
        addExcludeIfRequired(process.env.LOCALAPPDATA);
    }
    // For each workspace, handle excluded folders.
    workspaceFolders.forEach((f) => {
        for (const folder of util.getExcludedFolders(f))
            excludeFolders.push(folder);
    });
    void analyzer.client.analysisSetAnalysisRoots({
        excluded: excludeFolders,
        included: analysisRoots,
    });
}
function handleConfigurationChange(sdks) {
    // TODOs
    const newShowTodoSetting = config_1.config.showTodos;
    const todoSettingChanged = JSON.stringify(showTodos) !== JSON.stringify(newShowTodoSetting);
    showTodos = newShowTodoSetting;
    // SDK
    const newSettings = getSettingsThatRequireRestart();
    const settingsChanged = previousSettings !== newSettings;
    previousSettings = newSettings;
    if (todoSettingChanged && analyzer instanceof analyzer_das_1.DasAnalyzer) {
        void analyzer.client.analysisReanalyze();
    }
    if (settingsChanged) {
        // Delay the restart slightly, because the config change may be transmitted to the LSP server
        // and shutting the server down too quickly results in that trying to write to a closed
        // stream.
        setTimeout(util.promptToReloadExtension, 50);
    }
}
function getSettingsThatRequireRestart() {
    // The return value here is used to detect when any config option changes that requires a project reload.
    // It doesn't matter how these are combined; it just gets called on every config change and compared.
    // Usually these are options that affect the analyzer and need a reload, but config options used at
    // activation time will also need to be included.
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return "CONF-"
        + config_1.config.sdkPath
        + config_1.config.sdkPaths?.length
        + config_1.config.analyzerPath
        + config_1.config.analyzerDiagnosticsPort
        + config_1.config.analyzerVmServicePort
        + config_1.config.analyzerInstrumentationLogFile
        + config_1.config.extensionLogFile
        + config_1.config.analyzerAdditionalArgs?.join(",")
        + config_1.config.analyzerVmAdditionalArgs?.join(",")
        + config_1.config.flutterSdkPath
        + config_1.config.flutterSdkPaths?.length
        + config_1.config.flutterSelectDeviceWhenConnected
        + config_1.config.closingLabels
        + config_1.config.analyzeAngularTemplates
        + config_1.config.analysisServerFolding
        + config_1.config.showMainCodeLens
        + config_1.config.showTestCodeLens
        + config_1.config.updateImportsOnRename
        + config_1.config.flutterOutline
        + config_1.config.flutterAdbConnectOnChromeOs;
}
async function deactivate(isRestart = false) {
    logger.info(`Extension deactivate was called (isRestart: ${isRestart})`);
    const loggersToDispose = [...loggers];
    loggers.length = 0;
    await Promise.allSettled([
        tryCleanup(() => setCommandVisiblity(false)),
        tryCleanup(() => analyzer?.dispose()),
        tryCleanup(() => flutterDaemon?.shutdown()),
        tryCleanup(() => vs.commands.executeCommand("setContext", constants_contexts_1.FLUTTER_SUPPORTS_ATTACH, false)),
        ...loggersToDispose.map((l) => tryCleanup(() => l.dispose())),
    ]);
    logger.info(`Extension cleanup done`);
    // Pump for any log events that might need to be written to the loggers.
    await new Promise((resolve) => setTimeout(resolve, 100));
    if (!isRestart) {
        logger.info(`Closing all loggers...`);
        await new Promise((resolve) => setTimeout(resolve, 50));
        await Promise.allSettled([
            tryCleanup(() => logger.dispose()),
            tryCleanup(() => ringLogger?.dispose()),
            tryCleanup(() => extensionLog?.dispose()),
        ]);
        await new Promise((resolve) => setTimeout(resolve, 50));
    }
    else {
        logger.info(`Restarting...`);
        await new Promise((resolve) => setTimeout(resolve, 300));
    }
}
function setCommandVisiblity(enable, workspaceContext) {
    void vs.commands.executeCommand("setContext", constants_contexts_1.PROJECT_LOADED, enable);
    void vs.commands.executeCommand("setContext", constants_contexts_1.DART_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyStandardDartProjects);
    void vs.commands.executeCommand("setContext", constants_contexts_1.FLUTTER_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterProjects);
    void vs.commands.executeCommand("setContext", constants_contexts_1.WEB_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyWebProjects);
}
/// Calls a cleanup function in a try/catch to ensure we never throw and logs any error to the logger
/// and the console.
async function tryCleanup(f) {
    try {
        await f();
    }
    catch (e) {
        try {
            console.error(`Error cleaning up during extension shutdown: ${e}`);
            logger.error(`Error cleaning up during extension shutdown: ${e}`);
        }
        catch { }
    }
}


/***/ }),

/***/ 5656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setUpDaemonMessageHandler = setUpDaemonMessageHandler;
const vscode_1 = __webpack_require__(1398);
const channels_1 = __webpack_require__(269);
function setUpDaemonMessageHandler(logger, context, daemon) {
    function showShouldOutput(log) {
        const isError = "error" in log ? log.error : log.level === "error";
        if (!isError)
            return false;
        const message = "error" in log ? log.log : log.message;
        // The daemon reports lots of errors during normal operation, so we only
        // show the error for some specific known things.
        const knownErrorStrings = [
            "Android emulator stderr",
            "Address these issues and try again",
            "requires hardware acceleration",
            // If we ever need to add to this list, consider updating Flutter to pass
            // some flag to separate errors that should be shown to users from those
            // that are normal (for example adb errors are printed normally during
            // a device connection).
        ];
        return !!knownErrorStrings.find((s) => message.includes(s));
    }
    const channel = (0, channels_1.getOutputChannel)("flutter daemon", true);
    context.subscriptions.push(daemon.registerForDaemonLog((l) => {
        if (showShouldOutput(l))
            channel.show(true);
        const prefix = l.error ? "[ERR] " : "";
        channel.appendLine(`${prefix}${l.log}`);
    }));
    context.subscriptions.push(daemon.registerForDaemonLogMessage((l) => {
        if (showShouldOutput(l))
            channel.show(true);
        const prefix = l.level === "error"
            ? "[ERR] "
            : l.level === "warning"
                ? "[WARN]" : "";
        channel.appendLine(`${prefix}${l.message}`);
    }));
    context.subscriptions.push(daemon.registerForDaemonShowMessage((l) => {
        const title = l.title.trim().endsWith(".") ? l.title.trim() : `${l.title.trim()}.`;
        const message = `${title} ${l.message}`.trim();
        switch (l.level) {
            case "info":
                void vscode_1.window.showInformationMessage(message);
                break;
            case "warning":
                void vscode_1.window.showWarningMessage(message);
                break;
            case "error":
                void vscode_1.window.showErrorMessage(message);
                break;
            default:
                logger.warn(`Unexpected daemon.showMessage type: ${l.level}`);
        }
    }));
}


/***/ }),

/***/ 6547:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDaemon = void 0;
const child_process = __importStar(__webpack_require__(5317));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const flutter_1 = __webpack_require__(8997);
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const stdio_service_1 = __webpack_require__(7724);
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
const misc_1 = __webpack_require__(1166);
const processes_1 = __webpack_require__(8141);
class FlutterDaemon extends stdio_service_1.StdIOService {
    analytics;
    workspaceContext;
    runIfNoDevices;
    hasStarted = false;
    hasShownTerminatedError = false;
    hasLoggedDaemonTimeout = false;
    isShuttingDown = false;
    startupReporter;
    daemonStartedCompleter = new utils_1.PromiseCompleter();
    daemonStarted = this.daemonStartedCompleter.promise;
    pingIntervalId;
    capabilities = flutter_1.DaemonCapabilities.empty;
    constructor(logger, analytics, workspaceContext, flutterCapabilities, runIfNoDevices, portFromLocalExtension) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.FlutterDaemon), config_1.config.maxLogLineLength, true, true);
        this.analytics = analytics;
        this.workspaceContext = workspaceContext;
        this.runIfNoDevices = runIfNoDevices;
        const folder = workspaceContext.sdks.flutter;
        this.registerForDaemonConnected((e) => {
            this.additionalPidsToTerminate.push(e.pid);
            this.capabilities.version = e.version;
            void vs.commands.executeCommand("setContext", constants_contexts_1.FLUTTER_SUPPORTS_ATTACH, this.capabilities.canFlutterAttach);
            void this.deviceEnable();
        });
        const daemonArgs = [];
        const showWebServer = config_1.config.flutterShowWebServerDevice === "always" || !utils_2.isRunningLocally;
        if (showWebServer && flutterCapabilities.supportsShowWebServerDevice)
            daemonArgs.push("--show-web-server-device");
        if (constants_1.isDartCodeTestRun)
            daemonArgs.push("--show-test-device");
        if (portFromLocalExtension) {
            this.createNcProcess(portFromLocalExtension);
            this.startPing();
        }
        else if (workspaceContext.config.forceFlutterWorkspace && config_1.config.daemonPort) {
            this.createNcProcess(config_1.config.daemonPort);
            this.startPing(workspaceContext.config.restartMacDaemonMessage);
        }
        else {
            const execution = (0, utils_1.usingCustomScript)(path.join(workspaceContext.sdks.flutter, constants_1.flutterPath), ["daemon"].concat(daemonArgs), workspaceContext.config?.flutterDaemonScript);
            const flutterAdditionalArgs = config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs;
            const args = (0, processes_1.getGlobalFlutterArgs)().concat(flutterAdditionalArgs).concat(execution.args);
            this.createProcess(folder, execution.executable, args, { toolEnv: (0, processes_1.getToolEnv)() });
        }
        if (constants_1.isChromeOS && config_1.config.flutterAdbConnectOnChromeOs) {
            logger.info("Running ADB Connect on Chrome OS");
            const adbConnectProc = (0, processes_1.safeToolSpawn)(undefined, "adb", ["connect", "100.115.92.2:5555"]);
            (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, adbConnectProc);
        }
    }
    startPing(customMessage) {
        const message = customMessage ?? "The daemon connection was lost. Reload the extension to restart the daemon.";
        this.pingIntervalId = setInterval(async () => {
            try {
                await (0, utils_1.withTimeout)(this.daemonVersion(), "The daemon connection was lost", 10);
            }
            catch (e) {
                clearInterval(this.pingIntervalId);
                this.logger.error(e);
                this.hasShownTerminatedError = true;
                void (0, utils_3.promptToReloadExtension)(message);
            }
        }, 60 * 1000);
    }
    // This is for the case where a user has started a flutter daemon process on their local machine where devices are available, and
    // has forwarded this port to the remote machine where the Dart extension is running. Netcat is used to access the local devices,
    // instead of starting another daemon process on the remote machine.
    createNcProcess(port) {
        this.process = child_process.spawn("nc", ["localhost", port.toString()]);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => {
            void vs.window.showErrorMessage(`Remote daemon startup had an error: ${error}. Check the instructions for using dart.daemonPort`);
            this.handleError(error);
        });
    }
    handleExit(code, signal) {
        if (code && !this.isShuttingDown)
            this.handleUncleanExit();
        super.handleExit(code, signal);
    }
    handleUncleanExit() {
        if (this.runIfNoDevices) {
            this.runIfNoDevices();
        }
        else if (!this.hasShownTerminatedError) {
            this.showTerminatedError(this.hasStarted ? "has terminated" : "failed to start");
        }
    }
    notifyRequestAfterExit() {
        this.showTerminatedError("is not running");
    }
    lastShownTerminatedError;
    noRepeatTerminatedErrorThresholdMs = constants_1.tenMinutesInMs;
    showTerminatedError(message) {
        // Don't show this notification if we've shown it recently.
        if (this.lastShownTerminatedError && Date.now() - this.lastShownTerminatedError < this.noRepeatTerminatedErrorThresholdMs)
            return;
        this.lastShownTerminatedError = Date.now();
        // This flag is set here, but checked in handleUncleanExit because explicit calls
        // here can override hasShownTerminationError, for example to show the error when
        // something tries to interact with the API (`notifyRequestAfterExit`).
        this.hasShownTerminatedError = true;
        void (0, utils_3.promptToReloadExtension)(`The Flutter Daemon ${message}.`, undefined, true, config_1.config.flutterDaemonLogFile);
    }
    dispose() {
        this.isShuttingDown = true;
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
        }
        super.dispose();
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            if (!this.hasShownTerminatedError && !this.isShuttingDown) {
                this.hasShownTerminatedError = true;
                void (0, utils_3.promptToReloadExtension)("The Flutter Daemon has terminated.", undefined, true, config_1.config.flutterDaemonLogFile);
                throw e;
            }
        }
    }
    shouldHandleMessage(message) {
        // Everything in flutter is wrapped in [] so we can tell what to handle.
        if (message.startsWith("[{") && message.endsWith("}]")) {
            // When we get the first message to handle, complete the status notifications.
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.daemonStartedCompleter.resolve();
            }
            return true;
        }
        return false;
    }
    static outOfDateWarning = new RegExp("WARNING: .* Flutter is (\\d+) days old");
    static newVersionMessage = "A new version of Flutter is available";
    hasShownStartupError = false;
    async processUnhandledMessage(message) {
        let upgradeMessage;
        const matches = FlutterDaemon.outOfDateWarning.exec(message);
        if (matches && matches.length === 2)
            upgradeMessage = `Your installation of Flutter is ${matches[1]} days old.`;
        else if (message.includes(FlutterDaemon.newVersionMessage))
            upgradeMessage = "A new version of Flutter is available";
        if (upgradeMessage) {
            if (await vs.window.showWarningMessage(upgradeMessage, "Upgrade Flutter"))
                void vs.commands.executeCommand("flutter.upgrade");
            return;
        }
        if (!this.hasShownStartupError && message.startsWith("Flutter requires")) {
            this.logger.error(message, enums_1.LogCategory.FlutterDaemon);
            void vs.window.showErrorMessage(message);
            this.hasShownStartupError = true;
            return;
        }
        // Show as progress message, this is likely "Building flutter tool" or "downloading Dart SDK" messages.
        if ((message.startsWith("Building ") || message.startsWith("Downloading ") || message.startsWith("Starting ") || message.startsWith("Running "))
            && !message.startsWith("Starting device daemon") // Don't show this one as it happens for normal startups too.
        ) {
            if (!this.hasStarted) {
                if (this.startupReporter) {
                    this.startupReporter.report({ message });
                }
                else {
                    void vs.window.withProgress({
                        location: vscode_1.ProgressLocation.Notification,
                        title: "Flutter Setup",
                    }, (progressReporter) => {
                        this.startupReporter = progressReporter;
                        this.startupReporter.report({ message });
                        return this.daemonStartedCompleter.promise;
                    });
                }
            }
        }
    }
    async enablePlatformGlobally(platformType) {
        const flutterSdkPath = this.workspaceContext.sdks.flutter;
        const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
        const args = ["config", `--enable-${platformType}`];
        await (0, processes_1.runToolProcess)(this.logger, flutterSdkPath, binPath, args);
    }
    async checkIfPlatformGloballyDisabled(platformType) {
        const flutterSdkPath = this.workspaceContext.sdks.flutter;
        const value = await (0, misc_1.getFlutterConfigValue)(this.logger, flutterSdkPath, flutterSdkPath, `enable-${platformType}`);
        // Only consider it disabled if it's specifically false (if it's not present, don't assume).
        return value === false;
    }
    // TODO: Can we code-gen all this like the analysis server?
    async handleNotification(evt) {
        switch (evt.event) {
            case "daemon.connected":
                await this.notify(this.daemonConnectedSubscriptions, evt.params);
                break;
            case "device.added":
                await this.notify(this.deviceAddedSubscriptions, evt.params);
                break;
            case "device.removed":
                await this.notify(this.deviceRemovedSubscriptions, evt.params);
                break;
            case "daemon.logMessage":
                await this.notify(this.daemonLogMessageSubscriptions, evt.params);
                break;
            case "daemon.log":
                await this.notify(this.daemonLogSubscriptions, evt.params);
                break;
            case "daemon.showMessage":
                await this.notify(this.daemonShowMessageSubscriptions, evt.params);
                break;
        }
    }
    // Subscription lists.
    daemonConnectedSubscriptions = [];
    deviceAddedSubscriptions = [];
    deviceRemovedSubscriptions = [];
    daemonLogMessageSubscriptions = [];
    daemonLogSubscriptions = [];
    daemonShowMessageSubscriptions = [];
    // Request methods.
    daemonVersion() {
        return this.sendRequest("daemon.version");
    }
    deviceEnable() {
        return this.sendRequest("device.enable");
    }
    getEmulators() {
        return this.withRecordedTimeout(this.sendRequest("emulator.getEmulators"));
    }
    launchEmulator(emulatorId, coldBoot) {
        return this.sendRequest("emulator.launch", { emulatorId, coldBoot });
    }
    createEmulator(name) {
        return this.sendRequest("emulator.create", { name });
    }
    getSupportedPlatforms(projectRoot) {
        return this.withRecordedTimeout(this.sendRequest("daemon.getSupportedPlatforms", { projectRoot }));
    }
    serveDevTools() {
        return this.sendRequest("devtools.serve");
    }
    shutdown() {
        this.isShuttingDown = true;
        return this.hasStarted && !this.hasShownTerminatedError ? this.sendRequest("daemon.shutdown") : new Promise((resolve) => resolve());
    }
    async withRecordedTimeout(promise) {
        // Don't use timeout unless we haven't shown the message before and we know
        // we have fully started up (so we don't false trigger during slow startups
        // caused by SDK upgrades, etc.).
        const recordTimeouts = this.hasStarted && !this.hasLoggedDaemonTimeout && !this.isShuttingDown && !this.processExited;
        if (!recordTimeouts)
            return promise; // Short-cut creating the timer.
        return new Promise((resolve, reject) => {
            // Set a timer to record if the request doesn't respond fast enough.
            const timeoutTimer = setTimeout(() => {
                const recordTimeouts = this.hasStarted && !this.hasLoggedDaemonTimeout && !this.isShuttingDown && !this.processExited;
                if (recordTimeouts) {
                    this.analytics.logErrorFlutterDaemonTimeout();
                    this.hasLoggedDaemonTimeout = true;
                }
            }, constants_1.twentySecondsInMs);
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            promise.then((result) => {
                clearTimeout(timeoutTimer);
                resolve(result);
            }, (e) => {
                clearTimeout(timeoutTimer);
                reject(e);
            });
        });
    }
    // Subscription methods.
    registerForDaemonConnected(subscriber) {
        return this.subscribe(this.daemonConnectedSubscriptions, subscriber);
    }
    registerForDeviceAdded(subscriber) {
        return this.subscribe(this.deviceAddedSubscriptions, subscriber);
    }
    registerForDeviceRemoved(subscriber) {
        return this.subscribe(this.deviceRemovedSubscriptions, subscriber);
    }
    registerForDaemonLogMessage(subscriber) {
        return this.subscribe(this.daemonLogMessageSubscriptions, subscriber);
    }
    registerForDaemonLog(subscriber) {
        return this.subscribe(this.daemonLogSubscriptions, subscriber);
    }
    registerForDaemonShowMessage(subscriber) {
        return this.subscribe(this.daemonShowMessageSubscriptions, subscriber);
    }
}
exports.FlutterDaemon = FlutterDaemon;


/***/ }),

/***/ 7866:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterWidgetItem = exports.LspFlutterOutlineProvider = exports.DasFlutterOutlineProvider = exports.FlutterOutlineProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const extension_utils_1 = __webpack_require__(6584);
const mappings_1 = __webpack_require__(5372);
const utils_2 = __webpack_require__(1894);
const analyzer_das_1 = __webpack_require__(5476);
const flutter_outline_1 = __webpack_require__(5074);
const utils_3 = __webpack_require__(279);
const DART_SHOW_FLUTTER_OUTLINE = "dart-code:showFlutterOutline";
const WIDGET_SELECTED_CONTEXT = "dart-code:isSelectedWidget";
const WIDGET_SUPPORTS_CONTEXT_PREFIX = "dart-code:widgetSupports:";
class FlutterOutlineProvider {
    analytics;
    subscriptions = [];
    activeEditor;
    rootNode;
    treeNodesByLine = [];
    updateTimeout;
    onDidChangeTreeDataEmitter = new vs.EventEmitter();
    onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    lastSelectedWidget;
    isSelectingBecauseOfEditor = false;
    constructor(analytics) {
        this.analytics = analytics;
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_3.isAnalyzable)(editor.document)) {
            this.activeEditor = editor;
            void this.loadExistingOutline();
        }
        else if (editor && editor.document.uri.scheme === "file") {
            // HACK: We can't currently reliably tell when editors are changed that are only real
            // text editors (debug window is considered an editor) so we should only hide the tree
            // when we know a file that is not ours is selected.
            // https://github.com/Microsoft/vscode/issues/45188
            this.activeEditor = undefined;
            FlutterOutlineProvider.hideTree();
        }
        else {
            // HACK: If there are no valid open editors, hide the tree.
            // The timeout is because the open editors disappear briefly during a closing
            // of one preview and opening of another :(
            // https://github.com/Microsoft/vscode/issues/45188.
            setTimeout(() => {
                if (!vs.window.visibleTextEditors.filter((e) => (0, utils_3.isAnalyzable)(e.document)).length) {
                    FlutterOutlineProvider.hideTree();
                }
            }, 100);
        }
    }
    async handleSelection(selection) {
        // Unmark the old node as being selected.
        if (this.lastSelectedWidget) {
            const widget = this.lastSelectedWidget;
            widget.contextValue = undefined;
            // If we refresh immediately, we may cause "actual command not found" for the
            // navigation command.
            setTimeout(() => this.refresh(widget), 200);
        }
        // Clear all contexts that enabled refactors.
        for (const refactor of flutter_outline_1.flutterOutlineCommands) {
            void vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + refactor, false);
        }
        // Set up the new contexts for our node and mark is as current.
        if (this.activeEditor && selection && selection.length === 1 && isWidget(selection[0].outline)) {
            const fixes = (await getFixes(this.activeEditor, selection[0].outline))
                .filter((f) => f instanceof vs.CodeAction)
                .filter((ca) => ca.kind && ca.kind.value && flutter_outline_1.flutterOutlineCommands.includes(ca.kind.value));
            // Stash the fixes, as we may need to call them later.
            selection[0].fixes = fixes;
            for (const fix of fixes)
                void vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + (fix.kind ? fix.kind.value : "NOKIND"), true);
            // Used so we can show context menu if you right-click the selected one.
            // We can't support arbitrary context menus, because we can't get the fixes up-front (see
            // https://github.com/dart-lang/sdk/issues/32462) so we fetch when you select an item
            // and then just support it if it's selected.
            selection[0].contextValue = WIDGET_SELECTED_CONTEXT;
            const widget = this.lastSelectedWidget = selection[0];
            // If we refresh immediately, we may cause "actual command not found" for the
            // navigation command.
            setTimeout(() => this.refresh(widget), 200);
        }
    }
    getNodeAt(uri, pos) {
        if (!this.activeEditor || !this.flutterOutline || (0, fs_1.fsPath)(this.activeEditor.document.uri) !== (0, fs_1.fsPath)(uri) || !this.treeNodesByLine[pos.line])
            return;
        const nodes = this.treeNodesByLine[pos.line];
        // We want the last node that started before the position (eg. most specific).
        let currentBest;
        for (const item of nodes) {
            const range = "range" in item.outline
                ? (0, utils_2.lspToRange)(item.outline.range)
                : (0, utils_2.toRange)(this.activeEditor.document, item.outline.offset, item.outline.length);
            if (range.contains(pos))
                currentBest = item;
        }
        if (currentBest === this.rootNode)
            return undefined; // Root node isn't actually in the tree.
        return currentBest;
    }
    refresh(item) {
        this.onDidChangeTreeDataEmitter.fire(item);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element)
            return element.children;
        if (this.rootNode)
            return this.rootNode.children;
        return [];
    }
    getParent(element) {
        return element.parent;
    }
    static setTreeVisible(visible) {
        void vs.commands.executeCommand("setContext", DART_SHOW_FLUTTER_OUTLINE, visible);
    }
    static showTree() { this.setTreeVisible(true); }
    static hideTree() { this.setTreeVisible(false); }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterOutlineProvider = FlutterOutlineProvider;
class DasFlutterOutlineProvider extends FlutterOutlineProvider {
    analyzer;
    flutterOutline;
    constructor(analytics, analyzer) {
        super(analytics);
        this.analyzer = analyzer;
        this.analyzer.client.registerForServerConnected((c) => {
            if (analyzer.client.capabilities.supportsFlutterOutline) {
                this.analyzer.client.registerForFlutterOutline((n) => {
                    if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                        this.flutterOutline = n.outline;
                        this.treeNodesByLine = [];
                        // Delay this so if we're getting lots of updates we don't flicker.
                        if (this.updateTimeout)
                            clearTimeout(this.updateTimeout);
                        if (!this.rootNode)
                            void this.update();
                        else
                            this.updateTimeout = setTimeout(() => this.update(), 200);
                    }
                });
                this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
                if (vs.window.activeTextEditor) {
                    this.setTrackingFile(vs.window.activeTextEditor);
                }
            }
        });
    }
    async loadExistingOutline() {
        this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
        if (this.flutterOutline)
            await this.update();
        else {
            this.rootNode = undefined;
            this.refresh(); // Force update (to nothing) while requests are in-flight.
        }
        if (this.activeEditor)
            this.analyzer.client.forceNotificationsFor((0, fs_1.fsPath)(this.activeEditor.document.uri));
    }
    async update() {
        // Build the tree from our outline
        if (this.flutterOutline) {
            this.rootNode = await this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
            FlutterOutlineProvider.showTree();
        }
        else {
            this.rootNode = undefined;
            FlutterOutlineProvider.hideTree();
        }
        this.refresh();
    }
    async createTreeNode(parent, element, editor) {
        // Ensure we're still active editor before trying to use.
        if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
            const node = new FlutterWidgetItem(parent, element, editor);
            // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
            const startLine = editor.document.positionAt(element.offset).line;
            const endLine = editor.document.positionAt(element.offset + element.length).line;
            for (let line = startLine; line <= endLine; line++) {
                if (!this.treeNodesByLine[line]) {
                    this.treeNodesByLine[line] = [];
                }
                this.treeNodesByLine[line].push(node);
            }
            if (element.children)
                node.children = (await Promise.all(element.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
            return node;
        }
        return undefined;
    }
}
exports.DasFlutterOutlineProvider = DasFlutterOutlineProvider;
class LspFlutterOutlineProvider extends FlutterOutlineProvider {
    analyzer;
    flutterOutline;
    constructor(analytics, analyzer) {
        super(analytics);
        this.analyzer = analyzer;
        this.analyzer.fileTracker.onFlutterOutline((n) => {
            if (this.activeEditor && (0, fs_1.fsPath)(vs.Uri.parse(n.uri)) === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.flutterOutline = n.outline;
                this.treeNodesByLine = [];
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                if (!this.rootNode)
                    void this.update();
                else
                    this.updateTimeout = setTimeout(() => this.update(), 200);
            }
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
        }
    }
    async loadExistingOutline() {
        this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
        if (this.flutterOutline)
            await this.update();
        else {
            this.rootNode = undefined;
            this.refresh(); // Force update (to nothing) while requests are in-flight.
        }
    }
    async update() {
        // Build the tree from our outline
        if (this.flutterOutline) {
            this.rootNode = await this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
            FlutterOutlineProvider.showTree();
        }
        else {
            this.rootNode = undefined;
            FlutterOutlineProvider.hideTree();
        }
        this.refresh();
    }
    async createTreeNode(parent, outline, editor) {
        // Ensure we're still active editor before trying to use.
        if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
            const node = new FlutterWidgetItem(parent, outline, editor);
            // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
            const startLine = outline.range.start.line;
            const endLine = outline.range.end.line;
            for (let line = startLine; line <= endLine; line++) {
                if (!this.treeNodesByLine[line]) {
                    this.treeNodesByLine[line] = [];
                }
                this.treeNodesByLine[line].push(node);
            }
            if (outline.children)
                node.children = (await Promise.all(outline.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
            return node;
        }
        return undefined;
    }
}
exports.LspFlutterOutlineProvider = LspFlutterOutlineProvider;
function isWidget(outline) {
    return outline.kind !== "DART_ELEMENT";
}
async function getFixes(editor, outline) {
    const pos = "range" in outline
        ? (0, utils_2.lspToPosition)(outline.range.start)
        : editor.document.positionAt(outline.offset);
    const range = new vs.Range(pos, pos);
    const fixes = await vs.commands.executeCommand("vscode.executeCodeActionProvider", editor.document.uri, range);
    return fixes || [];
}
class FlutterWidgetItem extends vs.TreeItem {
    parent;
    outline;
    children = [];
    fixes = [];
    constructor(parent, outline, editor) {
        super(FlutterWidgetItem.getLabel(outline), (outline.children && outline.children.length)
            ? vs.TreeItemCollapsibleState.Expanded
            : vs.TreeItemCollapsibleState.None);
        this.parent = parent;
        this.outline = outline;
        this.description = FlutterWidgetItem.getDescription(outline);
        if (isWidget(outline)) {
            this.iconPath = vs.Uri.file(path.join(extension_utils_1.extensionPath, "media/icons/flutter_widget.svg"));
        }
        else if (outline.dartElement) {
            const icon = (0, mappings_1.getIconForSymbolKind)((0, analyzer_das_1.getSymbolKindForElementKind)(logging_1.nullLogger, outline.dartElement.kind));
            this.iconPath = {
                dark: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-dark.svg`)),
                light: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-light.svg`)),
            };
        }
        const displayRange = "range" in outline
            ? outline.range
            : new vs.Range(editor.document.positionAt(outline.offset), editor.document.positionAt(outline.offset + outline.length));
        const highlightRange = "codeRange" in outline
            ? outline.codeRange
            : new vs.Range(editor.document.positionAt(outline.codeOffset), editor.document.positionAt(outline.codeOffset + outline.codeLength));
        const selectionPos = "range" in outline
            ? outline.dartElement && outline.dartElement.range
                ? (0, utils_2.lspToPosition)(outline.dartElement.range.start)
                : (0, utils_2.lspToPosition)(outline.range.start)
            : outline.dartElement && outline.dartElement.location && outline.dartElement.location.offset
                ? editor.document.positionAt(outline.dartElement.location.offset)
                : editor.document.positionAt(outline.offset);
        this.command = {
            arguments: [
                editor,
                // Code to fit on screen
                displayRange,
                // Code to highlight
                highlightRange,
                // Selection (we just want to move cursor, so it's 0-length)
                new vs.Range(selectionPos, selectionPos),
            ],
            command: "_dart.showCode",
            title: "",
        };
        this.tooltip = (0, utils_2.treeLabel)(this);
        if (outline.attributes && outline.attributes.length) {
            this.tooltip += "\n  " + outline.attributes.map((a) => `${a.name}: ${a.label}`).join("\n   ");
        }
    }
    static getLabel(outline) {
        let label = "";
        if (outline.dartElement) {
            label += " " + outline.dartElement.name;
            if (outline.dartElement.typeParameters)
                label += outline.dartElement.typeParameters;
        }
        if (outline.variableName)
            label += " " + outline.variableName;
        if (outline.className)
            label += " " + outline.className;
        if (outline.label)
            label += " " + outline.label;
        return label.trim();
    }
    static getDescription(outline) {
        let label = "";
        if (outline.dartElement) {
            if (outline.dartElement.parameters)
                label += outline.dartElement.parameters;
            if (outline.dartElement.returnType)
                label += " → " + outline.dartElement.returnType;
        }
        // Prefer an attribute named "data", but otherwise try some others
        // in order that appear useful.
        const attributeToShow = outline.attributes?.find((a) => a.name === "data")
            || outline.attributes?.find((a) => a.name === "icon" || a.name === "value");
        if (attributeToShow)
            label += " " + attributeToShow.label;
        return label.trim();
    }
}
exports.FlutterWidgetItem = FlutterWidgetItem;


/***/ }),

/***/ 4261:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterTaskProvider = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(3960);
const utils_2 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const utils_3 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const dart_task_provider_1 = __webpack_require__(8641);
const util = __importStar(__webpack_require__(279));
class FlutterTaskProvider extends dart_task_provider_1.BaseTaskProvider {
    flutterCapabilities;
    static type = "flutter"; // also referenced in package.json
    get type() { return FlutterTaskProvider.type; }
    constructor(logger, context, sdks, flutterCapabilities) {
        super(logger, context, sdks);
        this.flutterCapabilities = flutterCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("flutter.task.genl10n", (uri) => this.runProjectTask(uri, "flutter", ["gen-l10n"])));
    }
    async provideTasks(token) {
        const projectFolders = await (0, utils_3.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
        const promises = [];
        projectFolders.forEach((folder) => {
            const folderUri = vs.Uri.file(folder);
            const workspaceFolder = vs.workspace.getWorkspaceFolder(folderUri);
            const isFlutter = (0, fs_1.isFlutterProjectFolder)(folder);
            if (isFlutter) {
                promises.push(...this.createSharedTasks(workspaceFolder, folderUri));
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "aar"]));
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "apk"]));
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "appbundle"]));
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "bundle"]));
                if (constants_1.isMac) {
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ios"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ios-framework"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ipa"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "macos"]));
                }
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "web"]));
                if (constants_1.isWin) {
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "windows"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "winuwp"]));
                }
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["install"]));
                promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["gen-l10n"]));
            }
        });
        const tasks = (await Promise.all(promises)).filter(utils_2.notUndefined);
        return tasks;
    }
    createPubTask(workspaceFolder, projectFolder, args) {
        return this.createTask(workspaceFolder, projectFolder, "flutter", ["pub", ...args]);
    }
    injectArgs(definition) {
        definition.args = definition.args ?? [];
        if (definition.command === "flutter") {
            // Inject web-renderer if required.
            const isWebBuild = (0, array_1.arrayStartsWith)(definition.args, ["build", "web"]);
            if (isWebBuild && !definition.args.includes("--web-renderer")) {
                const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                if (renderer) {
                    definition.args.push("--web-renderer");
                    definition.args.push(renderer);
                }
            }
        }
    }
}
exports.FlutterTaskProvider = FlutterTaskProvider;


/***/ }),

/***/ 2338:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateLocalizationsOnSaveHandler = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
const utils_2 = __webpack_require__(279);
class GenerateLocalizationsOnSaveHandler {
    disposables = [];
    debounceDelayTimer;
    // Track save reason so we can avoid hot reloading on auto-saves.
    lastSaveReason;
    // And whether any saved file was dirty to support `..ifDirty` settings.
    isSavingDirtyFile = false;
    constructor() {
        this.disposables.push(vscode_1.workspace.onWillSaveTextDocument((e) => {
            if (!this.isGeneratableFile(e.document))
                return;
            this.lastSaveReason = e.reason;
            this.isSavingDirtyFile = this.isSavingDirtyFile || e.document.isDirty;
        }));
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            this.triggerGeneration(td);
        }));
    }
    triggerGeneration(file) {
        const isAutoSave = this.lastSaveReason === vscode_1.TextDocumentSaveReason.FocusOut ||
            this.lastSaveReason === vscode_1.TextDocumentSaveReason.AfterDelay;
        // Never do anything for files inside .dart_tool folders.
        if (!this.isGeneratableFile(file))
            return;
        const isDirty = this.isSavingDirtyFile;
        this.isSavingDirtyFile = false;
        const configSetting = config_1.config.flutterGenerateLocalizationsOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "flutter.task.genl10n";
        const args = [file.uri];
        // Debounce to avoid reloading multiple times during multi-file-save (Save All).
        // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
        if (this.debounceDelayTimer) {
            clearTimeout(this.debounceDelayTimer);
        }
        this.debounceDelayTimer = setTimeout(() => {
            this.debounceDelayTimer = undefined;
            void vscode_1.commands.executeCommand(commandToRun, args);
        }, 200);
    }
    isGeneratableFile(file) {
        // Never do anything for files inside .dart_tool folders.
        if ((0, fs_1.fsPath)(file.uri).includes(`${path.sep}.dart_tool${path.sep}`))
            return false;
        // Bail out if we're in an external file, or not Dart.
        if (!(0, utils_2.isWithinWorkspace)((0, fs_1.fsPath)(file.uri)) || !this.isArbDocument(file))
            return false;
        if (!(0, utils_2.isInsideFlutterProject)(file.uri))
            return false;
        return true;
    }
    isArbDocument(file) {
        if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
            return false;
        const extName = path.extname((0, fs_1.fsPath)(file.uri));
        const extension = extName ? extName.substr(1) : undefined;
        return extension === "arb";
    }
    dispose() {
        if (this.debounceDelayTimer)
            clearTimeout(this.debounceDelayTimer);
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.GenerateLocalizationsOnSaveHandler = GenerateLocalizationsOnSaveHandler;


/***/ }),

/***/ 3419:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VmServiceExtensions = exports.timeDilationSlow = exports.timeDilationNormal = exports.IS_INSPECTING_WIDGET_CONTEXT = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(1894);
const debug_1 = __webpack_require__(394);
exports.IS_INSPECTING_WIDGET_CONTEXT = "dart-code:flutter.isInspectingWidget";
const keyTimeDilation = "timeDilation";
const keyEnabled = "enabled";
const keyValue = "value";
/// Service extension values must be wrapped in objects when sent to the VM, eg:
///
///     { timeDilation: x.x }
///     { enabled: true }
///
/// This map tracks the name of the key for a given extension.
const toggleExtensionStateKeys = {
    [enums_1.VmServiceExtension.PlatformOverride]: keyValue,
    [enums_1.VmServiceExtension.DebugBanner]: keyEnabled,
    [enums_1.VmServiceExtension.DebugPaint]: keyEnabled,
    [enums_1.VmServiceExtension.PaintBaselines]: keyEnabled,
    [enums_1.VmServiceExtension.InspectorSelectMode]: keyEnabled,
    [enums_1.VmServiceExtension.BrightnessOverride]: keyValue,
    [enums_1.VmServiceExtension.RepaintRainbow]: keyEnabled,
    [enums_1.VmServiceExtension.PerformanceOverlay]: keyEnabled,
    [enums_1.VmServiceExtension.SlowAnimations]: keyTimeDilation,
};
exports.timeDilationNormal = 1.0;
exports.timeDilationSlow = 5.0;
/// Manages state for (mostly Flutter) VM service extensions.
class VmServiceExtensions {
    logger;
    debugCommands;
    workspaceContext;
    flutterCapabilities;
    registeredServices = {};
    loadedServiceExtensions = [];
    loadedServiceExtensionIsolateIds = new Map();
    /// Extension values owned by us. If someone else updates a value, we should
    /// remove it from here.
    currentExtensionValues = {};
    constructor(logger, debugCommands, workspaceContext, flutterCapabilities) {
        this.logger = logger;
        this.debugCommands = debugCommands;
        this.workspaceContext = workspaceContext;
        this.flutterCapabilities = flutterCapabilities;
        this.debugCommands.onWillHotRestart(() => this.markAllServiceExtensionsUnloaded());
    }
    /// Handles an event from the Debugger, such as extension services being loaded and values updated.
    async handleDebugEvent(session, e) {
        if (e.event === "dart.serviceExtensionAdded") {
            this.handleServiceExtensionLoaded(session, e.body.extensionRPC, e.body.isolateId);
            const useAddPubRootDirectories = this.flutterCapabilities.supportsAddPubRootDirectories;
            const pubRootDirectoriesService = useAddPubRootDirectories
                ? enums_1.VmServiceExtension.InspectorAddPubRootDirectories
                : enums_1.VmServiceExtension.InspectorSetPubRootDirectories;
            try {
                if (e.body.extensionRPC === pubRootDirectoriesService) {
                    const params = {
                        // TODO: Is this OK???
                        isolateId: e.body.isolateId,
                    };
                    let argNum = 0;
                    for (const workspaceFolder of (0, utils_1.getDartWorkspaceFolders)()) {
                        params[`arg${argNum++}`] = this.formatPathForPubRootDirectories((0, fs_1.fsPath)(workspaceFolder.uri));
                    }
                    await this.callServiceExtension(e.session, pubRootDirectoriesService, params);
                }
            }
            catch (e) {
                if (!this.shouldSilenceError(e)) {
                    this.logger.error(e);
                }
            }
        }
        else if (e.event === "dart.serviceRegistered") {
            this.handleServiceRegistered(e.body.service, e.body.method);
        }
        else if (e.event === "flutter.serviceExtensionStateChanged") {
            this.handleRemoteValueUpdate(e.body.extension, e.body.value);
        }
    }
    shouldSilenceError(e) {
        return constants_1.isDartCodeTestRun && "message" in e && typeof e.message === "string" && e.message.includes("Service connection disposed");
    }
    formatPathForPubRootDirectories(path) {
        if (constants_1.isWin) {
            return path && `file:///${path.replace(/\\/g, "/")}`;
        }
        // TODO(helin24): Use DDS for this translation.
        const search = "/google3/";
        if (this.workspaceContext.config.forceFlutterWorkspace && path.startsWith("/google") && path.includes(search)) {
            const idx = path.indexOf(search);
            const remainingPath = path.substring(idx + search.length);
            return `google3:///${remainingPath}`;
        }
        return path;
    }
    async overridePlatform() {
        const selection = await vs.window.showQuickPick([
            { label: "Android", platform: "android" },
            { label: "iOS", platform: "iOS" },
            { label: "macOS", platform: "macOS" },
            { label: "Windows", platform: "windows" },
            { label: "Linux", platform: "linux" },
        ]);
        if (!selection)
            return;
        // Pass the same value for both options as we will always set it.
        return this.toggle(enums_1.VmServiceExtension.PlatformOverride, selection.platform, selection.platform);
    }
    /// Toggles between two values. Always picks the value1 if the current value
    /// is not already value1 (eg. if it's neither of those, it'll pick val1).
    async toggle(id, val1 = true, val2 = false) {
        /// Helper that toggles for one session.
        const toggleForSession = async (session) => {
            const newValue = val1 === val2
                ? val1
                : await this.getCurrentServiceExtensionValue(session.session, id) !== val1
                    ? val1
                    : val2;
            this.currentExtensionValues[id] = newValue;
            await this.sendExtensionValue(session.session, id, newValue);
        };
        await Promise.all(debug_1.debugSessions.map((session) => toggleForSession(session).catch((e) => this.logger.error(e))));
    }
    async getCurrentServiceExtensionValue(session, method) {
        const responseBody = await this.callServiceExtension(session, method);
        return this.extractServiceValue(responseBody[toggleExtensionStateKeys[method]]);
    }
    async sendExtensionValue(session, method, value) {
        const params = { [toggleExtensionStateKeys[method]]: value };
        await this.callServiceExtension(session, method, params);
    }
    async callServiceExtension(session, method, params) {
        if (!params?.isolateId) {
            params = params || {};
            params.isolateId = this.loadedServiceExtensionIsolateIds.get(method);
        }
        return await session.customRequest("callService", { method, params });
    }
    syncContextStates(id, value) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        if (id === enums_1.VmServiceExtension.InspectorSelectMode) {
            /// Keep the context in sync so that the "Cancel Inspect Widget" command is enabled/disabled.
            void vs.commands.executeCommand("setContext", exports.IS_INSPECTING_WIDGET_CONTEXT, !!value);
            this.debugCommands.isInspectingWidget = !!value;
        }
    }
    /// Handles updates that come from the VM (eg. were updated by another tool).
    handleRemoteValueUpdate(id, value) {
        this.syncContextStates(id, value);
        // Don't try to process service extension we don't know about.
        if (this.currentExtensionValues[id] === undefined)
            return;
        value = this.extractServiceValue(value);
        // If someone else updated it to something different to the value we're
        // overriding, then remove our override.
        if (this.currentExtensionValues[id] !== value)
            delete this.currentExtensionValues[id];
    }
    extractServiceValue(value) {
        // HACK: Everything comes through as strings, but we need bools/ints and sometimes strings,
        // so attempt to parse it, but keep the original string in the case of failure.
        if (typeof value === "string") {
            try {
                value = JSON.parse(value);
            }
            catch {
            }
        }
        return value;
    }
    /// Resets all local state to defaults - used when terminating the last debug session (or
    // starting the first) to ensure debug toggles don't "persist" across sessions.
    resetToDefaults() {
        this.currentExtensionValues = {};
    }
    /// Tracks registered services and updates contexts to enable VS Code commands.
    handleServiceRegistered(service, method) {
        this.registeredServices[service] = method;
        void vs.commands.executeCommand("setContext", `${constants_contexts_1.SERVICE_CONTEXT_PREFIX}${service}`, true);
    }
    /// Tracks loaded service extensions and updates contexts to enable VS Code commands.
    handleServiceExtensionLoaded(session, extensionRPC, isolateId) {
        session.loadedServiceExtensions.push(extensionRPC);
        this.loadedServiceExtensions.push(extensionRPC);
        if (isolateId)
            this.loadedServiceExtensionIsolateIds.set(extensionRPC, isolateId);
        void vs.commands.executeCommand("setContext", `${constants_contexts_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${extensionRPC}`, true);
        // If this extension is one we have an override value for, then this must be the extension loading
        // for a new isolate (perhaps after a restart), so send its value.
        // Only ever send values for enabled and known extensions.
        const isTogglableService = toggleExtensionStateKeys[extensionRPC] !== undefined;
        const value = this.currentExtensionValues[extensionRPC];
        const hasValue = value !== undefined;
        if (isTogglableService && hasValue) {
            this.sendExtensionValue(session.session, extensionRPC, value).catch((e) => {
                if (!this.shouldSilenceError(e)) {
                    this.logger.error(e);
                }
            });
        }
    }
    /// Marks all services as not-loaded (happens after session ends).
    markAllServicesUnloaded() {
        for (const id of Object.keys(this.registeredServices)) {
            void vs.commands.executeCommand("setContext", `${constants_contexts_1.SERVICE_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.registeredServices = {};
    }
    /// Marks all service extensions as not-loaded (happens after session ends or after hot restart).
    markAllServiceExtensionsUnloaded() {
        for (const id of this.loadedServiceExtensions) {
            void vs.commands.executeCommand("setContext", `${constants_contexts_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.loadedServiceExtensions.length = 0;
        this.loadedServiceExtensionIsolateIds.clear();
    }
    // TODO: These services should be per-session!
    serviceIsRegistered(service) {
        return !!this.registeredServices[service];
    }
    getServiceMethodName(service) {
        return this.registeredServices[service];
    }
    serviceExtensionIsLoaded(id) {
        return !!this.loadedServiceExtensions.find((loadedID) => loadedID === id);
    }
}
exports.VmServiceExtensions = VmServiceExtensions;


/***/ }),

/***/ 7431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
// TODO: Remove this class once Flutter Stable has an LSP server that uses $/progress.
class LspAnalyzerStatusReporter {
    analyzer;
    analysisInProgress = false;
    analyzingPromise;
    constructor(analyzer) {
        this.analyzer = analyzer;
        analyzer.onAnalysisStatusChange((params) => this.handleServerStatus(params));
    }
    handleServerStatus(params) {
        if (params.suppressProgress) {
            return;
        }
        this.analysisInProgress = params.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 100);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
}
exports.LspAnalyzerStatusReporter = LspAnalyzerStatusReporter;


/***/ }),

/***/ 1683:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClosingLabelsDecorations = void 0;
const vs = __importStar(__webpack_require__(1398));
const custom_protocol_1 = __webpack_require__(815);
const utils_1 = __webpack_require__(949);
const document_cache_1 = __webpack_require__(2524);
const editors_1 = __webpack_require__(6305);
const config_1 = __webpack_require__(7678);
const closing_labels_decorations_1 = __webpack_require__(4283);
class LspClosingLabelsDecorations {
    analyzer;
    subscriptions = [];
    closingLabels = new document_cache_1.DocumentCache();
    editors = new document_cache_1.DocumentCache();
    updateTimeouts = new document_cache_1.DocumentCache();
    decorationType;
    closingLabelsPrefix;
    buildDecorationType() {
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                fontStyle: config_1.config.closingLabelsTextStyle,
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
    }
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.closingLabelsPrefix = config_1.config.closingLabelsPrefix;
        this.buildDecorationType();
        void analyzer.start().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishClosingLabelsNotification.type, (n) => {
                const uri = vs.Uri.parse(n.uri);
                this.closingLabels.set(uri, n);
                // Fire an update if it was for a visible editor.
                const editor = (0, editors_1.findVisibleEditor)(uri);
                if (editor) {
                    // Delay this so if we're getting lots of updates we don't flicker.
                    if (this.updateTimeouts.has(uri))
                        clearTimeout(this.updateTimeouts.get(uri));
                    this.updateTimeouts.set(uri, setTimeout(() => this.update(uri), 500));
                }
            });
        });
        this.subscriptions.push(vs.window.onDidChangeVisibleTextEditors(() => this.updateAll()));
        this.subscriptions.push(vs.workspace.onDidCloseTextDocument((td) => {
            this.closingLabels.delete(td.uri);
        }));
        this.subscriptions.push(vs.workspace.onDidChangeConfiguration((e) => {
            let needsUpdate = false;
            if (e.affectsConfiguration("dart.closingLabelsPrefix")) {
                needsUpdate = true;
                this.closingLabelsPrefix = config_1.config.closingLabelsPrefix;
            }
            if (e.affectsConfiguration("dart.closingLabels") || e.affectsConfiguration("dart.closingLabelsTextStyle")) {
                needsUpdate = true;
                this.decorationType.dispose();
                this.buildDecorationType();
            }
            if (needsUpdate) {
                this.updateAll();
            }
        }));
        this.updateAll();
    }
    updateAll() {
        for (const editor of vs.window.visibleTextEditors)
            this.update(editor.document.uri);
    }
    update(uri) {
        if (!this.closingLabels.has(uri))
            return;
        const editor = (0, editors_1.findVisibleEditor)(uri);
        if (!editor)
            return;
        const decorations = [];
        for (const r of this.closingLabels.get(uri)?.labels ?? []) {
            const labelRange = this.analyzer.protocol2CodeConverter.asRange(r.range);
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = labelRange.end;
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = editor.document.getText(finalCharacterRange);
            if (!closing_labels_decorations_1.validLastCharacters.includes(finalCharacterText))
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = editor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = this.closingLabelsPrefix + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(labelRange.start, endOfLine),
                    renderOptions: { after: { contentText: this.closingLabelsPrefix + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.editors.set(uri, editor);
        editor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    dispose() {
        for (const editor of Object.values(this.editors)) {
            try {
                editor.setDecorations(this.decorationType, []);
            }
            catch {
                // It's possible the editor was closed, but there
                // doesn't seem to be a way to tell.
            }
        }
        this.decorationType.dispose();
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.LspClosingLabelsDecorations = LspClosingLabelsDecorations;


/***/ }),

/***/ 7164:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspGoToLocationCommand = exports.LspGoToAugmentationCommand = exports.LspGoToAugmentedCommand = exports.LspGoToImportsCommand = exports.LspGoToSuperCommand = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const editors = __importStar(__webpack_require__(9451));
class LspGoToCommand {
    analyzer;
    disposables = [];
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    async goToLocation(location) {
        const codeLocation = this.analyzer.client.protocol2CodeConverter.asLocation(location);
        const uri = codeLocation.uri;
        const elementDocument = await vs.workspace.openTextDocument(uri);
        const sourceUriString = (0, fs_1.uriComparisonString)(uri);
        const existingTab = vs.window.tabGroups.all
            .flatMap((group) => group.tabs)
            .find((tab) => tab.input instanceof vs.TabInputText && (0, fs_1.uriComparisonString)(tab.input.uri) === sourceUriString);
        const tabGroup = existingTab?.group.viewColumn;
        const elementEditor = await vs.window.showTextDocument(elementDocument, tabGroup);
        (0, utils_2.showCode)(elementEditor, codeLocation.range, codeLocation.range, codeLocation.range);
    }
    async goToLocations(locations, sourceUri, sourcePosition) {
        if (!Array.isArray(locations))
            return this.goToLocation(locations);
        if (locations.length === 1)
            return this.goToLocation(locations[0]);
        const codeLocations = locations.map((l) => this.analyzer.client.protocol2CodeConverter.asLocation(l));
        void vs.commands.executeCommand("editor.action.goToLocations", sourceUri, sourcePosition, codeLocations, "gotoAndPeek", "No imports found for this element");
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
class LspGoToRequestCommand extends LspGoToCommand {
    analyzer;
    constructor(analyzer) {
        super(analyzer);
        this.analyzer = analyzer;
    }
    async goTo() {
        const editor = editors.getActiveDartEditor();
        if (!editor) {
            void vs.window.showWarningMessage("No active Dart editor.");
            return;
        }
        const locations = await this.getLocations({
            position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
            textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
        });
        if (!locations)
            return;
        await this.goToLocations(locations, editor.document.uri, editor.selection.start);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
class LspGoToSuperCommand extends LspGoToRequestCommand {
    constructor(analyzer) {
        super(analyzer);
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goTo, this));
    }
    getLocations(params) {
        return this.analyzer.getSuper(params);
    }
}
exports.LspGoToSuperCommand = LspGoToSuperCommand;
class LspGoToImportsCommand extends LspGoToRequestCommand {
    constructor(analyzer) {
        super(analyzer);
        this.disposables.push(vs.commands.registerCommand("dart.goToImports", this.goTo, this));
    }
    getLocations(params) {
        return this.analyzer.getImports(params);
    }
}
exports.LspGoToImportsCommand = LspGoToImportsCommand;
class LspGoToAugmentedCommand extends LspGoToRequestCommand {
    constructor(analyzer) {
        super(analyzer);
        this.disposables.push(vs.commands.registerCommand("dart.goToAugmented", this.goTo, this));
    }
    getLocations(params) {
        return this.analyzer.getAugmented(params);
    }
}
exports.LspGoToAugmentedCommand = LspGoToAugmentedCommand;
class LspGoToAugmentationCommand extends LspGoToRequestCommand {
    constructor(analyzer) {
        super(analyzer);
        this.disposables.push(vs.commands.registerCommand("dart.goToAugmentation", this.goTo, this));
    }
    getLocations(params) {
        return this.analyzer.getAugmentation(params);
    }
}
exports.LspGoToAugmentationCommand = LspGoToAugmentationCommand;
/**
 * Supports the dart.goToLocation command that the LSP server may use.
 */
class LspGoToLocationCommand extends LspGoToCommand {
    constructor(analyzer) {
        super(analyzer);
        this.disposables.push(vs.commands.registerCommand("dart.goToLocation", this.goToLocations, this));
    }
}
exports.LspGoToLocationCommand = LspGoToLocationCommand;


/***/ }),

/***/ 867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// TODO: Move this to Shared (and remove dependencies on extension/)
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestDiscoverer = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const test_model_1 = __webpack_require__(5871);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_lsp_1 = __webpack_require__(3248);
const test_1 = __webpack_require__(672);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
class TestDiscoverer {
    logger;
    fileTracker;
    model;
    disposables = [];
    debounceTimers = {};
    debounceDuration = 1500;
    hasSetupFileHandlers = false;
    testDiscoveryPerformed;
    constructor(logger, fileTracker, model) {
        this.logger = logger;
        this.fileTracker = fileTracker;
        this.model = model;
        this.disposables.push(fileTracker.onOutline((o) => this.handleOutline(o)));
    }
    /// Performs suite discovery if it has not already finished. If discovery
    /// is started (or already in progress), waits for it to complete.
    async ensureSuitesDiscovered() {
        if (!this.testDiscoveryPerformed)
            this.testDiscoveryPerformed = this.performSuiteDiscovery();
        // Wait for discovery to complete, however it started.
        await this.testDiscoveryPerformed;
    }
    /// Immediately performs suite discovery. Use [ensureSuitesDiscovered] if you want
    /// to just ensure discovery has run at least once.
    ///
    /// Also sets up handlers so creating/renaming/deleting files updates the
    /// discovered suite list correctly.
    async performSuiteDiscovery() {
        // Set up events for create/rename/delete so we keep the suites updated
        // once we have discovered them.
        if (!this.hasSetupFileHandlers) {
            this.hasSetupFileHandlers = true;
            this.disposables.push(vs.workspace.onDidCreateFiles((e) => {
                e.files.forEach((file) => {
                    const filePath = (0, fs_1.fsPath)(file);
                    if ((0, utils_3.isTestFile)(filePath))
                        this.model.suiteDiscovered(undefined, filePath);
                });
            }), vs.workspace.onDidRenameFiles(async (e) => {
                e.files.forEach(async (file) => {
                    this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file.oldUri));
                    void this.discoverTestSuites((0, fs_1.fsPath)(file.newUri), undefined);
                });
            }), vs.workspace.onDidDeleteFiles(async (e) => {
                e.files.forEach(async (file) => {
                    this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file));
                });
            }));
        }
        await vs.window.withProgress({
            location: vs.ProgressLocation.Window,
            title: "Discovering Tests…",
        }, async () => {
            try {
                const projectFoldersAndExclusions = await (0, utils_2.getAllProjectFoldersAndExclusions)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
                const projectFolders = projectFoldersAndExclusions.projectFolders;
                const excludedFolders = projectFoldersAndExclusions.excludedFolders;
                await Promise.all(projectFolders.map((folder) => this.discoverTestSuites(folder, excludedFolders)));
            }
            catch (e) {
                this.logger.error(`Failed to discover tests: ${e}`);
            }
        });
    }
    async discoverTestSuites(fileOrDirectory, excludedFolders, isDirectory, level = 0) {
        if (level > 100)
            return; // Ensure we don't traverse too far or follow any cycles.
        if ((0, utils_3.isTestFile)(fileOrDirectory)) {
            this.model.suiteDiscovered(undefined, fileOrDirectory);
        }
        else if (isDirectory !== false) { // undefined or true are allowed
            try {
                const children = await vs.workspace.fs.readDirectory(vs.Uri.file(fileOrDirectory));
                const childPromises = children
                    .map((item) => ({ name: item[0], type: item[1] }))
                    .filter((item) => !item.name.startsWith("."))
                    .map((item) => ({ name: item.name, type: item.type, path: path.join(fileOrDirectory, item.name) }))
                    .filter((item) => !excludedFolders?.has(item.path) ?? false)
                    .map((item) => this.discoverTestSuites(item.path, excludedFolders, item.type === vs.FileType.Directory, level + 1));
                await Promise.all(childPromises);
            }
            catch (e) {
                if (e.code !== "FileNotADirectory")
                    this.logger.error(`Failed to discover tests: ${e}`);
            }
        }
    }
    async discoverTestsForSuite(node) {
        const doc = await vs.workspace.openTextDocument(node.suiteData.path);
        // Opening a file that hasn't been opened before does not force analysis, so send a light request that will force
        // analysis and for the outline to be sent.
        await vs.commands.executeCommand("vscode.executeHoverProvider", doc.uri, new vs.Position(0, 0));
        await this.fileTracker.waitForOutline(doc, undefined);
    }
    /// Forces an update for a file based on the last Outline data (if any).
    ///
    /// Used by tests to ensure discovery results are available if the test tree state has
    /// been cleared between test runs.
    forceUpdate(uri) {
        const outline = this.fileTracker.getOutlineFor(uri);
        if (outline)
            this.rebuildFromOutline((0, fs_1.fsPath)(uri), outline);
    }
    handleOutline(outline) {
        const suitePath = (0, fs_1.forceWindowsDriveLetterToUppercase)((0, utils_1.uriToFilePath)(outline.uri));
        const existingTimeout = this.debounceTimers[suitePath];
        if (existingTimeout)
            clearTimeout(existingTimeout);
        // If this is the first outline for a file (eg. we've never had a timeout)
        // we should skip the debounce so things are initially more responsive.
        const debounceDuration = existingTimeout ? this.debounceDuration : 0;
        this.debounceTimers[suitePath] = setTimeout(() => this.rebuildFromOutline(suitePath, outline.outline), debounceDuration);
    }
    rebuildFromOutline(suitePath, outline) {
        if ((0, utils_3.isTestFile)(suitePath)) {
            // Generate a unique ID for these IDs to be owned by so that they can be looked
            // up independent of any other ongoing runs.
            const dartCodeDebugSessionID = `discovery-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}`;
            // Force creation of a node if it's not already there.
            const suite = this.model.suiteDiscoveredConditional(dartCodeDebugSessionID, suitePath);
            // Mark everything in the suite as potentially-deleted so that we can detect anything
            // that was not present in the new list to remove it afterwards.
            this.model.markAllAsPotentiallyDeleted(suite, test_model_1.TestSource.Outline);
            const visitor = new TestDiscoveryVisitor(this.logger, this.model, dartCodeDebugSessionID, suitePath);
            visitor.visit(outline);
            this.model.removeAllPotentiallyDeletedNodes(suite);
            this.model.updateSuiteTestCountLabels(suite, true);
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestDiscoverer = TestDiscoverer;
class TestDiscoveryVisitor extends outline_lsp_1.LspOutlineVisitor {
    model;
    dartCodeDebugSessionID;
    suitePath;
    stack = [];
    id = 1;
    constructor(logger, model, dartCodeDebugSessionID, suitePath) {
        super(logger);
        this.model = model;
        this.dartCodeDebugSessionID = dartCodeDebugSessionID;
        this.suitePath = suitePath;
    }
    visitUnitTestTest(outline) {
        this.handleItem(outline, false, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.handleItem(outline, true, super.visitUnitTestGroup);
    }
    handleItem(outline, isGroup, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const parent = this.stack.length > 0 ? this.stack[this.stack.length - 1] : undefined;
        const fullName = parent?.name
            ? `${parent.name} ${name}`
            : name;
        const thisID = this.id++;
        if (isGroup)
            this.model.groupDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent?.id, undefined, range);
        else
            this.model.testDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent?.id, undefined, range, undefined);
        if (isGroup)
            this.stack.push({ id: thisID, name: fullName });
        try {
            base.bind(this)(outline);
        }
        finally {
            if (isGroup)
                this.stack.pop();
        }
    }
}


/***/ }),

/***/ 5143:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UPGRADE_TO_WORKSPACE_FOLDERS = void 0;
exports.locateBestProjectRoot = locateBestProjectRoot;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(279);
exports.UPGRADE_TO_WORKSPACE_FOLDERS = "Mark Projects as Workspace Folders";
function locateBestProjectRoot(folder, allowOutsideWorkspace = false) {
    if (!folder)
        return undefined;
    if (!allowOutsideWorkspace && (!(0, utils_1.isWithinWorkspace)(folder) && vscode_1.workspace.workspaceFolders?.length)) {
        return undefined;
    }
    let dir = folder;
    while (dir !== path.dirname(dir)) {
        if ((0, fs_1.hasPubspec)(dir) || (0, fs_1.hasPackageMapFile)(dir))
            return dir;
        dir = path.dirname(dir);
    }
    return undefined;
}


/***/ }),

/***/ 4709:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCodeActionProvider = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const project_1 = __webpack_require__(5143);
const utils_2 = __webpack_require__(279);
const diagnostics_1 = __webpack_require__(5883);
const applicableErrorCodes = ["uri_does_not_exist", "conditional_uri_does_not_exist", "depend_on_referenced_packages"];
const packageUriSourceCodePattern = new RegExp(`r?['"]+package:([\\w\\-]+)\\/`);
class AddDependencyCodeActionProvider {
    selector;
    constructor(selector) {
        this.selector = selector;
    }
    rank = 90;
    metadata = {
        providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
    };
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!context || !context.diagnostics || !context.diagnostics.length)
            return;
        const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(document.uri));
        if (!projectRoot)
            return;
        let diagnosticsWithPackageNames = context.diagnostics
            .filter((d) => d.range.intersection(range) && d.source === "dart")
            .map((diagnostic) => ({ diagnostic, packageName: this.extractPackageNameForUriNotFoundDiagnostic(document, diagnostic) }))
            .filter((d) => d.packageName);
        if (!diagnosticsWithPackageNames.length)
            return;
        const pubspec = path.join(projectRoot, "pubspec.yaml");
        const pubspecContent = fs.existsSync(pubspec) ? fs.readFileSync(pubspec).toString() : undefined;
        if (!pubspecContent)
            return;
        // Next, filter out any already in pubspec, as that suggests the URI is incorrect
        // for another reason (and we wouldn't want to try to add something that exists).
        diagnosticsWithPackageNames = diagnosticsWithPackageNames
            .filter((obj) => obj.packageName && !pubspecContent.includes(`  ${obj.packageName}`));
        // Next, remove any diagnostics that have the same package name and overlap with the same range.
        // https://github.com/Dart-Code/Dart-Code/issues/4896
        for (let i = 0; i < diagnosticsWithPackageNames.length; i++) {
            const packageName = diagnosticsWithPackageNames[i].packageName;
            const range = diagnosticsWithPackageNames[i].diagnostic.range;
            for (let j = i + 1; j < diagnosticsWithPackageNames.length; j++) {
                const packageName2 = diagnosticsWithPackageNames[i].packageName;
                const range2 = diagnosticsWithPackageNames[i].diagnostic.range;
                if (packageName === packageName2 && !range.intersection(range2)?.isEmpty) {
                    diagnosticsWithPackageNames.splice(j, 1);
                    j--;
                }
            }
        }
        if (!diagnosticsWithPackageNames.length)
            return;
        return (0, utils_1.flatMap)(diagnosticsWithPackageNames, (item) => this.createActions(document, item.diagnostic, item.packageName));
    }
    /// Checks if the diagnostic is a uri_does_not_exist and the URI is a package:
    /// URI and returns the package name.
    extractPackageNameForUriNotFoundDiagnostic(document, diag) {
        const errorCode = (0, diagnostics_1.getDiagnosticErrorCode)(diag);
        if (!errorCode)
            return;
        if (!applicableErrorCodes.includes(errorCode))
            return;
        // Finally, ensure the URI is a package: URI and something that exists in the pub cache list
        // we have.
        const uriSourceCode = document.getText(diag.range);
        const match = packageUriSourceCodePattern.exec(uriSourceCode);
        if (!match)
            return;
        return match[1];
    }
    createActions(document, diagnostic, packageName) {
        const createAction = (isDevDependency) => {
            const dependencyTypeName = isDevDependency ? "dev_dependencies" : "dependencies";
            const title = `Add '${packageName}' to ${dependencyTypeName}`;
            const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
            action.command = {
                arguments: [
                    document.uri,
                    { packageNames: packageName },
                    isDevDependency,
                ],
                command: "_dart.addDependency",
                title,
            };
            return action;
        };
        const actions = [createAction(false)];
        // When outside of lib, dev_dependency is an option too.
        if (!document.uri.path.includes("/lib/"))
            actions.push(createAction(true));
        return actions;
    }
}
exports.AddDependencyCodeActionProvider = AddDependencyCodeActionProvider;


/***/ }),

/***/ 3895:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(279);
const ranking_code_action_provider_1 = __webpack_require__(9160);
class AssistCodeActionProvider {
    logger;
    selector;
    analyzer;
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
    }
    rank = 10;
    metadata = {
        providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
    };
    async provideCodeActions(document, range, context, token) {
        if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
            return undefined;
        // If we were only asked for specific action types and that doesn't include
        // refactor (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
            return undefined;
        try {
            const startOffset = document.offsetAt(range.start);
            const endOffset = document.offsetAt(range.end);
            const assists = await this.analyzer.editGetAssists({
                file: (0, fs_1.fsPath)(document.uri),
                length: endOffset - startOffset,
                offset: startOffset,
            });
            const allAssists = assists.assists.map((assist) => this.convertResult(document, assist));
            return context.only
                ? allAssists.filter((ca) => context.only?.contains(ca.kind))
                : allAssists;
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    convertResult(document, change) {
        const title = change.message;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.Refactor);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        return action;
    }
}
exports.AssistCodeActionProvider = AssistCodeActionProvider;


/***/ }),

/***/ 6541:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCompletionItemProvider = void 0;
/* eslint-disable no-underscore-dangle */
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const extension_utils_1 = __webpack_require__(6584);
const edit_das_1 = __webpack_require__(3470);
const config_1 = __webpack_require__(7678);
// TODO: This code has become messy with the SuggestionSet changes. It could do with some refactoring
// (such as creating a mapping from CompletionSuggestion -> x and SuggestionSet -> x, and then x -> CompletionItem).
class DartCompletionItemProvider {
    logger;
    analyzer;
    disposables = [];
    cachedCompletions = {};
    existingImports = {};
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables.push(analyzer.registerForCompletionAvailableSuggestions((n) => this.storeCompletionSuggestions(n)));
        this.disposables.push(analyzer.registerForCompletionExistingImports((n) => this.storeExistingImports(n)));
    }
    async provideCompletionItems(document, position, token, context) {
        const line = document.lineAt(position.line).text.slice(0, position.character);
        const nextCharacter = document.getText(new vscode_1.Range(position, position.translate({ characterDelta: 200 }))).trim().substr(0, 1);
        const conf = config_1.config.for(document.uri);
        const enableCommitCharacters = conf.enableCompletionCommitCharacters;
        const insertArgumentPlaceholders = !enableCommitCharacters && conf.insertArgumentPlaceholders && this.shouldAllowArgPlaceholders(line);
        if (!this.shouldAllowCompletion(line, context))
            return;
        const offset = document.offsetAt(position);
        const resp = await this.analyzer.completionGetSuggestionsResults({
            file: (0, fs_1.fsPath)(document.uri),
            offset,
        });
        if (token && token.isCancellationRequested) {
            return undefined;
        }
        const includedResults = resp.results.map((r) => this.convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp, r));
        const cachedResults = await this.getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, document.offsetAt(position), resp);
        await promises_1.resolvedPromise;
        if (token && token.isCancellationRequested) {
            return undefined;
        }
        const allResults = [...includedResults, ...cachedResults];
        return new vscode_1.CompletionList(allResults);
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Filter out auto triggered completions on certain characters based on the previous
        // characters (eg. to allow completion on " if it's part of an import).
        if (context.triggerKind === vscode_1.CompletionTriggerKind.TriggerCharacter) {
            switch (context.triggerCharacter) {
                case "{":
                    return line.endsWith("${");
                case "'":
                    return line.endsWith("import '") || line.endsWith("export '");
                case "\"":
                    return line.endsWith("import \"") || line.endsWith("export \"");
                case "/":
                case "\\":
                    return line.startsWith("import \"") || line.startsWith("export \"")
                        || line.startsWith("import '") || line.startsWith("export '");
            }
        }
        // Otherwise, allow through.
        return true;
    }
    shouldAllowArgPlaceholders(line) {
        line = line.trim();
        // Disallow args on imports/exports since they're likely show/hide and
        // we only want the function name. This doesn't catch all cases (for ex.
        // where a show/hide is split across multiple lines) but it's better than
        // nothing. We'd need more semantic info to handle this better, and probably
        // this will go away if commit characters is fixed properly.
        if (line.startsWith("import \"") || line.startsWith("export \"")
            || line.startsWith("import '") || line.startsWith("export '")) {
            return false;
        }
        return true;
    }
    storeCompletionSuggestions(notification) {
        if (notification.changedLibraries) {
            for (const completionSet of notification.changedLibraries) {
                this.cachedCompletions[completionSet.id] = completionSet;
            }
        }
        if (notification.removedLibraries) {
            for (const completionSetID of notification.removedLibraries) {
                delete this.cachedCompletions[completionSetID];
            }
        }
    }
    storeExistingImports(notification) {
        const existingImports = notification.imports;
        // Map with key "elementName/elementDeclaringLibraryUri"
        // Value is a set of imported URIs that import that element.
        const alreadyImportedSymbols = {};
        for (const existingImport of existingImports.imports) {
            for (const importedElement of existingImport.elements) {
                // This is the symbol name and declaring library. That is, the
                // library that declares the symbol, not the one that was imported.
                // This wil be the same for an element that is re-exported by other
                // libraries, so we can avoid showing the exact duplicate.
                const elementName = existingImports.elements.strings[existingImports.elements.names[importedElement]];
                const elementDeclaringLibraryUri = existingImports.elements.strings[existingImports.elements.uris[importedElement]];
                const importedUri = existingImports.elements.strings[existingImport.uri];
                const key = `${elementName}/${elementDeclaringLibraryUri}`;
                if (!alreadyImportedSymbols[key])
                    alreadyImportedSymbols[key] = {};
                alreadyImportedSymbols[key][importedUri] = true;
            }
        }
        this.existingImports[notification.file] = alreadyImportedSymbols;
    }
    async resolveCompletionItem(item, token) {
        if (!item.suggestion) {
            if (!item.documentation && item._documentation) {
                item.documentation = item._documentation;
            }
            return item;
        }
        const res = await this.analyzer.completionGetSuggestionDetails({
            file: item.filePath,
            id: item.suggestionSetID,
            label: item.suggestion.label,
            offset: item.offset,
        });
        if (token && token.isCancellationRequested) {
            return;
        }
        // Rebuild the completion using the additional resolved info.
        return this.createCompletionItemFromSuggestion(item.document, item.offset, item.nextCharacter, item.enableCommitCharacters, item.insertArgumentPlaceholders, item.replacementOffset, item.replacementLength, item.autoImportUri, item.relevance, item.suggestion, res);
    }
    createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, replacementOffset, replacementLength, displayUri, relevance, suggestion, resolvedResult) {
        const completionItem = this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            autoImportUri: displayUri,
            completionText: (resolvedResult && resolvedResult.completion) || suggestion.label,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.label, // Keep the label for display, so we don't update to show "prefix0" as the user moves to it.
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: false,
            kind: undefined, // This is only used when there's no element (eg. keyword completions) that won't happen here.
            parameterNames: suggestion.parameterNames,
            parameterType: undefined, // Unimported completions can't be parameters.
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance,
            replacementLength,
            replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.element ? suggestion.element.returnType : undefined,
            selectionLength: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? 0 : undefined,
            selectionOffset: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? resolvedResult.change.selection.offset : undefined,
        });
        // Additional edits for the imports.
        if (resolvedResult && resolvedResult.change && resolvedResult.change.edits && resolvedResult.change.edits.length) {
            this.appendAdditionalEdits(completionItem, document, resolvedResult.change);
            if (displayUri)
                completionItem.detail = `Auto import from '${displayUri}'` + (completionItem.detail ? `\n\n${completionItem.detail}` : "");
        }
        // Copy the lazy docs over.
        if (resolvedResult && !completionItem.documentation && completionItem._documentation) {
            completionItem.documentation = completionItem._documentation;
        }
        return completionItem;
    }
    async getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, offset, resp) {
        if (!resp.includedSuggestionSets || !resp.includedElementKinds)
            return [];
        const existingImports = resp.libraryFile ? this.existingImports[resp.libraryFile] : undefined;
        // Create a fast lookup for which kinds to include.
        const elementKinds = {};
        resp.includedElementKinds.forEach((k) => elementKinds[k] = true);
        // Create a fast lookup for relevance boosts based on tag string.
        const tagBoosts = {};
        if (resp.includedSuggestionRelevanceTags)
            resp.includedSuggestionRelevanceTags.forEach((r) => tagBoosts[r.tag] = r.relevanceBoost);
        const filePath = (0, fs_1.fsPath)(document.uri);
        const suggestionSetResults = [];
        // Keep track of suggestion sets we've seen to avoid included them twice.
        // See https://github.com/dart-lang/sdk/issues/37211.
        const usedSuggestionSets = {};
        // Keep track of items items we've included so we don't show dupes if
        // there are multiple libraries importing the same thing.
        const includedItems = {};
        for (const includedSuggestionSet of resp.includedSuggestionSets) {
            if (usedSuggestionSets[includedSuggestionSet.id])
                continue;
            // Mark that we've done this one so we don't do it again.
            usedSuggestionSets[includedSuggestionSet.id] = true;
            // Because this work is expensive, we periodically (per suggestion
            // set) yield and check whether cancellation is pending and if so
            // stop and bail out to avoid doing redundant work.
            await promises_1.resolvedPromise;
            if (token && token.isCancellationRequested) {
                return [];
            }
            const suggestionSet = this.cachedCompletions[includedSuggestionSet.id];
            if (!suggestionSet) {
                this.logger.warn(`Suggestion set ${includedSuggestionSet.id} was not available and therefore not included in the completion results`);
                return [];
            }
            const unresolvedItems = suggestionSet.items
                .filter((r) => elementKinds[r.element.kind])
                .filter((suggestion) => {
                // Check existing imports to ensure we don't already import
                // this element (note: this exact element from its declaring
                // library, not just something with the same name). If we do
                // we'll want to skip it.
                // Trim back to the . to handle enum values
                // https://github.com/Dart-Code/Dart-Code/issues/1835
                const key = `${suggestion.label.split(".")[0]}/${suggestion.declaringLibraryUri}`;
                const importingUris = existingImports && existingImports[key];
                // If there are no URIs already importing this, then include it
                // as an auto-import.
                if (!importingUris)
                    return true;
                // Otherwise, it is imported but if it's not by this file, then skip it.
                if (!importingUris[suggestionSet.uri])
                    return false;
                // Finally, we're importing a file that has this item, so include
                // it only if it has not already been included by another imported file.
                // Unlike the above, we include the Kind here so that things with similar labels
                // like Constructors+Class are still included.
                const fullItemKey = `${suggestion.label}/${suggestion.element.kind}/${suggestion.declaringLibraryUri}`;
                const itemHasAlreadyBeenIncluded = includedItems[fullItemKey];
                includedItems[fullItemKey] = true;
                return !itemHasAlreadyBeenIncluded;
            })
                .map((suggestion) => {
                // Calculate the relevance for this item.
                let relevanceBoost = 0;
                if (suggestion.relevanceTags)
                    suggestion.relevanceTags.forEach((t) => relevanceBoost = Math.max(relevanceBoost, tagBoosts[t] || 0));
                const completionItem = this.createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp.replacementOffset, resp.replacementLength, undefined, includedSuggestionSet.relevance + relevanceBoost, suggestion, undefined);
                // Attach additional info that resolve will need.
                const delayedCompletionItem = {
                    autoImportUri: includedSuggestionSet.displayUri || suggestionSet.uri,
                    document,
                    enableCommitCharacters,
                    filePath,
                    insertArgumentPlaceholders,
                    nextCharacter,
                    offset,
                    relevance: includedSuggestionSet.relevance + relevanceBoost,
                    replacementLength: resp.replacementLength,
                    replacementOffset: resp.replacementOffset,
                    suggestion,
                    suggestionSetID: includedSuggestionSet.id,
                    ...completionItem,
                };
                return delayedCompletionItem;
            });
            suggestionSetResults.push(unresolvedItems);
        }
        return [].concat(...suggestionSetResults);
    }
    convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, notification, suggestion) {
        return this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            completionText: suggestion.completion,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.displayText,
            docComplete: suggestion.docComplete,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: suggestion.isDeprecated,
            kind: suggestion.kind,
            parameterNames: suggestion.parameterNames,
            parameterType: suggestion.parameterType,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance: suggestion.relevance,
            replacementLength: notification.replacementLength,
            replacementOffset: notification.replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.returnType || (suggestion.element ? suggestion.element.returnType : undefined),
            selectionLength: suggestion.selectionLength,
            selectionOffset: suggestion.selectionOffset,
        });
    }
    makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, suggestion) {
        const completionItemKind = suggestion.elementKind ? this.getElementKind(suggestion.elementKind) : undefined;
        let label = suggestion.displayText || suggestion.completionText;
        let detail;
        const completionText = new vscode_1.SnippetString();
        let triggerCompletion = false;
        const nextCharacterIsOpenParen = nextCharacter === "(";
        // If element has parameters (METHOD/CONSTRUCTOR/FUNCTION), show its parameters.
        if (suggestion.parameters && completionItemKind !== vscode_1.CompletionItemKind.Property && suggestion.kind !== "OVERRIDE"
            // Don't ever show if there is already a paren! (#969).
            && !label.includes("(")) {
            label += suggestion.parameters.length === 2 ? "()" : "(…)";
            detail = suggestion.parameters;
            const hasParams = (suggestion.parameterNames && suggestion.parameterNames.length > 0)
                || (insertArgumentPlaceholders && !!suggestion.defaultArgumentListString);
            // Add placeholders for params to the completion.
            if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("(");
                if (suggestion.defaultArgumentListString) {
                    for (const arg of this.extractTabstopDataForNamedArgs(suggestion.defaultArgumentListString, suggestion.defaultArgumentListTextRanges || [])) {
                        const text = suggestion.defaultArgumentListString.substring(arg.start, arg.end);
                        if (arg.tabStop)
                            completionText.appendPlaceholder(text);
                        else
                            completionText.appendText(text);
                    }
                }
                else
                    completionText.appendTabstop(); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                const args = suggestion.parameterNames.slice(0, suggestion.requiredParameterCount);
                completionText.appendText("(");
                if (args.length) {
                    completionText.appendPlaceholder(args[0]);
                    for (const arg of args.slice(1)) {
                        completionText.appendText(", ");
                        completionText.appendPlaceholder(arg);
                    }
                }
                else
                    completionText.appendTabstop(0); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("()");
            }
            else {
                completionText.appendText(suggestion.completionText);
            }
        }
        else if (suggestion.selectionOffset) {
            const before = suggestion.completionText.slice(0, suggestion.selectionOffset);
            const selection = suggestion.completionText.slice(suggestion.selectionOffset, suggestion.selectionOffset + (suggestion.selectionLength || 0));
            // If we have a selection offset (eg. a place to put the cursor) but not any text to pre-select then
            // pop open the completion to help the user type the value.
            // Only do this if it ends with a space (argument completion), see #730.
            if (!selection && suggestion.completionText.slice(suggestion.selectionOffset - 1, suggestion.selectionOffset) === " ")
                triggerCompletion = true;
            const after = suggestion.completionText.slice(suggestion.selectionOffset + (suggestion.selectionLength || 0));
            completionText.appendText(before);
            if (selection)
                completionText.appendPlaceholder(selection);
            else
                completionText.appendTabstop(0);
            completionText.appendText(after);
        }
        else {
            completionText.appendText(suggestion.completionText);
        }
        // If we're a property, work out the type.
        if (completionItemKind === vscode_1.CompletionItemKind.Property) {
            // Setters appear as methods with one arg (and cause getters to not appear),
            // so treat them both the same and just display with the properties type.
            detail = suggestion.elementKind === "GETTER"
                ? suggestion.returnType
                // See https://github.com/dart-lang/sdk/issues/27747
                : suggestion.parameters ? suggestion.parameters.substring(1, suggestion.parameters.lastIndexOf(" ")) : "";
            // Otherwise, get return type from method.
        }
        else if (suggestion.returnType) {
            detail =
                detail
                    ? detail + " → " + suggestion.returnType
                    : suggestion.returnType;
        }
        else if (suggestion.parameterType) {
            detail = suggestion.parameterType;
        }
        // If we have trailing commas (flutter) they look weird in the list, so trim the off (for display label only).
        if (label.endsWith(","))
            label = label.substr(0, label.length - 1).trim();
        else
            label = label.trim();
        // If we didnt have a CompletionItemKind from our element, base it on the CompletionSuggestionKind.
        // This covers things like Keywords that don't have elements.
        const kind = completionItemKind || (suggestion.kind ? this.getSuggestionKind(suggestion.kind, label) : undefined);
        const docs = (0, extension_utils_1.cleanDartdoc)(suggestion.docComplete);
        const completion = new vscode_1.CompletionItem(label, kind);
        completion.filterText = label.split("(")[0]; // Don't ever include anything after a ( in filtering.
        if (suggestion.isDeprecated)
            completion.tags = [vs.CompletionItemTag.Deprecated];
        completion.detail = detail;
        completion._documentation = docs ? (0, extension_utils_1.createMarkdownString)(docs) : undefined;
        completion.insertText = completionText;
        completion.keepWhitespace = true;
        completion.range = {
            inserting: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(Math.min(offset, suggestion.replacementOffset + suggestion.replacementLength))),
            replacing: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(suggestion.replacementOffset + suggestion.replacementLength)),
        };
        if (enableCommitCharacters)
            completion.commitCharacters = this.getCommitCharacters(suggestion.kind);
        const triggerCompletionsFor = ["import '';"];
        if (triggerCompletionsFor.includes(label))
            triggerCompletion = true;
        // Handle folders in imports better.
        if (suggestion.kind === "IMPORT" && label.endsWith("/"))
            triggerCompletion = true;
        if (triggerCompletion) {
            completion.command = {
                command: "editor.action.triggerSuggest",
                title: "Suggest",
            };
        }
        // Relevance is a number, highest being best. Code sorts by text, so subtract from a large number so that
        // a text sort will result in the correct order.
        // 555 -> 999455
        //  10 -> 999990
        //   1 -> 999999
        completion.sortText = (1000000 - suggestion.relevance).toString();
        return completion;
    }
    /// Argument info comes through as a stringle string like "a: null, b: null"
    /// and an array of ints that are offset/length pairs. [3,4,12,4] means
    /// characters 3-7 and 12 - 16 are tabstops.
    ///
    /// To process this more easily, we first convert this into an array like:
    ///
    /// ```
    /// [
    ///   { start: 0, end: 3, tabStop: false },
    ///   { start: 3, end: 7, tabStop: true },
    ///   { start: 7, end: 12, tabStop: false },
    ///   { start: 12, end: 16, tabStop: true },
    /// ]
    /// ```
    extractTabstopDataForNamedArgs(argListString, argListTextRanges) {
        const ranges = [];
        let currentIndex = 0;
        // For each range, push anything that comes before it, and it.
        for (const range of this.extractOffsetLengthPairs(argListTextRanges)) {
            ranges.push({ start: currentIndex, end: range[0], tabStop: false });
            ranges.push({ start: range[0], end: range[1], tabStop: true });
            currentIndex = range[1];
        }
        // Then push anything left at the end.
        if (currentIndex < argListString.length)
            ranges.push({ start: currentIndex, end: argListString.length, tabStop: false });
        return ranges;
    }
    extractOffsetLengthPairs(numberPairs) {
        const pairs = [];
        for (let i = 0; i < numberPairs.length - 1; i += 2) {
            pairs.push([numberPairs[i], numberPairs[i] + numberPairs[i + 1]]);
        }
        return pairs;
    }
    getSuggestionKind(kind, label) {
        switch (kind) {
            case "ARGUMENT_LIST":
                return vscode_1.CompletionItemKind.Variable;
            case "IMPORT":
                return label.startsWith("dart:")
                    ? vscode_1.CompletionItemKind.Module
                    : path.extname(label.toLowerCase()) === ".dart"
                        ? vscode_1.CompletionItemKind.File
                        : vscode_1.CompletionItemKind.Folder;
            case "IDENTIFIER":
                return vscode_1.CompletionItemKind.Variable;
            case "INVOCATION":
                return vscode_1.CompletionItemKind.Method;
            case "KEYWORD":
                return vscode_1.CompletionItemKind.Keyword;
            case "NAMED_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "OPTIONAL_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "PARAMETER":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getElementKind(kind) {
        switch (kind) {
            case "CLASS":
            case "CLASS_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Class;
            case "COMPILATION_UNIT":
                return vscode_1.CompletionItemKind.Module;
            case "CONSTRUCTOR":
            case "CONSTRUCTOR_INVOCATION":
                return vscode_1.CompletionItemKind.Constructor;
            case "ENUM":
                return vscode_1.CompletionItemKind.Enum;
            case "ENUM_CONSTANT":
                return vscode_1.CompletionItemKind.EnumMember;
            case "FIELD":
                return vscode_1.CompletionItemKind.Field;
            case "FILE":
                return vscode_1.CompletionItemKind.File;
            case "FUNCTION":
            case "FUNCTION_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Function;
            case "GETTER":
                return vscode_1.CompletionItemKind.Property;
            case "LABEL":
            case "LIBRARY":
                return vscode_1.CompletionItemKind.Module;
            case "LOCAL_VARIABLE":
                return vscode_1.CompletionItemKind.Variable;
            case "METHOD":
                return vscode_1.CompletionItemKind.Method;
            case "PARAMETER":
            case "PREFIX":
                return vscode_1.CompletionItemKind.Variable;
            case "SETTER":
                return vscode_1.CompletionItemKind.Property;
            case "TOP_LEVEL_VARIABLE":
            case "TYPE_PARAMETER":
                return vscode_1.CompletionItemKind.Variable;
            case "UNIT_TEST_GROUP":
                return vscode_1.CompletionItemKind.Module;
            case "UNIT_TEST_TEST":
                return vscode_1.CompletionItemKind.Method;
            case "UNKNOWN":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getCommitCharacters(kind) {
        switch (kind) {
            case "IDENTIFIER":
            case "INVOCATION":
                return [".", ",", "(", "["];
        }
        return undefined;
    }
    appendAdditionalEdits(completionItem, document, change) {
        if (!change)
            return undefined;
        // VS Code expects offsets to be based on the original document, but the analysis server provides
        // them assuming all previous edits have already been made. This means if the server provides us a
        // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
        // If this happens; we will fall back to sequential edits and write a warning.
        const hasProblematicEdits = (0, edit_das_1.hasOverlappingEdits)(change);
        if (hasProblematicEdits) {
            this.logger.error("Unable to insert imports because of overlapping edits from the server.");
            void vs.window.showErrorMessage(`Unable to insert imports because of overlapping edits from the server`);
            return undefined;
        }
        const filePath = (0, fs_1.fsPath)(document.uri);
        const thisFilesEdits = change.edits.filter((e) => e.file === filePath);
        const otherFilesEdits = change.edits.filter((e) => e.file !== filePath);
        if (thisFilesEdits.length) {
            completionItem.additionalTextEdits = (0, utils_1.flatMap)(thisFilesEdits, (edit) => edit.edits.map((edit) => {
                const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                return new vs.TextEdit(range, edit.replacement);
            }));
        }
        if (otherFilesEdits.length) {
            const filteredSourceChange = {
                edits: otherFilesEdits,
                id: change.id,
                linkedEditGroups: [],
                message: change.message,
                selection: change.selection,
            };
            completionItem.command = {
                arguments: [document, filteredSourceChange],
                command: "_dart.applySourceChange",
                title: "Automatically add imports",
            };
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartCompletionItemProvider = DartCompletionItemProvider;


/***/ }),

/***/ 7763:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDiagnostic = exports.DartDiagnosticProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
// TODO: This is not a provider?
class DartDiagnosticProvider {
    analyzer;
    diagnostics;
    lastErrorJson;
    constructor(analyzer, diagnostics) {
        this.analyzer = analyzer;
        this.diagnostics = diagnostics;
        this.analyzer.registerForAnalysisErrors((es) => this.handleErrors(es));
        // Fired when files are deleted
        this.analyzer.registerForAnalysisFlushResults((es) => this.flushResults(es));
    }
    handleErrors(notification) {
        const notificationJson = JSON.stringify(notification);
        // As a workaround for https://github.com/Dart-Code/Dart-Code/issues/1678, if
        // the errors we got are exactly the same as the previous set, do not give
        // them to VS Code. This avoids a potential loop of refreshing the error view
        // which triggers a request for Code Actions, which could result in analysis
        // of the file (which triggers errors to be sent, which triggers a refresh
        // of the error view... etc.!).
        if (this.lastErrorJson === notificationJson) {
            // TODO: Come up with a better fix than this!
            // log("Skipping error notification as it was the same as the previous one");
            return;
        }
        let errors = notification.errors;
        if (!config_1.config.showTodos)
            errors = errors.filter((error) => error.type !== "TODO");
        this.diagnostics.set(vscode_1.Uri.file(notification.file), errors.map((e) => DartDiagnosticProvider.createDiagnostic(e)));
        this.lastErrorJson = notificationJson;
    }
    static createDiagnostic(error) {
        const diag = new DartDiagnostic((0, utils_1.toRangeOnLine)(error.location), error.message, DartDiagnosticProvider.getSeverity(error.severity, error.type), error.type);
        diag.code = error.url ? { value: error.code, target: vscode_1.Uri.parse(error.url) } : error.code;
        diag.source = "dart";
        diag.tags = DartDiagnosticProvider.getTags(error);
        if (error.correction)
            diag.message += `\n${error.correction}`;
        if (error.contextMessages && error.contextMessages.length)
            diag.relatedInformation = error.contextMessages.map(DartDiagnosticProvider.createRelatedInformation);
        return diag;
    }
    static createRelatedInformation(related) {
        return new vscode_1.DiagnosticRelatedInformation(new vscode_1.Location(vscode_1.Uri.file(related.location.file), (0, utils_1.toRangeOnLine)(related.location)), related.message);
    }
    static getSeverity(severity, type) {
        switch (severity) {
            case "ERROR":
                return vscode_1.DiagnosticSeverity.Error;
            case "WARNING":
                return vscode_1.DiagnosticSeverity.Warning;
            case "INFO":
                switch (type) {
                    case "TODO":
                        return vscode_1.DiagnosticSeverity.Information; // https://github.com/Microsoft/vscode/issues/48376
                    default:
                        return vscode_1.DiagnosticSeverity.Information;
                }
            default:
                throw new Error(`Unknown severity type: ${severity}`);
        }
    }
    static getTags(error) {
        const tags = [];
        if (error.code === "dead_code" || error.code === "unused_local_variable" || error.code === "unused_import")
            tags.push(vscode_1.DiagnosticTag.Unnecessary);
        if (error.code === "deprecated_member_use" || error.code === "deprecated_member_use_from_same_package")
            tags.push(vscode_1.DiagnosticTag.Deprecated);
        return tags;
    }
    flushResults(notification) {
        this.lastErrorJson = undefined;
        const entries = notification.files.map((file) => [vscode_1.Uri.file(file), undefined]);
        this.diagnostics.set(entries);
    }
}
exports.DartDiagnosticProvider = DartDiagnosticProvider;
class DartDiagnostic extends vscode_1.Diagnostic {
    type;
    constructor(range, message, severity, type) {
        super(range, message, severity);
        this.type = type;
    }
}
exports.DartDiagnostic = DartDiagnostic;


/***/ }),

/***/ 4067:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentSymbolProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const promises_1 = __webpack_require__(1902);
const utils_1 = __webpack_require__(1894);
const analyzer_das_1 = __webpack_require__(5476);
class DartDocumentSymbolProvider {
    logger;
    fileTracker;
    constructor(logger, fileTracker) {
        this.logger = logger;
        this.fileTracker = fileTracker;
    }
    async provideDocumentSymbols(document, token) {
        const outline = await (0, promises_1.waitFor)(() => this.fileTracker.getOutlineFor(document.uri), 500, 60000, token);
        if (token.isCancellationRequested || !outline || !outline.children || !outline.children.length)
            return;
        return outline.children.map((r) => this.convertResult(document, r));
    }
    convertResult(document, outline) {
        const name = outline.element.name
            ? outline.element.name
            : (outline.element.kind === "EXTENSION" ? "<unnamed extension>" : "<unnamed>");
        const location = outline.element.location || outline;
        const symbol = new vscode_1.DocumentSymbol(name, this.getDetail(outline.element), (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, outline.element.kind), this.getCodeOffset(document, outline), (0, utils_1.toRange)(document, location.offset, location.length));
        // eslint-disable-next-line no-bitwise
        if (outline.element.flags & 0x20)
            symbol.tags = [vscode_1.SymbolTag.Deprecated];
        if (outline.children && outline.children.length) {
            symbol.children = outline.children.filter(this.shouldShow).map((r) => this.convertResult(document, r));
        }
        return symbol;
    }
    shouldShow(outline) {
        // Don't show these (#656).
        if (outline.element.kind === "CONSTRUCTOR_INVOCATION" || outline.element.kind === "FUNCTION_INVOCATION")
            return false;
        return true;
    }
    getDetail(element) {
        let label = "";
        if (element.parameters)
            label += element.parameters;
        if (element.returnType)
            label += " → " + element.returnType;
        return label.trim();
    }
    getCodeOffset(document, outline) {
        return (0, utils_1.toRange)(document, outline.codeOffset || outline.offset, outline.codeLength || outline.length);
    }
}
exports.DartDocumentSymbolProvider = DartDocumentSymbolProvider;


/***/ }),

/***/ 1890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFoldingProvider = void 0;
const vscode_1 = __webpack_require__(1398);
class DartFoldingProvider {
    analyzer;
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    async provideFoldingRanges(document, context, token) {
        // Wait for any current analysis to complete (eg. if we've just opened a project it
        // may take a while to get the results).
        await this.analyzer.client.currentAnalysis;
        if (token && token.isCancellationRequested)
            return;
        // Wait up to another few seconds after analysis completed (it might be that we opened a new
        // file and there was no analysis, in which case we're just waiting for the server to process
        // the newly added subscription and send results).
        let foldingRegions;
        for (let i = 0; i < 5; i++) {
            foldingRegions = this.analyzer.fileTracker.getFoldingRegionsFor(document.uri);
            if (foldingRegions)
                break;
            await new Promise((resolve) => setTimeout(resolve, i * 1000).unref());
            if (token && token.isCancellationRequested)
                return;
        }
        if (token.isCancellationRequested || !foldingRegions)
            return;
        return foldingRegions.map((f) => new vscode_1.FoldingRange(document.positionAt(f.offset).line, document.positionAt(f.offset + f.length).line, this.getKind(f.kind)));
    }
    getKind(kind) {
        switch (kind) {
            case "FILE_HEADER":
            case "DOCUMENTATION_COMMENT":
                return vscode_1.FoldingRangeKind.Comment;
            case "DIRECTIVES":
                return vscode_1.FoldingRangeKind.Imports;
        }
    }
}
exports.DartFoldingProvider = DartFoldingProvider;


/***/ }),

/***/ 7777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFormattingEditProvider = void 0;
const minimatch_1 = __webpack_require__(8722);
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
class DartFormattingEditProvider {
    logger;
    analyzer;
    context;
    constructor(logger, analyzer, context) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.context = context;
        this.otherDisposables.push(vscode_1.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration("dart.enableSdkFormatter")) {
                if (config_1.config.enableSdkFormatter)
                    this.registerAllFormatters();
                else
                    this.unregisterAllFormatters();
            }
        }));
    }
    otherDisposables = [];
    registeredFormatters = [];
    formatterRegisterFuncs = [];
    registerDocumentFormatter(filter) {
        this.registerFormatter(() => vscode_1.languages.registerDocumentFormattingEditProvider(filter, this));
    }
    registerTypingFormatter(filter, firstTriggerCharacter, ...moreTriggerCharacters) {
        this.registerFormatter(() => vscode_1.languages.registerOnTypeFormattingEditProvider(filter, this, firstTriggerCharacter, ...moreTriggerCharacters));
    }
    registerFormatter(reg) {
        const registerAndTrack = () => this.registeredFormatters.push(reg());
        // Register the formatter immediately if enabled.
        if (config_1.config.enableSdkFormatter)
            registerAndTrack();
        // Add it to our list so we can re-register later..
        this.formatterRegisterFuncs.push(registerAndTrack);
    }
    registerAllFormatters() {
        for (const formatterReg of this.formatterRegisterFuncs) {
            formatterReg();
        }
    }
    unregisterAllFormatters() {
        (0, utils_1.disposeAll)(this.registeredFormatters);
    }
    async provideDocumentFormattingEdits(document, options, token) {
        try {
            return await this.doFormat(document, true); // await is important for catch to work.
        }
        catch {
            if (!this.context.hasWarnedAboutFormatterSyntaxLimitation) {
                this.context.hasWarnedAboutFormatterSyntaxLimitation = true;
                void vscode_1.window.showInformationMessage("The Dart formatter will not run if the file has syntax errors");
            }
            return undefined;
        }
    }
    async provideOnTypeFormattingEdits(document, position, ch, options, token) {
        try {
            return await this.doFormat(document, false);
        }
        catch {
            return undefined;
        }
    }
    async doFormat(document, doLogError = true) {
        if (!this.shouldFormat(document))
            return undefined;
        try {
            const resp = await this.analyzer.editFormat({
                file: (0, fs_1.fsPath)(document.uri),
                lineLength: config_1.config.for(document.uri).lineLength,
                selectionLength: 0,
                selectionOffset: 0,
            });
            if (resp.edits.length === 0)
                return undefined;
            else
                return resp.edits.map((e) => this.convertData(document, e));
        }
        catch (e) {
            if (doLogError)
                this.logger.error(e);
            throw e;
        }
    }
    shouldFormat(document) {
        if (!document || !document.uri || document.uri.scheme !== "file")
            return false;
        const resourceConf = config_1.config.for(document.uri);
        const path = (0, fs_1.fsPath)(document.uri);
        return undefined === resourceConf.doNotFormat.find((p) => (0, minimatch_1.minimatch)(path, p, { dot: true }));
    }
    convertData(document, edit) {
        return new vscode_1.TextEdit(new vscode_1.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length)), edit.replacement);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.otherDisposables);
        this.unregisterAllFormatters();
    }
}
exports.DartFormattingEditProvider = DartFormattingEditProvider;


/***/ }),

/***/ 5137:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentHighlightProvider = void 0;
const vscode_1 = __webpack_require__(1398);
class DartDocumentHighlightProvider {
    fileTracker;
    constructor(fileTracker) {
        this.fileTracker = fileTracker;
    }
    provideDocumentHighlights(document, position, token) {
        const offset = document.offsetAt(position);
        const occurrences = this.fileTracker.getOccurrencesFor(document.uri);
        if (!occurrences)
            return;
        for (const occurrence of occurrences) {
            // If an occurence spans our position, then we don't need to look at any others.
            if (occurrence.offsets.find((o) => o <= offset && o + occurrence.length >= offset)) {
                return occurrence.offsets.map((o) => new vscode_1.DocumentHighlight(new vscode_1.Range(document.positionAt(o), document.positionAt(o + occurrence.length))));
            }
        }
    }
}
exports.DartDocumentHighlightProvider = DartDocumentHighlightProvider;


/***/ }),

/***/ 6755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartHoverProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const extension_utils_1 = __webpack_require__(6584);
class DartHoverProvider {
    logger;
    analyzer;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    async provideHover(document, position, token) {
        try {
            const resp = await this.analyzer.analysisGetHover({
                file: (0, fs_1.fsPath)(document.uri),
                offset: document.offsetAt(position),
            });
            if (token.isCancellationRequested || resp.hovers.length === 0)
                return;
            const hover = resp.hovers[0];
            const data = this.getHoverData(document.uri, hover);
            if (!data)
                return;
            const range = new vscode_1.Range(document.positionAt(hover.offset), document.positionAt(hover.offset + hover.length));
            return new vscode_1.Hover([{ language: "dart", value: data.displayString }, data.documentation || undefined], range.isSingleLine ? range : undefined);
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    getHoverData(documentUri, hover) {
        if (!hover.elementDescription)
            return undefined;
        // Import prefix tooltips are not useful currently.
        // https://github.com/dart-lang/sdk/issues/32735
        if (hover.elementKind === "import prefix")
            return undefined;
        const elementDescription = hover.elementDescription;
        const dartdoc = hover.dartdoc;
        const propagatedType = hover.propagatedType;
        let displayString = "";
        if (elementDescription)
            displayString += (hover.isDeprecated ? "(deprecated) " : "") + `${elementDescription}\n`;
        if (propagatedType)
            displayString += `propagated type: ${propagatedType.trim()}`;
        let documentation = (0, extension_utils_1.cleanDartdoc)(dartdoc);
        const containingLibraryName = hover.containingLibraryName;
        if (containingLibraryName)
            documentation = `*${containingLibraryName}*\n\n` + documentation;
        return {
            displayString: displayString.trim(),
            documentation: documentation.trim(),
        };
    }
}
exports.DartHoverProvider = DartHoverProvider;


/***/ }),

/***/ 947:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartImplementationProvider = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const outline_1 = __webpack_require__(8693);
class DartImplementationProvider {
    analyzer;
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    async provideImplementation(document, position, token) {
        // Try to use the Outline data to snap our location to a node.
        // For example in:
        //
        //     void b();
        //
        // The search.getTypeHierarchy call will only work over "b" but by using outline we
        // can support the whole "void b();".
        const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position, true);
        const offset = outlineNode && outlineNode.element && outlineNode.element.location
            ? outlineNode.element.location.offset
            : document.offsetAt(position);
        const hierarchy = await this.analyzer.client.searchGetTypeHierarchy({
            file: (0, fs_1.fsPath)(document.uri),
            offset,
        });
        if (token.isCancellationRequested || !hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
            return;
        // Find the element we started with, since we only want implementations (not super classes).
        const currentItem = hierarchy.hierarchyItems.find((h) => {
            const elm = h.memberElement || h.classElement;
            return elm.location && elm.location.offset <= offset && elm.location.offset + elm.location.length >= offset;
        })
            // If we didn't find the element when we might have been at a call site, so we'll have to start
            // at the root.
            || hierarchy.hierarchyItems[0];
        const isClass = !currentItem.memberElement;
        function getDescendants(item) {
            return [
                ...item.subclasses.map((i) => hierarchy.hierarchyItems[i]),
                ...(0, utils_1.flatMap)(item.subclasses, (i) => getDescendants(hierarchy.hierarchyItems[i])),
            ];
        }
        const descendants = getDescendants(currentItem)
            .map((d) => isClass ? d.classElement : d.memberElement)
            .filter(utils_1.notUndefined);
        const locations = [];
        for (const element of descendants) {
            if (!element.location)
                continue;
            const range = (0, utils_2.toRange)(await vs.workspace.openTextDocument(element.location.file), element.location.offset, element.location.length);
            locations.push(new vs.Location(vs.Uri.file(element.location.file), range));
        }
        return locations;
    }
}
exports.DartImplementationProvider = DartImplementationProvider;


/***/ }),

/***/ 9138:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartLanguageConfiguration = void 0;
const vscode_1 = __webpack_require__(1398);
const config_1 = __webpack_require__(7678);
class DartLanguageConfiguration {
    doubleSlashRules = [
        {
            // Double-slash with space.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
            beforeText: /^\s*\/\/ /,
        },
        {
            // Double-slash without space.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
            beforeText: /^\s*\/\//,
        },
    ];
    // When double-slash is disabled, we still want to be able to add newlines
    // in existing comments and have them include the comment markers.
    betweenDoubleSlashRules = [
        {
            // Double-slash with space when there's already an existing space after
            // so we don't need to insert one.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
            afterText: / .*$/,
            beforeText: /^\s*\/\//,
        },
        {
            // Double-slash with space when there's not already an existing space after.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
            afterText: /[^ ]+$/,
            beforeText: /^\s*\/\/ /,
        },
        {
            // Double-slash without space.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
            afterText: /.+$/,
            beforeText: /^\s*\/\//,
        },
    ];
    tripleSlashRules = [
        {
            // Triple-slash with space.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "/// " },
            beforeText: /^\s*\/\/\/ /,
        },
        {
            // Triple-slash without space.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "///" },
            beforeText: /^\s*\/\/\//,
        },
    ];
    slashStarRules = [
        {
            // When between "/** | */" this puts a " * " in but also pushes the "*/" down to next line.
            action: { indentAction: vscode_1.IndentAction.IndentOutdent, appendText: " * " },
            afterText: /^\s*\*\/$/,
            beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
        },
        {
            // When after "/**" will put a " * " in (like above, but where there's no "*/" to push down).
            action: { indentAction: vscode_1.IndentAction.None, appendText: " * " },
            beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
        },
        {
            // Continue " * " when on a line already start with this.
            action: { indentAction: vscode_1.IndentAction.None, appendText: "* " },
            beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
        },
        {
            // After "*/" we need to remove the indent.
            action: { indentAction: vscode_1.IndentAction.None, removeText: 1 },
            beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
        },
    ];
    tripleQuoteRules = [
        {
            // Remove all indent after starting a multiline string.
            action: { indentAction: vscode_1.IndentAction.None, removeText: 80 },
            beforeText: /('''|""")$/,
        },
    ];
    get onEnterRules() {
        let rules = [];
        if (config_1.config.automaticCommentSlashes !== "none")
            rules = rules.concat(this.tripleSlashRules);
        if (config_1.config.automaticCommentSlashes === "all")
            rules = rules.concat(this.doubleSlashRules);
        else
            rules = rules.concat(this.betweenDoubleSlashRules);
        rules = rules.concat(this.slashStarRules);
        rules = rules.concat(this.tripleQuoteRules);
        return rules;
    }
}
exports.DartLanguageConfiguration = DartLanguageConfiguration;


/***/ }),

/***/ 2294:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartReferenceProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
class DartReferenceProvider {
    analyzer;
    fileTracker;
    constructor(analyzer, fileTracker) {
        this.analyzer = analyzer;
        this.fileTracker = fileTracker;
    }
    async provideReferences(document, position, context, token) {
        // If we want to include the decleration, kick off a request for that.
        const definitions = context.includeDeclaration
            ? await this.provideDefinition(document, position, token)
            : undefined;
        const resp = await this.analyzer.searchFindElementReferencesResults({
            file: (0, fs_1.fsPath)(document.uri),
            includePotential: true,
            offset: document.offsetAt(position),
        });
        if (token && token.isCancellationRequested)
            return;
        const locations = resp.results.map((result) => new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_2.toRangeOnLine)(result.location)));
        return definitions
            ? locations.concat(definitions.map((dl) => new vscode_1.Location(dl.targetUri, dl.targetRange)))
            : locations;
    }
    async provideDefinition(document, position, token) {
        let resp1 = this.fileTracker.getNavigationTargets((0, fs_1.fsPath)(document.uri), document.offsetAt(position));
        if (!resp1) {
            resp1 = await this.analyzer.analysisGetNavigation({
                file: (0, fs_1.fsPath)(document.uri),
                length: 0,
                offset: document.offsetAt(position),
            });
        }
        if (!resp1)
            return undefined;
        const resp = resp1;
        if (token && token.isCancellationRequested)
            return;
        const definitions = (0, utils_1.flatMap)(resp.regions, (region) => region.targets.map((targetIndex) => {
            const target = resp.targets[targetIndex];
            // HACK: We sometimes get a startColumn of 0 (should be 1-based). Just treat this as 1 for now.
            //     See https://github.com/Dart-Code/Dart-Code/issues/200
            if (target.startColumn === 0)
                target.startColumn = 1;
            return {
                originSelectionRange: (0, utils_2.toRange)(document, region.offset, region.length),
                targetRange: (0, utils_2.toRangeOnLine)(target),
                targetUri: vscode_1.Uri.file(resp.files[target.fileIndex]),
            };
        }));
        // For some locations (for example on the "var" keyword ), we'll get multiple results
        // where some of them are the location we invoked at, or the name of the variable. If
        // there are any results that are on a different line/different file to where we were
        // invoked, return only those. If the only results are on the same line of the same
        // file then just return them all.
        const definitionsOnOtherLines = definitions
            .filter((d) => (0, fs_1.fsPath)(d.targetUri) !== (0, fs_1.fsPath)(document.uri)
            || d.targetRange.start.line !== position.line);
        return definitionsOnOtherLines.length ? definitionsOnOtherLines : definitions;
    }
}
exports.DartReferenceProvider = DartReferenceProvider;


/***/ }),

/***/ 3523:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartRenameProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(1894);
const channels = __importStar(__webpack_require__(269));
class DartRenameProvider {
    analyzer;
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideRenameEdits(document, position, newName, token) {
        return this.doRename(document, position, newName, token);
    }
    prepareRename(document, position, token) {
        return this.getLocation(document, position, token);
    }
    async doRename(document, position, newName, token) {
        const outputChannel = channels.getOutputChannel("Refactorings");
        outputChannel.appendLine("");
        const resp = await this.analyzer.editGetRefactoring({
            file: (0, fs_1.fsPath)(document.uri),
            kind: "RENAME",
            length: 1,
            offset: document.offsetAt(position),
            options: {
                newName,
            },
            validateOnly: false,
        });
        if (token && token.isCancellationRequested) {
            outputChannel.appendLine("[INFO] Rename cancelled.");
            return;
        }
        const workspaceEdit = new vscode_1.WorkspaceEdit();
        if (resp.change && resp.change.message)
            outputChannel.appendLine(`[INFO] ${resp.change.message}…`);
        this.handleProblem(resp.initialProblems
            .concat(resp.optionsProblems)
            .concat(resp.finalProblems), outputChannel);
        const promises = [];
        if (resp.change) {
            resp.change.edits.forEach((changeEdit) => {
                changeEdit.edits.forEach((fileEdit) => {
                    const uri = vscode_1.Uri.file(changeEdit.file);
                    const promise = vscode_1.workspace.openTextDocument(uri);
                    promises.push(promise.then((document) => workspaceEdit.replace(uri, new vscode_1.Range(document.positionAt(fileEdit.offset), document.positionAt(fileEdit.offset + fileEdit.length)), fileEdit.replacement)));
                });
            });
        }
        // TODO: This class is inconsistent with other refactors (which are silent when they work, for ex).
        // We should review what we can extract share (though note that this method must return the edit whereas
        // the other refactors apply them).
        // Wait all openTextDocument to finish
        await Promise.all(promises);
        if (token && token.isCancellationRequested) {
            outputChannel.appendLine("[INFO] Rename cancelled.");
            return;
        }
        outputChannel.appendLine("[INFO] Rename successful.");
        return workspaceEdit;
    }
    handleProblem(problems, outputChannel) {
        // Log all in output channel.
        problems.forEach((problem) => outputChannel.appendLine(`[${problem.severity}] ${problem.message}`));
        const errors = problems
            .filter((p) => p.severity !== "INFO" && p.severity !== "WARNING")
            .sort((p1, p2) => p2.severity.localeCompare(p1.severity));
        if (errors.length !== 0) {
            outputChannel.appendLine("[INFO] Rename aborted.");
            throw errors[0].message;
        }
    }
    async getLocation(document, position, token) {
        const resp = await this.analyzer.editGetRefactoring({
            file: (0, fs_1.fsPath)(document.uri),
            kind: "RENAME",
            length: 0,
            offset: document.offsetAt(position),
            validateOnly: true,
        });
        if (token && token.isCancellationRequested)
            return;
        if (!resp.feedback)
            throw new Error("You cannot rename this element.");
        const feedback = resp.feedback;
        // The dart server returns -1 when the old name doesn't exist (for ex. renaming an unprefixed import to add a prefix)
        // so we use a zero-character range at the requested position in this case.
        const range = feedback.offset === -1
            ? new vscode_1.Range(position, position)
            : (0, utils_1.toRange)(document, feedback.offset, feedback.length);
        if (feedback) {
            return {
                placeholder: feedback.oldName,
                range,
            };
        }
        else {
            const fatalProblems = resp.initialProblems
                .concat(resp.optionsProblems)
                .concat(resp.finalProblems)
                .filter((p) => p.severity === "FATAL");
            if (fatalProblems && fatalProblems.length) {
                throw new Error(fatalProblems[0].message);
            }
            else {
                throw new Error("This rename is not supported.");
            }
        }
    }
}
exports.DartRenameProvider = DartRenameProvider;


/***/ }),

/***/ 3157:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartSignatureHelpProvider = void 0;
const vs = __importStar(__webpack_require__(1398));
const fs_1 = __webpack_require__(2587);
const extension_utils_1 = __webpack_require__(6584);
class DartSignatureHelpProvider {
    analyzer;
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    async provideSignatureHelp(document, position, token) {
        try {
            const resp = await this.analyzer.analysisGetSignature({
                file: (0, fs_1.fsPath)(document.uri),
                offset: document.offsetAt(position),
            });
            if (token && token.isCancellationRequested)
                return undefined;
            const sig = new vs.SignatureInformation(this.getSignatureLabel(resp), (0, extension_utils_1.createMarkdownString)((0, extension_utils_1.cleanDartdoc)(resp.dartdoc)));
            sig.parameters = resp.parameters.map((p) => new vs.ParameterInformation(this.getLabel(p)));
            const sigs = new vs.SignatureHelp();
            sigs.signatures = [sig];
            sigs.activeSignature = 0;
            // TODO: This isn't implemented in the server yet.
            sigs.activeParameter = -1; // resp.selectedParameterIndex;
            return sigs;
        }
        catch {
            return undefined;
        }
    }
    getSignatureLabel(resp) {
        const req = resp.parameters.filter((p) => p.kind === "REQUIRED" || p.kind === "REQUIRED_POSITIONAL");
        const opt = resp.parameters.filter((p) => p.kind === "OPTIONAL" || p.kind === "OPTIONAL_POSITIONAL");
        const named = resp.parameters.filter((p) => p.kind === "NAMED" || p.kind === "OPTIONAL_NAMED" || p.kind === "REQUIRED_NAMED");
        const params = [];
        if (req.length)
            params.push(req.map(this.getLabel).join(", "));
        if (opt.length)
            params.push("[" + opt.map(this.getLabel).join(", ") + "]");
        if (named.length)
            params.push("{" + named.map(this.getLabel).join(", ") + "}");
        return `${resp.name}(${params.join(", ")})`;
    }
    getLabel(p) {
        const def = p.defaultValue
            ? ` = ${p.defaultValue}`
            : "";
        const prefix = p.kind === "REQUIRED_NAMED" ? "required " : "";
        return `${prefix}${p.type} ${p.name}${def}`;
    }
}
exports.DartSignatureHelpProvider = DartSignatureHelpProvider;


/***/ }),

/***/ 3847:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartWorkspaceSymbolProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(1894);
const analyzer_das_1 = __webpack_require__(5476);
class DartWorkspaceSymbolProvider {
    logger;
    analyzer;
    dartCapabilities;
    badChars = new RegExp("[^0-9a-z\-]", "gi");
    constructor(logger, analyzer, dartCapabilities) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.dartCapabilities = dartCapabilities;
    }
    async provideWorkspaceSymbols(query, token) {
        if (query.length === 0)
            return undefined;
        // Turn query into a case-insensitive fuzzy search.
        const pattern = this.dartCapabilities.workspaceSymbolSearchUsesFuzzy
            ? query.replace(this.badChars, "")
            : ".*" + query.replace(this.badChars, "").split("").map((c) => `[${c.toUpperCase()}${c.toLowerCase()}]`).join(".*") + ".*";
        const results = await this.analyzer.searchGetElementDeclarations({ pattern, maxResults: 500 });
        if (token && token.isCancellationRequested)
            return;
        return results.declarations.map((d) => this.convertWorkspaceResult(d, results.files[d.fileIndex]));
    }
    async resolveWorkspaceSymbol(symbol, token) {
        if (!(symbol instanceof PartialSymbolInformation))
            return undefined;
        const document = await vscode_1.workspace.openTextDocument(vscode_1.Uri.file(symbol.locationData.file));
        symbol.location = new vscode_1.Location(document.uri, (0, utils_1.toRange)(document, symbol.locationData.offset, symbol.locationData.length));
        return symbol;
    }
    convertWorkspaceResult(result, file) {
        const nameSuffix = result.parameters ? (result.parameters === "()" ? "()" : "(…)") : "";
        const symbol = new PartialSymbolInformation(result.name + nameSuffix, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.kind), result.className || "", 
        // HACK: Work around the incorrect typing in VS Code with !
        // https://github.com/microsoft/vscode/issues/69558
        new vscode_1.Location(vscode_1.Uri.file(file), undefined), {
            file,
            length: result.codeLength,
            // Fall back to offset when the server gives us a bad codeOffset
            // https://github.com/dart-lang/sdk/issues/39192.
            offset: result.codeOffset || result.offset,
        });
        return symbol;
    }
}
exports.DartWorkspaceSymbolProvider = DartWorkspaceSymbolProvider;
class PartialSymbolInformation extends vscode_1.SymbolInformation {
    locationData;
    constructor(name, kind, containerName, location, locationData) {
        super(name, kind, containerName, location);
        this.locationData = locationData;
    }
}


/***/ }),

/***/ 687:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterDescriptorFactory = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const debug_1 = __webpack_require__(2125);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const processes_1 = __webpack_require__(8141);
class DartDebugAdapterDescriptorFactory {
    analytics;
    sdks;
    logger;
    extensionContext;
    dartCapabilities;
    flutterCapabilities;
    workspaceContext;
    experiments;
    constructor(analytics, sdks, logger, extensionContext, dartCapabilities, flutterCapabilities, workspaceContext, experiments) {
        this.analytics = analytics;
        this.sdks = sdks;
        this.logger = logger;
        this.extensionContext = extensionContext;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.workspaceContext = workspaceContext;
        this.experiments = experiments;
    }
    createDebugAdapterDescriptor(session, executable) {
        return this.descriptorForType(session.configuration.debuggerType, !!session.configuration.noDebug);
    }
    descriptorForType(debuggerType, noDebug) {
        const debuggerName = (0, debug_1.getDebugAdapterName)(debuggerType);
        this.logger.info(`Using ${debuggerName} debugger for ${enums_1.DebuggerType[debuggerType]}`);
        const isDartOrDartTest = debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.DartTest;
        const isFlutterOrFlutterTest = debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.FlutterTest;
        const isDartTestOrFlutterTest = debuggerType === enums_1.DebuggerType.DartTest || debuggerType === enums_1.DebuggerType.FlutterTest;
        const isDartTest = debuggerType === enums_1.DebuggerType.DartTest;
        const isFlutterTest = debuggerType === enums_1.DebuggerType.FlutterTest;
        let isSdkDapSupported = false;
        let canDefaultToSdkDap = false;
        let isPreReleaseSdk = false;
        let isInSdkDapExperiment = false;
        if (isDartOrDartTest) {
            isSdkDapSupported = this.dartCapabilities.supportsSdkDap;
            canDefaultToSdkDap = this.dartCapabilities.canDefaultSdkDaps;
            isPreReleaseSdk = this.dartCapabilities.version.includes("-");
            isInSdkDapExperiment = this.experiments.dartSdkDaps.applies;
        }
        else if (isFlutterOrFlutterTest) {
            isSdkDapSupported = this.flutterCapabilities.supportsSdkDap;
            canDefaultToSdkDap = this.flutterCapabilities.canDefaultSdkDaps;
            isPreReleaseSdk = this.flutterCapabilities.version.includes("-");
            isInSdkDapExperiment = this.flutterCapabilities.useLegacyDapExperiment
                ? this.experiments.flutterSdkDapsLegacy.applies
                : this.experiments.flutterSdkDaps.applies;
        }
        const forceSdkDap = process.env.DART_CODE_FORCE_SDK_DAP === "true"
            ? true
            : process.env.DART_CODE_FORCE_SDK_DAP === "false"
                ? false
                : undefined;
        let useSdkDap;
        let sdkDapReason;
        if (forceSdkDap !== undefined) {
            useSdkDap = forceSdkDap;
            sdkDapReason = "DART_CODE_FORCE_SDK_DAP env variable";
        }
        else {
            if (!isSdkDapSupported) {
                useSdkDap = false;
                sdkDapReason = "not supported for SDK";
            }
            else if (this.workspaceContext.config.forceFlutterWorkspace) {
                useSdkDap = true;
                sdkDapReason = "workspaceContext.config.forceFlutterWorkspace";
            }
            else if (config_1.config.useLegacyDebugAdapters !== undefined) {
                useSdkDap = !config_1.config.useLegacyDebugAdapters;
                sdkDapReason = "config.useLegacyDebugAdapters";
            }
            else if (canDefaultToSdkDap && isPreReleaseSdk) {
                useSdkDap = true;
                sdkDapReason = "canDefaultToSdkDap and using pre-release SDK";
            }
            else {
                useSdkDap = isInSdkDapExperiment;
                sdkDapReason = "sdkDaps experiment";
                if (useSdkDap && !canDefaultToSdkDap) {
                    useSdkDap = false;
                    sdkDapReason = "sdkDaps experiment overriden by canDefaultSdkDaps";
                }
            }
        }
        this.logger.info(`SDK DAP setting is ${useSdkDap}, set by ${sdkDapReason}`);
        const analytics = this.analytics;
        function logDebuggerStart(sdkDap) {
            analytics.logDebuggerStart(enums_1.DebuggerType[debuggerType], noDebug ? "Run" : "Debug", sdkDap);
        }
        const toolEnv = (0, processes_1.getToolEnv)();
        // If FLUTTER_ROOT hasn't been set explicitly and any of our open workspace are in the Flutter SDK we're using, then
        // set that SDK path as FLUTTER_ROOT.
        const flutterSdk = this.sdks.flutter;
        if (!process.env.FLUTTER_ROOT && !toolEnv.FLUTTER_ROOT && flutterSdk) {
            const openFlutterSdkFolders = (0, utils_1.getDartWorkspaceFolders)()?.find((wf) => (0, fs_1.isWithinPathOrEqual)((0, fs_1.fsPath)(wf.uri), flutterSdk));
            if (openFlutterSdkFolders)
                toolEnv.FLUTTER_ROOT = flutterSdk;
        }
        const executableOptions = {
            env: toolEnv,
        };
        if (config_1.config.customDartDapPath && isDartOrDartTest) {
            const args = [config_1.config.customDartDapPath, "debug_adapter"];
            if (isDartTest)
                args.push("--test");
            this.logger.info(`Running custom Dart debugger using Dart VM with args ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args, executableOptions);
        }
        else if (config_1.config.customFlutterDapPath && isFlutterOrFlutterTest) {
            const args = [config_1.config.customFlutterDapPath, "debug_adapter"];
            if (isFlutterTest)
                args.push("--test");
            if (isFlutterTest && this.flutterCapabilities.requiresDdsDisabledForSdkDapTestRuns)
                args.push("--no-dds");
            this.logger.info(`Running custom Flutter debugger using Dart VM with args ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args, executableOptions);
        }
        else if (useSdkDap) {
            const executable = isDartOrDartTest
                ? path.join(this.sdks.dart, constants_1.dartVMPath)
                : this.workspaceContext.config.flutterToolsScript?.script ?? (this.sdks.flutter ? path.join(this.sdks.flutter, constants_1.flutterPath) : constants_1.executableNames.flutter);
            const args = ["debug_adapter"];
            if (isDartTestOrFlutterTest)
                args.push("--test");
            if (isFlutterTest && this.flutterCapabilities.requiresDdsDisabledForSdkDapTestRuns)
                args.push("--no-dds");
            if (this.workspaceContext.config.flutterSdkHome)
                executableOptions.cwd = this.workspaceContext.config.flutterSdkHome;
            this.logger.info(`Running SDK DAP Dart VM in ${executableOptions.cwd}: ${executable} ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            logDebuggerStart(true);
            return new vscode_1.DebugAdapterExecutable(executable, args, executableOptions);
        }
        if (process.env.DART_CODE_USE_DEBUG_SERVERS) {
            const port = (0, debug_1.getDebugAdapterPort)(debuggerName);
            this.logger.info(`Running debugger in server mode on port ${port} because DART_CODE_USE_DEBUG_SERVERS is set`);
            return new vscode_1.DebugAdapterServer(port);
        }
        const args = [this.extensionContext.asAbsolutePath(constants_1.debugAdapterPath), debuggerName];
        this.logger.info(`Running debugger via node with ${args.join("    ")}`);
        logDebuggerStart(false);
        return new vscode_1.DebugAdapterExecutable("node", args);
    }
}
exports.DartDebugAdapterDescriptorFactory = DartDebugAdapterDescriptorFactory;


/***/ }),

/***/ 7966:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugForcedAnsiColorSupportFactory = void 0;
/**
 * Forces `supportsANSIStyling` on in the server capabilities because VS Code now requires this and
 * it will take a while for the change to ship in the SDK adapters.
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/5302 and https://github.com/microsoft/vscode/pull/227729.
 */
class DartDebugForcedAnsiColorSupportFactory {
    createDebugAdapterTracker(session) {
        return new DartDebugForcedAnsiColorSupport();
    }
}
exports.DartDebugForcedAnsiColorSupportFactory = DartDebugForcedAnsiColorSupportFactory;
/**
 * Forces `supportsANSIStyling` on in the server capabilities because VS Code now requires this and
 * it will take a while for the change to ship in the SDK adapters.
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/5302 and https://github.com/microsoft/vscode/pull/227729.
 */
class DartDebugForcedAnsiColorSupport {
    onDidSendMessage(message) {
        if (message && message.command === "initialize" && message.type === "response" && message.body && message.body.supportsANSIStyling === undefined)
            message.body.supportsANSIStyling = true;
    }
}


/***/ }),

/***/ 2011:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugForcedDebugModeFactory = void 0;
/**
 * Forces debug mode in the launchRequest if the 'forceDisableDebugging' flag was set by the debug config provider.
 *
 * This enables functionality like the widget inspectors ToolEvent navigation.
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/4878.
 */
class DartDebugForcedDebugModeFactory {
    createDebugAdapterTracker(session) {
        // Only set up the forced debug mode if this magic flag was set (in debug_config_provider).
        // Checking capabilities etc. is done there, not here.
        if (session.configuration.forceEnableDebugging) {
            return new DartDebugForcedDebugMode();
        }
        return undefined;
    }
}
exports.DartDebugForcedDebugModeFactory = DartDebugForcedDebugModeFactory;
/**
 * Forces debug mode in the launchRequest so that the debug adapter sets up a connection to the VM Service.
 *
 * This enables functionality like the widget inspectors ToolEvent navigation.
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/4878.
 */
class DartDebugForcedDebugMode {
    onWillReceiveMessage(message) {
        if (message.command === "launch") {
            message.arguments.noDebug = undefined;
        }
    }
}


/***/ }),

/***/ 1836:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugForcedSingleThreadFactory = void 0;
/**
 * Forces `allThreadsContinued=false` on `continued` events and `allThreadsStopped=false` on `stopped` events
 * as a workaround until shipped in the DA (and then for older SDK versions!).
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/5252 and https://github.com/microsoft/vscode/issues/224832.
 */
class DartDebugForcedSingleThreadFactory {
    createDebugAdapterTracker(session) {
        return new DartDebugForcedSingleThread();
    }
}
exports.DartDebugForcedSingleThreadFactory = DartDebugForcedSingleThreadFactory;
/**
 * Forces `allThreadsContinued=false` on `continued` events and `allThreadsStopped=false` on `stopped` events
 * as a workaround until shipped in the DA (and then for older SDK versions!).
 *
 * See https://github.com/Dart-Code/Dart-Code/issues/5252 and https://github.com/microsoft/vscode/issues/224832.
 */
class DartDebugForcedSingleThread {
    onDidSendMessage(message) {
        if (message && message.type === "event" && message.body) {
            if (message.event === "continued" && message.body.allThreadsContinued === undefined)
                message.body.allThreadsContinued = false;
            if (message.event === "stopped" && message.body.allThreadsStopped === undefined)
                message.body.allThreadsStopped = false;
        }
    }
}


/***/ }),

/***/ 8652:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterGlobalEvaluationContextFactory = void 0;
const fs_1 = __webpack_require__(2587);
const editors_1 = __webpack_require__(9451);
class DartDebugAdapterGlobalEvaluationContextFactory {
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterGlobalEvaluationContext();
    }
}
exports.DartDebugAdapterGlobalEvaluationContextFactory = DartDebugAdapterGlobalEvaluationContextFactory;
class DartDebugAdapterGlobalEvaluationContext {
    onWillReceiveMessage(message) {
        if (message.command === "evaluate" && message.arguments?.context === "repl") {
            const doc = (0, editors_1.getActiveRealFileEditor)()?.document;
            if (doc && (0, editors_1.isDartDocument)(doc)) {
                // Don't escape colons in drive letters, as the shipped DAP code here
                // will call `lookupPackageUris` on this URI and it won't match. Also normalize
                // the drive letter because otherwise it might not work for Windows -> Android
                // (see https://github.com/Dart-Code/Dart-Code/issues/5237).
                message.arguments.context = (0, fs_1.forceWindowsDriveLetterToUppercaseInUriString)(doc.uri.toString(true));
            }
        }
    }
}


/***/ }),

/***/ 5985:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterHexViewFactory = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_contexts_1 = __webpack_require__(4471);
const utils_1 = __webpack_require__(949);
const config_1 = __webpack_require__(7678);
class DartDebugAdapterHexViewFactory {
    logger;
    disposables = [];
    hexFormatters = new Set();
    supportsFormatting = false;
    constructor(logger) {
        this.logger = logger;
        this.disposables.push(vs.workspace.onDidChangeConfiguration(this.handleConfigChange, this));
        this.disposables.push(vs.commands.registerCommand("_dart.showDebuggerNumbersAsHex", () => this.setFormatHex(true)));
        this.disposables.push(vs.commands.registerCommand("_dart.showDebuggerNumbersAsDecimal", () => this.setFormatHex(false)));
    }
    createDebugAdapterTracker(session) {
        const hexFormatter = new DartDebugAdapterHexView(this, this.logger, session);
        this.hexFormatters.add(hexFormatter);
        return hexFormatter;
    }
    async handleConfigChange(conf) {
        if (conf.affectsConfiguration("dart.showDebuggerNumbersAsHex")) {
            if (this.supportsFormatting) {
                await this.invalidateAll();
            }
        }
    }
    async setFormatHex(enabled) {
        await config_1.config.setShowDebuggerNumbersAsHex(enabled ? true : undefined);
        await this.invalidateAll();
    }
    async invalidateAll() {
        await Promise.all([...this.hexFormatters].map((formatter) => formatter.invalidate()));
    }
    dispose() {
        this.hexFormatters.clear();
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartDebugAdapterHexViewFactory = DartDebugAdapterHexViewFactory;
class DartDebugAdapterHexView {
    factory;
    logger;
    session;
    constructor(factory, logger, session) {
        this.factory = factory;
        this.logger = logger;
        this.session = session;
    }
    async invalidate() {
        try {
            await this.session.customRequest("_invalidateAreas", { areas: ["variables"] });
        }
        catch (e) {
            this.logger.error(e);
        }
    }
    onExit(code, signal) {
        this.factory.hexFormatters.delete(this);
    }
    onDidSendMessage(message) {
        if (!this.factory.supportsFormatting && message?.command === "initialize" && message?.body?.supportsValueFormattingOptions) {
            this.factory.supportsFormatting = true;
            void vs.commands.executeCommand("setContext", constants_contexts_1.SUPPORTS_DEBUG_VALUE_FORMAT, true);
        }
    }
    onWillReceiveMessage(message) {
        if (this.factory.supportsFormatting && (message.command === "evaluate" || message.command === "variables")) {
            message.arguments ??= {};
            message.arguments.format ??= {};
            // Don't override if we happen to be a future version of VS Code that supports this.
            if (message.arguments.format.hex === undefined) {
                message.arguments.format.hex = config_1.config.showDebuggerNumbersAsHex;
            }
        }
    }
}


/***/ }),

/***/ 5196:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterLaunchStatusFactory = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
class DartDebugAdapterLaunchStatusFactory {
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterLaunchStatus();
    }
}
exports.DartDebugAdapterLaunchStatusFactory = DartDebugAdapterLaunchStatusFactory;
class DartDebugAdapterLaunchStatus {
    completer = new utils_1.PromiseCompleter();
    startProgress() {
        void vscode_1.window.withProgress({
            cancellable: false,
            location: vscode_1.ProgressLocation.Notification,
            title: "Starting debug session…",
        }, () => this.completer.promise);
    }
    endProgress() {
        this.completer.resolve();
    }
    onWillStartSession() {
        this.startProgress();
    }
    onDidSendMessage(message) {
        this.endProgress();
    }
    onWillStopSession() {
        this.endProgress();
    }
    onExit(code, signal) {
        this.endProgress();
    }
}


/***/ }),

/***/ 166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterLoggerFactory = void 0;
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const config_1 = __webpack_require__(7678);
const utils_1 = __webpack_require__(279);
const log_1 = __webpack_require__(7962);
class DartDebugAdapterLoggerFactory {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterLogger(this.logger, session);
    }
}
exports.DartDebugAdapterLoggerFactory = DartDebugAdapterLoggerFactory;
class DartDebugAdapterLogger {
    emittingLogger;
    session;
    logger;
    logFileDisposable;
    constructor(emittingLogger, session) {
        this.emittingLogger = emittingLogger;
        this.session = session;
        this.logger = new logging_1.CategoryLogger(emittingLogger, enums_1.LogCategory.DAP);
    }
    onWillStartSession() {
        let dapLogFile = (0, utils_1.insertSessionName)(this.session.configuration, config_1.config.dapLogFile);
        if (dapLogFile) {
            const debuggerType = this.session.configuration.debuggerType;
            let debuggerTypeName = debuggerType !== undefined ? enums_1.DebuggerType[debuggerType].toLowerCase() : "unknown";
            debuggerTypeName = debuggerTypeName.replaceAll("test", "_test");
            dapLogFile = dapLogFile.replaceAll("${kind}", debuggerTypeName);
            this.logFileDisposable = (0, logging_1.captureLogs)(this.emittingLogger, dapLogFile, (0, log_1.getLogHeader)(), config_1.config.maxLogLineLength, [enums_1.LogCategory.DAP]);
        }
        this.logger.info(`Starting debug session ${this.session.id}`);
    }
    onWillReceiveMessage(message) {
        this.logger.info(`==> ${JSON.stringify(message)}`);
    }
    onDidSendMessage(message) {
        this.logger.info(`<== ${JSON.stringify(message)}`);
    }
    onWillStopSession() {
        this.logger.info(`Stopping debug session ${this.session.id}`);
    }
    onError(error) {
        // We log this as info, as this isn't the place to handle errors and it seems to fire
        // whenever a debug session stops because the process stream goes away.
        this.logger.info(`Debug session ${this.session.id} errored: ${JSON.stringify(error)}`);
    }
    onExit(code, signal) {
        this.logger.info(`Debug session ${this.session.id} exit: code: ${code}, signal: ${signal}`);
        void this.logFileDisposable?.dispose();
        this.logFileDisposable = undefined;
    }
}


/***/ }),

/***/ 9154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterRemoveErrorShowUserFactory = void 0;
class DartDebugAdapterRemoveErrorShowUserFactory {
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterRemoveErrorShowUser();
    }
}
exports.DartDebugAdapterRemoveErrorShowUserFactory = DartDebugAdapterRemoveErrorShowUserFactory;
class DartDebugAdapterRemoveErrorShowUser {
    onDidSendMessage(message) {
        // Strip any showUser flags so that we use the VS Code default. The behaviour of this
        // flag is not currently well defined and the DAP is sending showUser=true but that
        // can result in additional prompts to users:
        // - https://github.com/Dart-Code/Dart-Code/issues/4930
        // - https://github.com/google/go-dap/issues/87
        // - https://github.com/microsoft/vscode/issues/180488
        if (message?.success === false && message?.body?.error && message?.body?.error?.showUser !== undefined) {
            message.body.error.showUser = undefined;
        }
    }
}


/***/ }),

/***/ 5129:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterSupportsUrisFactory = void 0;
class DartDebugAdapterSupportsUrisFactory {
    dartCapabilities;
    constructor(dartCapabilities) {
        this.dartCapabilities = dartCapabilities;
    }
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterSupportsUris(this.dartCapabilities);
    }
}
exports.DartDebugAdapterSupportsUrisFactory = DartDebugAdapterSupportsUrisFactory;
class DartDebugAdapterSupportsUris {
    dartCapabilities;
    constructor(dartCapabilities) {
        this.dartCapabilities = dartCapabilities;
    }
    onWillReceiveMessage(message) {
        if (message?.command === "initialize" && message.arguments && this.dartCapabilities.supportsMacroGeneratedFiles) {
            message.arguments.supportsDartUris = true;
        }
    }
}


/***/ }),

/***/ 4905:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDebugConfigProvider = exports.InitialLaunchJsonDebugConfigProvider = exports.DebugConfigProvider = void 0;
/* eslint-disable @typescript-eslint/tslint/config */
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const constants_contexts_1 = __webpack_require__(4471);
const enums_1 = __webpack_require__(3962);
const utils_1 = __webpack_require__(3960);
const version_1 = __webpack_require__(7149);
const utils_2 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const test_1 = __webpack_require__(672);
const utils_3 = __webpack_require__(1894);
const debug_1 = __webpack_require__(394);
const logging_1 = __webpack_require__(6444);
const config_1 = __webpack_require__(7678);
const editors_1 = __webpack_require__(9451);
const project_1 = __webpack_require__(5143);
const webdev_1 = __webpack_require__(6205);
const utils_4 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
class DebugConfigProvider {
    logger;
    wsContext;
    pubGlobal;
    testModel;
    daemon;
    deviceManager;
    devTools;
    flutterCapabilities;
    constructor(logger, wsContext, pubGlobal, testModel, daemon, deviceManager, devTools, flutterCapabilities) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.pubGlobal = pubGlobal;
        this.testModel = testModel;
        this.daemon = daemon;
        this.deviceManager = deviceManager;
        this.devTools = devTools;
        this.flutterCapabilities = flutterCapabilities;
    }
    resolveDebugConfiguration(folder, debugConfig, token) {
        (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
        debugConfig.type = debugConfig.type || "dart";
        debugConfig.request = debugConfig.request || "launch";
        return debugConfig;
    }
    warnOnUnresolvedVariables(property, input) {
        if (!input)
            return false;
        const v = this.getUnresolvedVariable(input);
        if (v) {
            this.logger.error(`Launch config property '${property}' has unresolvable variable ${v}`);
            void vscode_1.window.showErrorMessage(`Launch config property '${property}' has unresolvable variable ${v}`);
            return true;
        }
        return false;
    }
    /** Gets the first unresolved variable from the given string. */
    getUnresolvedVariable(input) {
        if (!input)
            return undefined;
        const matches = /\${\w+}/.exec(input);
        return matches ? matches[0] : undefined;
    }
    async resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfig, token) {
        (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
        const isAttachRequest = debugConfig.request === "attach";
        const logger = this.logger;
        const editor = (0, editors_1.getActiveRealFileEditor)();
        const openFile = editor
            ? (0, fs_1.fsPath)(editor.document.uri)
            : undefined;
        logger.info(`Starting debug session...`);
        if (folder)
            logger.info(`    workspace: ${(0, fs_1.fsPath)(folder.uri)}`);
        if (debugConfig.program)
            logger.info(`    program  : ${debugConfig.program}`);
        if (debugConfig.cwd)
            logger.info(`    cwd      : ${debugConfig.cwd}`);
        // Split off any querystring from program because there's a lot of path
        // manipulation that may not handle it. We'll put it back on at the end.
        debugConfig.programQuery = debugConfig.program?.includes("?") ? "?" + debugConfig.program.split("?")[1] : undefined;
        debugConfig.program = debugConfig.program ? (0, test_1.getProgramPath)(debugConfig.program) : undefined;
        if (this.warnOnUnresolvedVariables("program", debugConfig.program) || this.warnOnUnresolvedVariables("cwd", debugConfig.cwd)) {
            // Warning is shown from inside warnOnUnresolvedVariables.
            return null; // null means open launch.json.
        }
        this.configureProgramAndCwd(debugConfig, folder, openFile);
        // If we still don't have an entry point, the user will have to provide it.
        if (!isAttachRequest && !debugConfig.program) {
            this.logger.warn("No program was set in launch config");
            const exampleEntryPoint = this.wsContext.hasAnyFlutterProjects ? "lib/main.dart" : "bin/main.dart";
            void vscode_1.window.showInformationMessage(`Set the 'program' value in your launch config (eg '${exampleEntryPoint}') then launch again`);
            return null; // null means open launch.json.
        }
        const argsHaveTestFilter = (!!debugConfig.programQuery) || (0, utils_4.hasTestFilter)((debugConfig.toolArgs ?? []).concat(debugConfig.args ?? []));
        const isTest = !!debugConfig.program && (0, utils_4.isTestFileOrFolder)(debugConfig.program);
        const debugType = this.selectDebuggerType(debugConfig, argsHaveTestFilter, isTest, logger);
        const isFlutter = debugType === enums_1.DebuggerType.Flutter || debugType === enums_1.DebuggerType.FlutterTest;
        const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
        // Handle detecting a Flutter app, but the extension has loaded in Dart-only mode.
        if (isFlutter && !this.wsContext.hasAnyFlutterProjects) {
            this.logger.warn("Tried to launch Flutter project in non-Flutter workspace");
            void vscode_1.window.showErrorMessage(`Unable to launch Flutter project in a Dart-only workspace. Please open a folder closer to your Flutter project root or increase the value of the "dart.projectSearchDepth" setting.`);
            return undefined; // undefined means abort
        }
        // Handle test_driver tests that can be pointed at an existing running instrumented app.
        if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "test_driver") && !debugConfig.env?.VM_SERVICE_URL) {
            const runningInstrumentedApps = debug_1.debugSessions.filter((s) => s.loadedServiceExtensions.includes(enums_1.VmServiceExtension.Driver));
            if (runningInstrumentedApps.length === 0) {
                return this.errorWithoutOpeningLaunchConfig("Could not find a running Flutter app that was instrumented with enableFlutterDriverExtension. Run your instrumented app before running driver tests.");
            }
            else if (runningInstrumentedApps.length > 1) {
                return this.errorWithoutOpeningLaunchConfig("More than one Flutter app instrumented with enableFlutterDriverExtension is running. Please run only one app before running driver tests.");
            }
            else {
                const app = runningInstrumentedApps[0];
                // This shouldn't really be possible as we wouldn't find an instrumented app without having its VM Service connection.
                if (!app.vmServiceUri)
                    return this.errorWithoutOpeningLaunchConfig("The Flutter app instrumented with enableFlutterDriverExtension is not fully initialised yet.");
                // Restart the app for clean state before the test run.
                await app.session.customRequest("hotRestart");
                debugConfig.env = debugConfig.env || {};
                debugConfig.env.VM_SERVICE_URL = app.vmServiceUri;
            }
        }
        if (debugType === enums_1.DebuggerType.WebTest) {
            // TODO: IMPORTANT! When removing this if statement, add WebTest to
            // the call to TestResultsProvider.flagSuiteStart below!
            logger.error("Tests in web projects are not currently supported");
            void vscode_1.window.showErrorMessage("Tests in web projects are not currently supported");
            return undefined; // undefined means silent (don't open launch.json).
        }
        if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isTestFolder)(debugConfig.program) && !debugConfig.noDebug) {
            // When running `flutter test (folder)`, multiple debug sessions are created - one for each file. This is
            // different to how `pub run test (folder)` works (one debug session, which each file in an isolate). The
            // debugger does not currently support multiple VM service sessions so we have to downgrade this to noDebug.
            logger.warn("Setting noDebug=true for Flutter test run because it's a folder");
            debugConfig.noDebug = true;
        }
        // If we're attaching to Dart, ensure we get a VM service URI.
        if (isAttachRequest && !debugConfig.vmServiceInfoFile) {
            // For attaching, the VM service address must be specified. If it's not provided already, prompt for it.
            if (!isFlutter) { // TEMP Condition because there's no point asking yet as the user doesn't know how to get this..
                debugConfig.vmServiceUri = await this.getFullVmServiceUri(debugConfig.vmServiceUri || debugConfig.observatoryUri);
            }
            if (!debugConfig.vmServiceUri && !isFlutter) {
                logger.warn("No VM service URI/port was provided");
                void vscode_1.window.showInformationMessage("You must provide a VM service URI/port to attach a debugger");
                return undefined; // undefined means silent (don't open launch.json).
            }
        }
        if (token && token.isCancellationRequested)
            return;
        // Ensure we have a device if required.
        let deviceToLaunchOn = this.deviceManager?.getDevice(debugConfig.deviceId) || this.deviceManager?.currentDevice;
        const requiresDevice = (debugType === enums_1.DebuggerType.Flutter && !isAttachRequest)
            || (enums_1.DebuggerType.FlutterTest && isIntegrationTest && this.flutterCapabilities.supportsRunningIntegrationTests);
        if (requiresDevice) {
            if (this.deviceManager && this.daemon && debugConfig.deviceId !== "flutter-tester") {
                let supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                    ? (await this.deviceManager.tryGetSupportedPlatforms(debugConfig.cwd))?.platforms
                    : undefined;
                if (!debugConfig.suppressPrompts) {
                    // If the current device is not valid, prompt the user.
                    if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn))
                        deviceToLaunchOn = await this.deviceManager.showDevicePicker(supportedPlatforms);
                    // Refresh the supported platforms, as the we may have enabled new platforms during
                    // the call to showDevicePicker.
                    supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                        ? (await this.deviceManager.tryGetSupportedPlatforms(debugConfig.cwd))?.platforms
                        : undefined;
                }
                // If we still don't have a valid device, show an error.
                if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn)) {
                    if (!debugConfig.suppressPrompts) {
                        if (deviceToLaunchOn) {
                            logger.warn(`Unable to launch because ${deviceToLaunchOn.id} is not valid for this project (${deviceToLaunchOn.platformType} is not allowed according to [${supportedPlatforms?.join(", ")}])`);
                            void vscode_1.window.showInformationMessage("Cannot launch without a valid device for this project");
                        }
                        else {
                            logger.warn("Unable to launch due to no active device");
                            void vscode_1.window.showInformationMessage("Cannot launch without an active device");
                        }
                    }
                    return undefined; // undefined means silent (don't open launch.json).
                }
            }
        }
        if (token && token.isCancellationRequested)
            return;
        // Ensure we have any require dependencies.
        if (!(await this.installDependencies(debugType, this.pubGlobal))) {
            return undefined;
        }
        if (token && token.isCancellationRequested)
            return;
        // TODO: This cast feels nasty?
        await this.setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttachRequest, isTest, deviceToLaunchOn, this.deviceManager);
        // Debugger always uses uppercase drive letters to ensure our paths have them regardless of where they came from.
        debugConfig.program = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.program);
        debugConfig.cwd = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.cwd);
        // If we're launching (not attaching) then check there are no errors before we launch.
        if (!isAttachRequest && debugConfig.cwd && config_1.config.promptToRunIfErrors && !debugConfig.suppressPrompts) {
            if (await this.checkIfProjectHasErrors(debugConfig))
                return undefined; // undefined means silent (don't open launch.json).
        }
        if (token && token.isCancellationRequested)
            return;
        const didWarnAboutCwd = debugConfig.cwd && path.isAbsolute(debugConfig.cwd)
            ? (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.cwd, "the launch script working directory", "check the 'cwd' field in your launch configuration file (.vscode/launch.json)")
            : false;
        if (!didWarnAboutCwd && debugConfig.program && path.isAbsolute(debugConfig.program))
            (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.program, "the launch script", "check the 'program' field in your launch configuration file (.vscode/launch.json)");
        if (debugType === enums_1.DebuggerType.FlutterTest /* || debugType === DebuggerType.WebTest */ || debugType === enums_1.DebuggerType.DartTest) {
            if (debugConfig.program) {
                const suites = (0, utils_4.isTestFolder)(debugConfig.program)
                    ? Array.from(this.testModel.suites.values())
                        .filter((suite) => suite.path.startsWith(debugConfig.program))
                    : [this.testModel.suites.getForPath(debugConfig.program)];
                for (const suite of suites.filter(utils_2.notNullOrUndefined))
                    this.testModel.flagSuiteStart(suite, !argsHaveTestFilter);
            }
        }
        debugConfig.debuggerType = debugType;
        if (debugConfig.programQuery) {
            debugConfig.program += debugConfig.programQuery;
            delete debugConfig.programQuery;
        }
        logger.info(`Debug session starting...\n    ${JSON.stringify(debugConfig, undefined, 4).replace(/\n/g, "\n    ")}`);
        // Stash the config to support the "rerun last debug session" command.
        debug_1.LastDebugSession.workspaceFolder = folder;
        debug_1.LastDebugSession.debugConfig = Object.assign({}, debugConfig);
        void vs.commands.executeCommand("setContext", constants_contexts_1.HAS_LAST_DEBUG_CONFIG, true);
        // Stash the config to support the "rerun last test(s)" command.
        if (isTest) {
            debug_1.LastTestDebugSession.workspaceFolder = folder;
            debug_1.LastTestDebugSession.debugConfig = Object.assign({}, debugConfig);
            void vs.commands.executeCommand("setContext", constants_contexts_1.HAS_LAST_TEST_DEBUG_CONFIG, true);
        }
        return debugConfig;
    }
    async checkIfProjectHasErrors(debugConfig) {
        const logger = this.logger;
        logger.info("Checking for errors before launching");
        const isDartError = (d) => d.source === "dart" && d.severity === vs.DiagnosticSeverity.Error;
        const dartErrors = vs.languages
            .getDiagnostics()
            .filter((file) => file[1].find(isDartError));
        // Check if any are inside our CWD.
        const firstRelevantDiagnostic = dartErrors.find((fd) => {
            const file = (0, fs_1.fsPath)(fd[0]);
            return (0, fs_1.isWithinPath)(file, debugConfig.cwd)
                // Ignore errors in test folder unless it's the file we're running.
                && ((!(0, utils_4.isInsideFolderNamed)(file, "test") && !(0, utils_4.isInsideFolderNamed)(file, "integration_test")) || file === debugConfig.program);
        });
        if (firstRelevantDiagnostic) {
            logger.warn("Project has errors, prompting user");
            const firstRelevantError = firstRelevantDiagnostic[1].find(isDartError);
            const range = firstRelevantError.range;
            logger.warn(`    ${(0, fs_1.fsPath)(firstRelevantDiagnostic[0])}:${range.start.line}:${range.start.character}`);
            logger.warn(`    ${firstRelevantError.message.split("\n")[0].trim()}`);
            const action = await vscode_1.window.showErrorMessage("Errors exist in your project.", { modal: true }, constants_1.runAnywayAction, constants_1.showErrorsAction);
            if (action === constants_1.runAnywayAction) {
                logger.info("Running anyway!");
                // Do nothing, we'll just carry on.
            }
            else {
                logger.info("Aborting!");
                if (action === constants_1.showErrorsAction)
                    void vs.commands.executeCommand("workbench.action.showErrorsWarnings");
                return true;
            }
        }
        return false;
    }
    selectDebuggerType(debugConfig, argsHaveTestFilter, isTest, logger) {
        const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
        let debugType = enums_1.DebuggerType.Dart;
        let firstPathSegment;
        const projectRoot = debugConfig.projectRootPath ?? debugConfig.cwd;
        if (projectRoot && debugConfig.program && (0, fs_1.isWithinPath)(debugConfig.program, projectRoot)) {
            const relativePath = debugConfig.program ? path.relative(projectRoot, debugConfig.program) : undefined;
            firstPathSegment = relativePath?.split(path.sep)[0];
        }
        if (firstPathSegment === "bin" || firstPathSegment === "tool" || firstPathSegment === ".dart_tool") {
            logger.info(`Program is 'bin', 'tool', '.dart_tool' so will use Dart debugger`);
        }
        else if ((0, fs_1.isFlutterProjectFolder)(projectRoot) || this.wsContext.config.forceFlutterDebug) {
            debugType = enums_1.DebuggerType.Flutter;
        }
        else if (firstPathSegment === "web") {
            debugType = enums_1.DebuggerType.Web;
        }
        else {
            logger.info(`Program (${debugConfig.program}) not recognised as Flutter or Web, will use Dart debugger`);
        }
        logger.info(`Detected launch project as ${enums_1.DebuggerType[debugType]}`);
        if (isTest)
            logger.info(`Detected launch project as a Test project`);
        const canUsePackageTest = isTest && projectRoot && (0, utils_4.projectCanUsePackageTest)(projectRoot, this.wsContext.config);
        if (isTest && !canUsePackageTest)
            logger.info(`Project does not appear to support 'pub run test', will use VM directly`);
        if (isTest) {
            switch (debugType) {
                case enums_1.DebuggerType.Dart:
                    if (canUsePackageTest)
                        debugType = enums_1.DebuggerType.DartTest;
                    break;
                case enums_1.DebuggerType.Flutter:
                    if (isIntegrationTest) {
                        // Integration tests always use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice && argsHaveTestFilter) {
                        // TODO: Remove argsHaveTestFilter now that "flutter test" supports running tests on device (integration tests).
                        // Non-integration tests set to run on device but have a test name filter will also have
                        // to run with "flutter test".
                        void vs.window.showWarningMessage("Running with 'flutter test' as 'runTestsOnDevice' is not supported for individual tests.");
                        logger.info(`runTestsOnDevice is set but args have test filter so will still use Flutter`);
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice) {
                        // Anything else (eg. Non-integration tests without a test name filter) is allowed to
                        // run on a device if specified.
                        logger.info(`runTestsOnDevice is set, so will use Flutter instead of FlutterTest`);
                    }
                    else {
                        // Otherwise, default is to use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    break;
                case enums_1.DebuggerType.Web:
                    debugType = enums_1.DebuggerType.WebTest;
                    break;
                default:
                    logger.info("Unknown debugType, unable to switch to test debugger");
            }
        }
        logger.info(`Using ${enums_1.DebuggerType[debugType]} debug adapter for this session`);
        return debugType;
    }
    configureProgramAndCwd(debugConfig, folder, openFile) {
        const logger = this.logger;
        const isAttachRequest = debugConfig.request === "attach";
        // Try to infer a default working directory:
        //
        //   1. Provided by the user
        //   2. Inferred from the likely entry point (`program ?? openFile`)
        //   3. From the active workspace folder for this launch configuration (only if no explicit entry point)
        //   4. A common ancestor from the workspace folders
        //
        // The default may be overwritten further down if we locate a project root
        // while walking up the tree from the `program`.
        let defaultCwd = debugConfig.cwd;
        if (!defaultCwd) {
            const likelyEntryPoint = debugConfig.program ?? openFile;
            if (likelyEntryPoint && path.isAbsolute(likelyEntryPoint)) {
                // If we have an explicit program, always use that to try and get a cwd.
                folder = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(likelyEntryPoint));
                if (folder) {
                    defaultCwd = (0, fs_1.fsPath)(folder.uri);
                    logger.info(`Setting cwd based on likely entry point: ${defaultCwd}`);
                }
            }
            else if (folder) {
                // Otherwise, if we had no entry point but did have an active workspace folder, use that.
                defaultCwd = (0, fs_1.fsPath)(folder.uri);
                logger.info(`Setting cwd based on active workspace folder: ${defaultCwd}`);
            }
            // If none of those searches found a good cwd, try to infer one from our active workspace
            // folders.
            if (!defaultCwd && vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length >= 1) {
                if (vs.workspace.workspaceFolders.length === 1) {
                    folder = vs.workspace.workspaceFolders[0];
                    defaultCwd = (0, fs_1.fsPath)(folder.uri);
                    logger.info(`Setting folder/defaultCwd based single open folder: ${defaultCwd}`);
                }
                else {
                    const workspaceFolderPaths = vs.workspace.workspaceFolders.map((wf) => (0, fs_1.fsPath)(wf.uri));
                    defaultCwd = (0, fs_1.findCommonAncestorFolder)(workspaceFolderPaths);
                }
                if (defaultCwd)
                    logger.info(`Setting defaultCwd based on common ancestor of open folders: ${defaultCwd}`);
                else
                    logger.info(`Unable to infer defaultCwd from open workspace (no common ancestor)`);
            }
        }
        // Convert any relative paths to absolute paths (if possible).
        if (defaultCwd && !path.isAbsolute(defaultCwd) && folder) {
            debugConfig.cwd = path.join((0, fs_1.fsPath)(folder.uri), defaultCwd);
            this.logger.info(`Converted defaultCwd to absolute path: ${defaultCwd}`);
        }
        if (debugConfig.cwd && !path.isAbsolute(debugConfig.cwd) && folder) {
            debugConfig.cwd = path.join((0, fs_1.fsPath)(folder.uri), debugConfig.cwd);
            this.logger.info(`Converted cwd to absolute path: ${debugConfig.cwd}`);
        }
        if (debugConfig.program && !path.isAbsolute(debugConfig.program) && (debugConfig.cwd || folder)) {
            debugConfig.program = path.join(debugConfig.cwd || (0, fs_1.fsPath)(folder.uri), debugConfig.program);
            this.logger.info(`Converted program to absolute path: ${debugConfig.program}`);
        }
        if (!isAttachRequest) {
            // If there's no program set, try to guess one.
            if (!debugConfig.program) {
                const preferredFolder = debugConfig.cwd
                    ? debugConfig.cwd
                    : defaultCwd;
                // If we have a folder specified, we should only consider open files if it's inside it.
                const preferredFile = !preferredFolder || (!!openFile && (0, fs_1.isWithinPath)(openFile, preferredFolder)) ? openFile : undefined;
                debugConfig.program = debugConfig.program || this.guessBestEntryPoint(preferredFile, preferredFolder);
            }
        }
        // Compute a best project root and store it against the config. This can be used to pass to tools like
        // DevTools to ensure we have the right root regardless of the actual cwd we end up using.
        // We allow this to be outside of the project to support some use cases of spawning utility scripts from outside
        // this project (https://github.com/Dart-Code/Dart-Code/issues/4867).
        const bestProjectRoot = debugConfig.program ? (0, project_1.locateBestProjectRoot)(debugConfig.program, true) : undefined;
        debugConfig.projectRootPath = bestProjectRoot;
        // If we don't have a cwd then find the best one from the project root.
        if (!debugConfig.cwd && defaultCwd) {
            debugConfig.cwd = defaultCwd;
            this.logger.info(`Using workspace as cwd: ${debugConfig.cwd}`);
            // If we have an entry point, see if we can make this more specific by finding a project root.
            if (bestProjectRoot && (0, fs_1.isWithinPath)(bestProjectRoot, defaultCwd)) {
                debugConfig.cwd = bestProjectRoot;
                this.logger.info(`Found better project root to use as cwd: ${debugConfig.cwd}`);
            }
        }
        // Ensure we have a full path.
        if (debugConfig.program && debugConfig.cwd && !path.isAbsolute(debugConfig.program))
            debugConfig.program = path.join(debugConfig.cwd, debugConfig.program);
        if (debugConfig.program && path.isAbsolute(debugConfig.program) && !this.wsContext.config.omitTargetFlag) {
            if (!fs.existsSync(debugConfig.program)) {
                this.logger.warn(`Launch config references non-existent file ${debugConfig.program}`);
                void vscode_1.window.showWarningMessage(`Your launch config references a program that does not exist. If you have problems launching, check the "program" field in your ".vscode/launch.json" file.`);
            }
        }
    }
    errorWithoutOpeningLaunchConfig(message) {
        this.logger.error(message);
        void vscode_1.window.showErrorMessage(message);
        return undefined; // undefined means silent (don't open launch.json).
    }
    installDependencies(debugType, pubGlobal) {
        return debugType === enums_1.DebuggerType.Web
            ? new webdev_1.WebDev(pubGlobal).installIfRequired()
            : true;
    }
    guessBestEntryPoint(openFile, folder) {
        // For certain open files, assume the user wants to run them.
        if ((0, utils_4.isValidEntryFile)(openFile)) {
            this.logger.info(`Using open file as entry point: ${openFile}`);
            return openFile;
        }
        // Use the open file as a clue to find the best project root, then search from there.
        const projectRoot = (openFile && (0, project_1.locateBestProjectRoot)(openFile)) || folder;
        if (projectRoot) {
            const projectFolderName = path.basename(projectRoot);
            const commonLaunchPaths = [
                path.join(projectRoot, "lib", "main.dart"),
                path.join(projectRoot, "bin", "main.dart"),
                path.join(projectRoot, "bin", `${projectFolderName}.dart`),
            ];
            for (const launchPath of commonLaunchPaths) {
                if (fs.existsSync(launchPath)) {
                    this.logger.info(`Using found common entry point: ${launchPath}`);
                    return launchPath;
                }
            }
            // If we don't have a bin folder, or a lib/main.dart, or a web folder, then
            // see if we have an example and try that.
            if (!fs.existsSync(path.join(projectRoot, "bin"))
                && !fs.existsSync(path.join(projectRoot, "web"))
                && fs.existsSync(path.join(projectRoot, "example")))
                return this.guessBestEntryPoint(undefined, path.join(projectRoot, "example"));
        }
        // Finally, if we don't have any workspace folder open, assume the user just wants to
        // run this file.
        if (!vscode_1.workspace.workspaceFolders?.length)
            return openFile;
    }
    async getFullVmServiceUri(vmServiceUriOrPort) {
        vmServiceUriOrPort = vmServiceUriOrPort || await vs.commands.executeCommand("dart.promptForVmService");
        vmServiceUriOrPort = vmServiceUriOrPort && vmServiceUriOrPort.trim();
        // If the input is just a number, treat is as a localhost port.
        if (vmServiceUriOrPort && /^[0-9]+$/.exec(vmServiceUriOrPort)) {
            vmServiceUriOrPort = `http://127.0.0.1:${vmServiceUriOrPort}`;
        }
        return vmServiceUriOrPort;
    }
    async setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttach, isTest, device, deviceManager) {
        const conf = config_1.config.for(folder && folder.uri);
        if (!debugConfig.name)
            debugConfig.name = isFlutter ? "Flutter" : "Dart";
        if (isFlutter && !debugConfig.deviceId && device) {
            const deviceLabel = deviceManager ? deviceManager.labelForDevice(device) : device.name;
            // Append the device name onto the session name to make it easier to start a config on multiple devices.
            // https://github.com/Dart-Code/Dart-Code/issues/4491
            debugConfig.name += ` (${deviceLabel})`;
            debugConfig.deviceId = device.id;
            debugConfig.deviceName = `${deviceLabel} (${device.platform})`;
        }
        if (isFlutter && !isTest && !isAttach && debugConfig.noDebug
            && this.flutterCapabilities.requiresForcedDebugModeForNoDebug
            && config_1.config.allowFlutterForcedDebugMode) {
            // Force debug mode in the adapter to get a VM Service connection.
            debugConfig.forceEnableDebugging = true;
        }
        debugConfig.toolEnv = (0, processes_1.getToolEnv)();
        debugConfig.sendLogsToClient = logging_1.isLogging || constants_1.isDartCodeTestRun;
        debugConfig.sendCustomProgressEvents = true;
        debugConfig.allowAnsiColorOutput = true;
        debugConfig.cwd = debugConfig.cwd || (folder && (0, fs_1.fsPath)(folder.uri));
        debugConfig.additionalProjectPaths = debugConfig.additionalProjectPaths || vs.workspace.workspaceFolders?.map((wf) => (0, fs_1.fsPath)(wf.uri));
        debugConfig.args = debugConfig.args || [];
        debugConfig.vmAdditionalArgs = debugConfig.vmAdditionalArgs || conf.vmAdditionalArgs;
        debugConfig.toolArgs = await this.buildToolArgs(debugType, debugConfig, conf, deviceManager?.daemonPortOverride);
        debugConfig.vmServicePort = debugConfig.vmServicePort ?? 0;
        debugConfig.dartSdkPath = this.wsContext.sdks.dart;
        debugConfig.vmServiceLogFile = (0, utils_4.insertSessionName)(debugConfig, debugConfig.vmServiceLogFile || conf.vmServiceLogFile);
        debugConfig.webDaemonLogFile = (0, utils_4.insertSessionName)(debugConfig, debugConfig.webDaemonLogFile || conf.webDaemonLogFile);
        debugConfig.maxLogLineLength = debugConfig.maxLogLineLength || config_1.config.maxLogLineLength;
        debugConfig.dartTestLogFile = (0, utils_4.insertSessionName)(debugConfig, debugConfig.dartTestLogFile || conf.dartTestLogFile);
        debugConfig.debugSdkLibraries = debugConfig.debugSdkLibraries !== undefined && debugConfig.debugSdkLibraries !== null
            ? debugConfig.debugSdkLibraries
            : !!config_1.config.debugSdkLibraries;
        debugConfig.debugExternalPackageLibraries = debugConfig.debugExternalPackageLibraries !== undefined && debugConfig.debugExternalPackageLibraries !== null
            ? debugConfig.debugExternalPackageLibraries
            : config_1.config.debugExternalPackageLibraries;
        debugConfig.showDartDeveloperLogs = conf.showDartDeveloperLogs;
        debugConfig.evaluateGettersInDebugViews = debugConfig.evaluateGettersInDebugViews || conf.evaluateGettersInDebugViews;
        debugConfig.showGettersInDebugViews = debugConfig.showGettersInDebugViews || conf.showGettersInDebugViews;
        debugConfig.evaluateToStringInDebugViews = debugConfig.evaluateToStringInDebugViews || config_1.config.evaluateToStringInDebugViews;
        debugConfig.daemonPort = config_1.config.daemonPort;
        if (!isFlutter && !isAttach && !isTest && debugConfig.console === undefined && config_1.config.cliConsole !== undefined)
            debugConfig.console = config_1.config.cliConsole;
        else if (isFlutter && (debugConfig.console === "terminal" || debugConfig.console === "externalTerminal"))
            void vs.window.showWarningMessage(`Flutter projects do not support "terminal" or "externalTerminal" for the "console" setting of a launch configuration. This setting will be ignored.`);
        if (isFlutter && this.wsContext.sdks.flutter) {
            debugConfig.flutterSdkPath = this.wsContext.sdks.flutter;
            debugConfig.omitTargetFlag = this.wsContext.config.omitTargetFlag;
            debugConfig.useInspectorNotificationsForWidgetErrors = config_1.config.showInspectorNotificationsForWidgetErrors;
            if (!debugConfig.customTool) {
                const customScript = isAttach ? this.wsContext.config.flutterToolsScript : isTest
                    ? this.wsContext.config.flutterTestScript
                    : this.wsContext.config.flutterRunScript;
                debugConfig.customTool = customScript?.script;
                debugConfig.customToolReplacesArgs = customScript?.replacesArgs;
            }
            debugConfig.flutterRunLogFile = (0, utils_4.insertSessionName)(debugConfig, debugConfig.flutterRunLogFile || conf.flutterRunLogFile);
            debugConfig.flutterTestLogFile = (0, utils_4.insertSessionName)(debugConfig, debugConfig.flutterTestLogFile || conf.flutterTestLogFile);
            debugConfig.showMemoryUsage =
                debugConfig.showMemoryUsage || debugConfig.showMemoryUsage === false
                    ? debugConfig.showMemoryUsage
                    : debugConfig.flutterMode === "profile";
        }
    }
    /// Builds arguments to be passed to tools (Dart VM or Flutter tool) for a given launch config.
    ///
    /// Arguments included here are usually based on convenience flags that are supported in launch.json, and are
    /// just mapped to standard arguments in an array.
    ///
    /// All arguments built here should be things that user the recognises based on the app they are trying to launch
    /// or settings they have configured. It should not include things that are specifically required by the debugger
    /// (for example, enabling the VM Service or starting paused). Those items should be handled inside the Debug Adapter.
    async buildToolArgs(debugType, debugConfig, conf, portFromLocalExtension) {
        let args = [];
        args = args.concat(debugConfig.toolArgs ?? []);
        switch (debugType) {
            case enums_1.DebuggerType.Dart:
                args = args.concat(await this.buildDartToolArgs(debugConfig, conf));
                break;
            case enums_1.DebuggerType.DartTest:
                args = args.concat(await this.buildDartTestToolArgs(debugConfig, conf));
                break;
            case enums_1.DebuggerType.Flutter:
                args = args.concat(await this.buildFlutterToolArgs(debugConfig, conf));
                break;
            case enums_1.DebuggerType.FlutterTest:
                args = args.concat(await this.buildFlutterTestToolArgs(debugConfig, conf));
                break;
        }
        return args;
    }
    async buildDartToolArgs(debugConfig, conf) {
        const args = [];
        const isDebug = debugConfig.noDebug !== true;
        this.addArgsIfNotExist(args, ...conf.cliAdditionalArgs);
        if (debugConfig.enableAsserts !== false) // undefined = on
            this.addArgsIfNotExist(args, "--enable-asserts");
        return args;
    }
    async buildDartTestToolArgs(debugConfig, conf) {
        const args = [];
        this.addArgsIfNotExist(args, ...conf.testAdditionalArgs);
        if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug)) {
            // Check whether package:test supports --ignore-timeouts
            let useIgnoreTimeouts = false;
            if (debugConfig.cwd) {
                const testCapabilities = await (0, version_1.getPackageTestCapabilities)(this.logger, this.wsContext, debugConfig.cwd);
                useIgnoreTimeouts = testCapabilities.supportsIgnoreTimeouts;
            }
            if (useIgnoreTimeouts)
                this.addArgsIfNotExist(args, "--ignore-timeouts");
            else
                this.addArgsIfNotExist(args, "--timeout", "1d");
        }
        return args;
    }
    async buildFlutterToolArgs(debugConfig, conf) {
        const args = [];
        const isDebug = debugConfig.noDebug !== true;
        const isAttach = debugConfig.request === "attach";
        const isWeb = (0, utils_2.isWebDevice)(debugConfig.deviceId);
        this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
        this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
        if (isAttach)
            this.addArgsIfNotExist(args, ...conf.flutterAttachAdditionalArgs);
        else
            this.addArgsIfNotExist(args, ...conf.flutterRunAdditionalArgs);
        if (debugConfig.deviceId)
            this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
        if (!isAttach) {
            switch (debugConfig.flutterMode) {
                case "profile":
                case "release":
                    this.addArgsIfNotExist(args, `--${debugConfig.flutterMode}`);
                    break;
                default: // Debug mode.
                    const futterVmServicePortOption = this.flutterCapabilities.supportsFlutterHostVmServicePort ? "host-vmservice-port" : "observatory-port";
                    if (debugConfig.vmServicePort && isDebug)
                        this.addArgsIfNotExist(args, `--${futterVmServicePortOption}`, debugConfig.vmServicePort.toString());
                    if (!conf.flutterTrackWidgetCreation && !args.includes("--no-track-widget-creation"))
                        this.addArgsIfNotExist(args, "--no-track-widget-creation");
            }
            if (debugConfig.flutterPlatform && debugConfig.flutterPlatform !== "default")
                this.addArgsIfNotExist(args, "--target-platform", debugConfig.flutterPlatform);
            if (debugConfig.deviceId === "web-server") {
                if (this.flutterCapabilities.supportsWsVmService && !args.includes("--web-server-debug-protocol"))
                    this.addArgsIfNotExist(args, "--web-server-debug-protocol", "ws");
                if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsDebugBackend)
                    this.addArgsIfNotExist(args, "--web-server-debug-backend-protocol", config_1.config.debugExtensionBackendProtocol);
                if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsInjectedClient)
                    this.addArgsIfNotExist(args, "--web-server-debug-injected-client-protocol", config_1.config.debugExtensionBackendProtocol);
            }
            if (this.flutterCapabilities.supportsExposeUrl && !utils_3.isRunningLocally)
                this.addArgsIfNotExist(args, "--web-allow-expose-url");
            if (isWeb) {
                const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                if (renderer)
                    this.addArgsIfNotExist(args, "--web-renderer", renderer);
            }
        }
        const daemonPort = this.deviceManager?.daemonPortOverride ?? conf.daemonPort;
        if (this.wsContext.config.forceFlutterWorkspace && daemonPort) {
            this.addArgsIfNotExist(args, "--daemon-connection-port", daemonPort.toString());
        }
        if (config_1.config.shareDevToolsWithFlutter && this.flutterCapabilities.supportsDevToolsServerAddress && !args.includes("--devtools-server-address")) {
            this.logger.info("Getting DevTools server address to pass to Flutter...");
            try {
                const devtoolsUrl = await this.devTools.devtoolsUrl;
                if (devtoolsUrl)
                    this.addArgsIfNotExist(args, "--devtools-server-address", devtoolsUrl.toString());
                else if (!constants_1.isDartCodeTestRun) // Suppress warning on test runs as they're fast and can launch before the server starts
                    this.logger.warn("DevTools server unavailable, not sending --devtools-server-address!");
            }
            catch (e) {
                this.logger.error(`Failed to get DevTools server address ${e}`);
            }
        }
        if ((logging_1.isLogging || constants_1.isDartCodeTestRun) && !args.includes("--verbose"))
            this.addArgsIfNotExist(args, "-v");
        return args;
    }
    async buildFlutterTestToolArgs(debugConfig, conf) {
        const args = [];
        this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
        this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
        this.addArgsIfNotExist(args, ...conf.flutterTestAdditionalArgs);
        if (debugConfig.deviceId)
            this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
        if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug))
            this.addArgsIfNotExist(args, "--timeout", "1d");
        return args;
    }
    addArgsIfNotExist(args, ...toAdd) {
        if (!args.includes(toAdd[0])) {
            toAdd.forEach((s) => args.push(s));
        }
    }
}
exports.DebugConfigProvider = DebugConfigProvider;
class InitialLaunchJsonDebugConfigProvider {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    async provideDebugConfigurations(folder, token) {
        const results = [];
        const projectFolders = folder
            ? await (0, utils_3.getAllProjectFolders)(this.logger, utils_4.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth, workspaceFolders: [folder] })
            : [];
        const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
        if (projectFolders.length) {
            for (const projectFolder of projectFolders) {
                const isFlutter = (0, fs_1.isFlutterProjectFolder)(projectFolder);
                const name = path.basename(projectFolder);
                // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                if (isFlutter) {
                    results.push({
                        name,
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                    results.push({
                        name: `${name} (profile mode)`,
                        cwd,
                        request: "launch",
                        type: "dart",
                        flutterMode: "profile",
                    });
                    results.push({
                        name: `${name} (release mode)`,
                        cwd,
                        request: "launch",
                        type: "dart",
                        flutterMode: "release",
                    });
                }
                else {
                    results.push({
                        name,
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
            }
        }
        else {
            results.push({
                name: "Dart & Flutter",
                request: "launch",
                type: "dart",
            });
        }
        return results;
    }
}
exports.InitialLaunchJsonDebugConfigProvider = InitialLaunchJsonDebugConfigProvider;
class DynamicDebugConfigProvider {
    logger;
    deviceManager;
    constructor(logger, deviceManager) {
        this.logger = logger;
        this.deviceManager = deviceManager;
    }
    async provideDebugConfigurations(folder, token) {
        const results = [];
        const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
        const projectFolders = folder
            ? await (0, utils_3.getAllProjectFolders)(this.logger, utils_4.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth, workspaceFolders: [folder] })
            : [];
        for (const projectFolder of projectFolders) {
            const isFlutter = (0, fs_1.isFlutterProjectFolder)(projectFolder);
            const name = path.basename(projectFolder);
            // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
            const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
            const exists = (p) => projectFolder && fs.existsSync(path.join(projectFolder, p));
            if (isFlutter && exists("lib/main.dart") && this.deviceManager) {
                results.push({
                    name: `${name} (Flutter)`,
                    program: "lib/main.dart",
                    cwd,
                    request: "launch",
                    type: "dart",
                });
                const devices = await this.deviceManager.getValidDevicesForProject(projectFolder);
                for (const device of devices) {
                    const deviceLabel = this.deviceManager?.labelForDevice(device);
                    results.push({
                        name: `${name} (Flutter ${deviceLabel})`,
                        program: "lib/main.dart",
                        cwd,
                        deviceId: device.id,
                        request: "launch",
                        type: "dart",
                    });
                }
                results.push({
                    name: `${name} (Flutter profile mode)`,
                    program: "lib/main.dart",
                    cwd,
                    request: "launch",
                    type: "dart",
                    flutterMode: "profile",
                });
                results.push({
                    name: `${name} (Flutter release mode)`,
                    program: "lib/main.dart",
                    cwd,
                    request: "launch",
                    type: "dart",
                    flutterMode: "release",
                });
            }
            if (!isFlutter && exists("web")) {
                results.push({
                    name: `${name} (Dart Web)`,
                    program: "web",
                    cwd,
                    request: "launch",
                    type: "dart",
                });
            }
            if (exists("bin/main.dart")) {
                results.push({
                    name: `${name} (Dart)`,
                    program: "bin/main.dart",
                    cwd,
                    request: "launch",
                    type: "dart",
                });
            }
            if (exists("test")) {
                results.push({
                    name: `${name} (${isFlutter ? "Flutter" : "Dart"} Tests)`,
                    program: "test",
                    cwd,
                    request: "launch",
                    type: "dart",
                });
            }
            if (isFlutter && exists("integration_test")) {
                results.push({
                    name: `${name} (${isFlutter ? "Flutter" : "Dart"} Integration Tests)`,
                    program: "integration_test",
                    cwd,
                    request: "launch",
                    type: "dart",
                });
            }
        }
        return results;
    }
}
exports.DynamicDebugConfigProvider = DynamicDebugConfigProvider;


/***/ }),

/***/ 6807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(279);
const dart_diagnostic_provider_1 = __webpack_require__(7763);
const ranking_code_action_provider_1 = __webpack_require__(9160);
class FixCodeActionProvider {
    logger;
    selector;
    analyzer;
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
    }
    rank = 1;
    metadata = {
        providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
    };
    async provideCodeActions(document, range, context, token) {
        if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
            return undefined;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return undefined;
        try {
            const pos = "active" in range ? range.active : range.start;
            const result = await this.analyzer.editGetFixes({
                file: (0, fs_1.fsPath)(document.uri),
                offset: document.offsetAt(pos),
            });
            if (token && token.isCancellationRequested)
                return;
            // Because fixes may be the same for multiple errors, we'll de-dupe them based on their edit.
            const allActions = {};
            for (const errorFix of result.fixes) {
                for (const fix of errorFix.fixes) {
                    allActions[JSON.stringify(fix.edits)] = this.convertResult(document, fix, errorFix.error);
                }
            }
            const allFixes = Object.keys(allActions).map((a) => allActions[a]);
            return context.only
                ? allFixes.filter((f) => context.only?.contains(f.kind))
                : allFixes;
        }
        catch (e) {
            this.logger.error(e);
            throw e;
        }
    }
    convertResult(document, change, error) {
        const title = change.message;
        const diagnostics = error ? [dart_diagnostic_provider_1.DartDiagnosticProvider.createDiagnostic(error)] : undefined;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.QuickFix);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        action.diagnostics = diagnostics;
        return action;
    }
}
exports.FixCodeActionProvider = FixCodeActionProvider;


/***/ }),

/***/ 4975:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyDartWorkspaceSymbolProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
const utils_1 = __webpack_require__(1894);
const analyzer_das_1 = __webpack_require__(5476);
const utils_2 = __webpack_require__(279);
class LegacyDartWorkspaceSymbolProvider {
    logger;
    analyzer;
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    async provideWorkspaceSymbols(query, token) {
        if (query.length === 0)
            return undefined;
        query = this.sanitizeUserQuery(query);
        const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
        const results = await Promise.all([
            this.analyzer.searchFindTopLevelDeclarationsResults({ pattern }),
            this.analyzer.searchFindMemberDeclarationsResults({ name: pattern }),
        ]);
        return this.combineResults(results);
    }
    combineResults(results) {
        return results[0].results.concat(results[1].results)
            .filter((r) => this.shouldIncludeResult(r))
            .map((r) => this.convertResult(r));
    }
    async searchTopLevelSymbols(query) {
        const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
        const resp = await this.analyzer.searchFindTopLevelDeclarationsResults({ pattern });
        return resp.results;
    }
    async searchMemberDeclarations(query) {
        const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
        const resp = await this.analyzer.searchFindMemberDeclarationsResults({ name: pattern });
        return resp.results;
    }
    sanitizeUserQuery(query) {
        let chars = Array.from(query);
        // Filter out special chars that will break regex.
        // searchFindTopLevelDeclarations supports regex, but we build the pattern with the output of this.
        // searchMemberDeclarations is not intended to support regex but does.
        chars = chars.filter((c) => !"[](){}\\|./<>?+".includes(c));
        return chars.join("");
    }
    makeCaseInsensitiveFuzzyRegex(query) {
        let chars = Array.from(query);
        chars = chars.map((c) => {
            if (c.toUpperCase() === c.toLowerCase())
                return c;
            return `[${c.toUpperCase()}${c.toLowerCase()}]`;
        });
        const pattern = chars.join(".*");
        return `.*${pattern}.*`;
    }
    shouldIncludeResult(result) {
        // Must be either:
        //   1. Public (not start with an underscore).
        //   2. In our project.
        const isPrivate = result.path[0].name.startsWith("_") || result.path[1].name.startsWith("_");
        return (0, utils_2.isWithinWorkspace)(result.location.file) || !isPrivate;
    }
    convertResult(result) {
        // Rewrite the filename for best display.
        const containerName = this.createDisplayPath(result.location.file);
        // Remove the library and compilation unit parent elements; concatenate names.
        let elementPathDescription = result.path
            .slice(0, result.path.length - 2)
            .reverse()
            .map((e) => e.name)
            .join(".");
        // For properties, show if get/set.
        if (result.path[0].kind === "SETTER")
            elementPathDescription += " set";
        if (result.path[0].kind === "GETTER")
            elementPathDescription += " get";
        const parameters = result.path[0].parameters && result.path[0].kind !== "SETTER"
            ? result.path[0].parameters
            : "";
        return new vscode_1.SymbolInformation(elementPathDescription + parameters, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.path[0].kind), containerName || "", new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_1.toRangeOnLine)(result.location)));
    }
    createDisplayPath(inputPath) {
        if (!inputPath)
            return undefined;
        // HACK: The AS returns paths to the PUB_CACHE folder, which Code can't
        // convert to relative paths (so they look terrible). If the file exists in
        // workspace.rootPath we rewrite the path to there which gives us a nice
        // relative path.
        // Currently I only do this for "hosted\pub.dartlang.org" as I'm not sure of the
        // rules for these paths!
        const pubCachePath = "hosted" + path.sep + "pub.dartlang.org";
        const pubCachePathIndex = inputPath.indexOf(pubCachePath);
        if (pubCachePathIndex > -1) {
            const relativePath = inputPath.substring(pubCachePathIndex + pubCachePath.length + 1);
            // Packages in pubcache are versioned so trim the "-x.x.x" off the end of the foldername.
            const pathComponents = relativePath.split(path.sep);
            pathComponents[0] = pathComponents[0].split("-")[0];
            // Symlink goes into the lib folder, so strip that out of the path.
            if (pathComponents[1] === "lib")
                pathComponents.splice(1, 1);
            // Return 'package:foo/bar.dart'.
            inputPath = `package:${pathComponents[0]}/${pathComponents.slice(1).join("/")}`;
        }
        else {
            const root = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(inputPath));
            inputPath = root && path.relative((0, fs_1.fsPath)(root.uri), inputPath);
        }
        return inputPath;
    }
}
exports.LegacyDartWorkspaceSymbolProvider = LegacyDartWorkspaceSymbolProvider;


/***/ }),

/***/ 9160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RankingCodeActionProvider = void 0;
exports.getKindFor = getKindFor;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
class RankingCodeActionProvider {
    codeActionProviders = [];
    registerProvider(provider) {
        this.codeActionProviders.push(provider);
        (0, array_1.sortBy)(this.codeActionProviders, (p) => p.rank);
    }
    get metadata() {
        const allKinds = (0, utils_1.flatMap)(this.codeActionProviders, (p) => p.metadata.providedCodeActionKinds || []);
        return { providedCodeActionKinds: (0, utils_1.uniq)(allKinds) };
    }
    async provideCodeActions(document, range, context, token) {
        // Sort the providers, because then their results will be sorted (flatMap doesn't change the order, and
        // Promise.all preserves order).
        const applicableProviders = this.codeActionProviders.filter((p) => vscode_1.languages.match(p.selector, document));
        const promises = applicableProviders.map((p) => p.provideCodeActions(document, range, context, token));
        const allResults = await Promise.all(promises);
        const flatResults = (0, utils_1.flatMap)(allResults, (x) => x || []);
        return flatResults;
    }
}
exports.RankingCodeActionProvider = RankingCodeActionProvider;
function getKindFor(id, base) {
    if (!id)
        return base;
    const newID = id
        .replace("dart.assist.", "")
        .replace("dart.fix.", "")
        .replace("analysisOptions.assist.", "")
        .replace("analysisOptions.fix.", "");
    return base.append(newID);
}


/***/ }),

/***/ 6244:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(279);
const supportedRefactors = {
    CONVERT_METHOD_TO_GETTER: "Convert Method to Getter",
    EXTRACT_LOCAL_VARIABLE: "Extract Local Variable",
    EXTRACT_METHOD: "Extract Method",
    EXTRACT_WIDGET: "Extract Widget",
};
class RefactorCodeActionProvider {
    selector;
    analyzer;
    constructor(selector, analyzer) {
        this.selector = selector;
        this.analyzer = analyzer;
    }
    rank = 50;
    metadata = {
        providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
    };
    async provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return undefined;
        // If we were only asked for specific action types and that doesn't include
        // refactor (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
            return undefined;
        try {
            const startOffset = document.offsetAt(range.start);
            const endOffset = document.offsetAt(range.end);
            const result = await this.analyzer.editGetAvailableRefactorings({
                file: (0, fs_1.fsPath)(document.uri),
                length: endOffset - startOffset,
                offset: startOffset,
            });
            if (token && token.isCancellationRequested)
                return;
            const allRefactors = result.kinds.map((k) => this.getSupportedRefactorForKind(document, range, k)).filter(utils_1.notUndefined);
            return context.only
                ? allRefactors.filter((r) => context.only?.contains(r.kind))
                : allRefactors;
        }
        catch (e) {
            // TODO: Swap this back to logError/throw when https://github.com/dart-lang/sdk/issues/33471 is fixed.
            return [];
            // logError(e);
            // reject();
        }
    }
    getSupportedRefactorForKind(document, range, k) {
        if (!supportedRefactors[k])
            return;
        const title = supportedRefactors[k];
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.Refactor);
        action.command = {
            arguments: [document, range, k],
            command: "_dart.performRefactor",
            title,
        };
        return action;
    }
}
exports.RefactorCodeActionProvider = RefactorCodeActionProvider;


/***/ }),

/***/ 2393:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetCompletionItemProvider = void 0;
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const extension_utils_1 = __webpack_require__(6584);
const config_1 = __webpack_require__(7678);
class SnippetCompletionItemProvider {
    isLsp;
    dartCapabilities;
    completions = new vscode_1.CompletionList();
    shouldRender;
    constructor(isLsp, dartCapabilities, filename, shouldRender) {
        this.isLsp = isLsp;
        this.dartCapabilities = dartCapabilities;
        this.shouldRender = shouldRender;
        const snippets = (0, extension_utils_1.readJson)(path.join(extension_utils_1.extensionPath, filename));
        for (const snippetType of Object.keys(snippets)) {
            for (const snippetName of Object.keys(snippets[snippetType])) {
                const snippet = snippets[snippetType][snippetName];
                const completionItem = new vscode_1.CompletionItem(snippetName, vscode_1.CompletionItemKind.Snippet);
                completionItem.filterText = snippet.prefix;
                completionItem.insertText = new vscode_1.SnippetString(Array.isArray(snippet.body)
                    ? snippet.body.join("\n")
                    : snippet.body);
                completionItem.detail = snippet.description;
                completionItem.documentation = (0, extension_utils_1.createMarkdownString)("").appendCodeblock(completionItem.insertText.value);
                completionItem.sortText = "zzzzzzzzzzzzzzzzzzzzzz";
                this.completions.items.push(completionItem);
            }
        }
    }
    provideCompletionItems(document, position, token, context) {
        if (!config_1.config.enableSnippets)
            return;
        if (config_1.config.enableServerSnippets && this.dartCapabilities.supportsServerSnippets && this.isLsp)
            return;
        const line = document.lineAt(position.line).text.slice(0, position.character);
        if (!this.shouldAllowCompletion(line, context))
            return;
        if (!this.shouldRender(document.uri))
            return;
        return this.completions;
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Don't provide completions after comment markers. This isn't perfect since it'll
        // suppress them for ex if // appears inside strings, but it's a reasonable
        // approximation given we don't have a reliable way to tell that.
        if (line.includes("//"))
            return false;
        // Otherwise, allow through.
        return true;
    }
}
exports.SnippetCompletionItemProvider = SnippetCompletionItemProvider;


/***/ }),

/***/ 4565:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(1894);
const utils_2 = __webpack_require__(279);
class SourceCodeActionProvider {
    static metadata = {
        providedCodeActionKinds: [vscode_1.CodeActionKind.Source, vscode_1.CodeActionKind.SourceOrganizeImports, utils_1.SourceSortMembersCodeActionKind],
    };
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return undefined;
        const actions = [];
        const organizeImportsCodeAction = {
            command: {
                arguments: [document],
                command: "_dart.organizeImports",
                title: "Organize Imports",
            },
            kind: vscode_1.CodeActionKind.SourceOrganizeImports,
            title: "Organize Imports",
        };
        const sortMembersCodeAction = {
            command: {
                arguments: [document],
                command: "dart.sortMembers",
                title: "Sort Members",
            },
            kind: utils_1.SourceSortMembersCodeActionKind,
            title: "Sort Members",
        };
        if (!context || !context.only || context.only.contains(vscode_1.CodeActionKind.Source) || context.only.contains(vscode_1.CodeActionKind.SourceOrganizeImports)) {
            actions.push(organizeImportsCodeAction);
        }
        if (!context || !context.only || context.only.contains(vscode_1.CodeActionKind.Source) || context.only.contains(utils_1.SourceSortMembersCodeActionKind)) {
            actions.push(sortMembersCodeAction);
        }
        return actions;
    }
}
exports.SourceCodeActionProvider = SourceCodeActionProvider;


/***/ }),

/***/ 3107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubGlobal = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const processes_1 = __webpack_require__(4917);
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const processes_2 = __webpack_require__(8141);
class PubGlobal {
    logger;
    dartCapabilities;
    context;
    sdks;
    pubApi;
    constructor(logger, dartCapabilities, context, sdks, pubApi) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.context = context;
        this.sdks = sdks;
        this.pubApi = pubApi;
    }
    async installIfRequired(options) {
        const packageID = options.packageID;
        const packageName = options.packageName ?? packageID;
        const moreInfoLink = options.moreInfoLink ?? constants_1.pubGlobalDocsUrl;
        const requiredVersion = options.requiredVersion;
        const silent = !!options.silent;
        const skipOptionalUpdates = !!options.skipOptionalUpdates;
        let updateSilently = !!options.updateSilently;
        let installedVersion = await this.getInstalledVersion(packageName, packageID);
        const versionStatus = await this.checkVersionStatus(packageID, installedVersion, requiredVersion);
        // If we have the latest version, or the update is not mandatory (UpdateRequired) and we were told to skip optional updates
        // just bail and use the current version.
        if (versionStatus === enums_1.VersionStatus.Valid || (skipOptionalUpdates && versionStatus === enums_1.VersionStatus.UpdateAvailable))
            return installedVersion;
        if (silent)
            updateSilently = true;
        const activateForMe = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activate ${packageName}` : `Update ${packageName}`;
        const message = versionStatus === enums_1.VersionStatus.NotInstalled
            ? `${packageName} needs to be installed with 'pub global activate ${packageID}' to use this feature.`
            : (versionStatus === enums_1.VersionStatus.UpdateRequired
                ? `${packageName} needs to be updated with 'pub global activate ${packageID}' to use this feature.`
                : `A new version of ${packageName} is available and can be installed with 'pub global activate ${packageID}'.`);
        let action = 
        // If we need an update and we're allowed to auto-update, to the same as if the user
        // clicked the activate button, otherwise prompt them.
        updateSilently && ((versionStatus === enums_1.VersionStatus.UpdateRequired || versionStatus === enums_1.VersionStatus.UpdateAvailable) || silent)
            ? activateForMe
            : await vs.window.showWarningMessage(message, activateForMe, constants_1.moreInfoAction);
        if (action === constants_1.moreInfoAction) {
            await utils_2.envUtils.openInBrowser(moreInfoLink);
            return undefined;
        }
        else if (action === activateForMe) {
            const actionName = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activating ${packageName}` : `Updating ${packageName}`;
            const args = ["global", "activate", packageID];
            try {
                if (silent)
                    await this.runCommand(packageName, args);
                else
                    await this.runCommandWithProgress(packageName, `${actionName}...`, args);
                installedVersion = await this.getInstalledVersion(packageName, packageID);
                const newVersionStatus = await this.checkVersionStatus(packageID, installedVersion);
                if (newVersionStatus !== enums_1.VersionStatus.Valid) {
                    this.logger.warn(`After installing ${packageID}, version status was ${enums_1.VersionStatus[newVersionStatus]} and not Valid!`);
                }
                return installedVersion;
            }
            catch (e) {
                this.logger.error(e);
                if (!silent) {
                    action = await vs.window.showErrorMessage(`${actionName} failed. Please try running 'pub global activate ${packageID}' manually.`, constants_1.moreInfoAction);
                    if (action === constants_1.moreInfoAction) {
                        await utils_2.envUtils.openInBrowser(moreInfoLink);
                    }
                }
                return undefined;
            }
        }
        return undefined;
    }
    async uninstall(packageID) {
        const args = ["global", "deactivate", packageID];
        await this.runCommand(packageID, args);
    }
    async checkVersionStatus(packageID, installedVersion, requiredVersion) {
        if (!installedVersion) {
            this.logger.info(`${packageID} has no installed version, returning NotInstalled`);
            return enums_1.VersionStatus.NotInstalled;
        }
        // If we need a specific version, check it here.
        if (requiredVersion && !(0, utils_1.pubVersionIsAtLeast)(installedVersion, requiredVersion)) {
            this.logger.info(`${packageID} version ${installedVersion} is not at least ${requiredVersion} so returning UpdateRequired`);
            return enums_1.VersionStatus.UpdateRequired;
        }
        // If we haven't checked in the last 24 hours, check if there's an update available.
        const lastChecked = this.context.getPackageLastCheckedForUpdates(packageID);
        if (!lastChecked || lastChecked <= Date.now() - constants_1.noRepeatPromptThreshold) {
            this.context.setPackageLastCheckedForUpdates(packageID, Date.now());
            try {
                const pubPackage = await this.pubApi.getPackage(packageID);
                if (!(0, utils_1.pubVersionIsAtLeast)(installedVersion, pubPackage.latest.version)) {
                    if (pubPackage.latest.retracted) {
                        this.logger.info(`${packageID} version ${installedVersion} is is retracted, so even though it's newer than ${pubPackage.latest.version}, returning Valid to avoid potentially installing repeatedly`);
                        return enums_1.VersionStatus.Valid;
                    }
                    else {
                        this.logger.info(`${packageID} version ${installedVersion} is not at least ${pubPackage.latest.version} so returning UpdateAvailable`);
                        return enums_1.VersionStatus.UpdateAvailable;
                    }
                }
            }
            catch (e) {
                // If we fail to call the API to check for a new version, then we can run
                // with what we have.
                this.logger.warn(`Failed to check for new version of ${packageID}: ${e}`, enums_1.LogCategory.CommandProcesses);
                return enums_1.VersionStatus.Valid;
            }
        }
        // Otherwise, we're installed and have a new enough version.
        this.logger.info(`${packageID} version ${installedVersion} appears to be latest so returning Valid`);
        return enums_1.VersionStatus.Valid;
    }
    async getInstalledVersion(packageName, packageID) {
        const output = await this.runCommand(packageName, ["global", "list"]);
        const versionMatch = new RegExp(`^${packageID} (\\d+\\.\\d+\\.\\d+[\\w.\\-+]*)(?: |$)`, "m");
        const match = versionMatch.exec(output);
        const installedVersion = match ? match[1] : undefined;
        return installedVersion;
    }
    runCommandWithProgress(packageName, title, args, customScript) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(packageName, args));
    }
    runCommand(packageName, args) {
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return new Promise((resolve, reject) => {
            this.logger.info(`Spawning ${pubExecution.executable} with args ${JSON.stringify(pubExecution.args)}`);
            const proc = (0, processes_2.safeToolSpawn)(undefined, pubExecution.executable, pubExecution.args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`${packageName} exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.PubGlobal = PubGlobal;


/***/ }),

/***/ 6205:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDev = void 0;
const packageName = "webdev";
const packageID = "webdev";
class WebDev {
    pubGlobal;
    constructor(pubGlobal) {
        this.pubGlobal = pubGlobal;
    }
    installIfRequired() {
        return this.pubGlobal.installIfRequired({ packageName, packageID, moreInfoLink: undefined, requiredVersion: "2.5.4" });
    }
}
exports.WebDev = WebDev;


/***/ }),

/***/ 706:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArbExtensionRecommentation = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const fs_1 = __webpack_require__(2587);
const arbExtensionIdentifier = "Google.arb-editor";
class ArbExtensionRecommentation {
    recommendations;
    context;
    constructor(recommendations, context) {
        this.recommendations = recommendations;
        this.context = context;
        context.context.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.maybePrompt(e?.document)));
    }
    hasShownPromptThisSession = false;
    async maybePrompt(doc) {
        if (!doc)
            return;
        if (this.hasShownPromptThisSession)
            return;
        // Not an ARB file. We can't check the languageId for JSON here, because the extension is not
        // matched to the JSON language until the ARB extension is installed.
        if (path.extname((0, fs_1.fsPath)(doc.uri)) !== ".arb")
            return;
        // Have already ignored.
        if (this.context.getIgnoredExtensionRecommendationIdentifiers().find((identifier) => identifier.toLowerCase() === arbExtensionIdentifier.toLowerCase()))
            return;
        this.hasShownPromptThisSession = true;
        await this.recommendations.promoteExtension({
            identifier: arbExtensionIdentifier,
            message: "The Google ARB Editor extension can provide validation and completion for ARB files.",
        });
    }
}
exports.ArbExtensionRecommentation = ArbExtensionRecommentation;


/***/ }),

/***/ 4241:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionRecommentations = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const analytics_1 = __webpack_require__(5922);
const utils_1 = __webpack_require__(279);
const arb_1 = __webpack_require__(706);
class ExtensionRecommentations {
    analytics;
    context;
    arb;
    constructor(analytics, context) {
        this.analytics = analytics;
        this.context = context;
        this.arb = new arb_1.ArbExtensionRecommentation(this, context);
    }
    async promptToInstallFlutterExtension() {
        const installExtension = "Install Flutter Extension";
        const res = await vs.window.showInformationMessage("The Flutter extension is required to work with Flutter projects.", installExtension);
        if (res === installExtension) {
            await this.installExtensionWithProgress("Installing Flutter extension", constants_1.flutterExtensionIdentifier);
            void (0, utils_1.promptToReloadExtension)();
        }
        return false;
    }
    async promoteExtension(extension) {
        const identifier = extension.identifier;
        const installPackage = `Install ${identifier}`;
        this.analytics.logExtensionPromotion(analytics_1.AnalyticsEvent.ExtensionRecommendation_Shown, identifier);
        const action = await vs.window.showInformationMessage(extension.message, installPackage, constants_1.noThanksAction);
        if (action === installPackage) {
            this.analytics.logExtensionPromotion(analytics_1.AnalyticsEvent.ExtensionRecommendation_Accepted, identifier);
            await this.installExtensionWithProgress(`Installing ${identifier}`, identifier);
        }
        else {
            this.analytics.logExtensionPromotion(analytics_1.AnalyticsEvent.ExtensionRecommendation_Rejected, identifier);
            this.context.ignoreExtensionRecommendation(extension.identifier);
        }
    }
    async installExtensionWithProgress(message, extensionIdentifier) {
        await vs.window.withProgress({ location: vs.ProgressLocation.Notification }, (progress) => {
            progress.report({ message });
            return new Promise((resolve) => {
                vs.extensions.onDidChange((e) => resolve());
                void vs.commands.executeCommand("workbench.extensions.installExtension", extensionIdentifier);
            });
        });
    }
}
exports.ExtensionRecommentations = ExtensionRecommentations;


/***/ }),

/***/ 33:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCreate = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(7385);
const processes_1 = __webpack_require__(8141);
class DartCreate {
    logger;
    sdks;
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    async getTemplates() {
        const json = await this.getTemplateJson();
        return JSON.parse(json);
    }
    async getTemplateJson() {
        return (0, utils_1.cleanPubOutput)(await this.runCommandWithProgress("Fetching project templates...", ["create", "--list-templates"]));
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const dartSdkPath = this.sdks.dart;
        const dartBinPath = path.join(dartSdkPath, constants_1.dartVMPath);
        return new Promise((resolve, reject) => {
            const proc = (0, processes_1.safeToolSpawn)(undefined, dartBinPath, args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`'dart create' exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.DartCreate = DartCreate;


/***/ }),

/***/ 8059:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsEmbeddedView = void 0;
const vs = __importStar(__webpack_require__(1398));
const events_1 = __webpack_require__(9495);
const utils_1 = __webpack_require__(1894);
const pageScript = `
const vscode = acquireVsCodeApi();
const originalState = vscode.getState();
const originalFrameUrl = originalState?.frameUrl;

// Track the background color as an indicator of whether the theme changed.
let currentBackgroundColor;

function getTheme() {
	const isDarkMode = !document.body.classList.contains('vscode-light');
	const backgroundColor = currentBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background');
	const foregroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-foreground');
	const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
	const fontSize = fontSizeWithUnits && fontSizeWithUnits.endsWith('px') ? parseFloat(fontSizeWithUnits) : undefined;

	return {
		isDarkMode: isDarkMode,
		backgroundColor: backgroundColor,
		foregroundColor: foregroundColor,
		fontSize: fontSize,
	};
}

window.addEventListener('load', (event) => {
	// Restore previous frame if we had one.
	const devToolsFrame = document.getElementById('devToolsFrame');
	if (originalFrameUrl && (devToolsFrame.src === "about:blank" || devToolsFrame.src === "")) {
		console.log(\`Restoring DevTools frame \${originalFrameUrl}\`);
		devToolsFrame.src = originalFrameUrl;
	}
});
window.addEventListener('message', (event) => {
	const message = event.data;
	const devToolsFrame = document.getElementById('devToolsFrame');
	switch (message.command) {
		case "setUrl":
			const theme = getTheme();
			const themeKind = theme.isDarkMode ? 'dark' : 'light';
			// Don't include # in colors
			// https://github.com/flutter/flutter/issues/155992
			let url = \`\${message.url}&theme=\${themeKind}&backgroundColor=\${encodeURIComponent(theme.backgroundColor?.replace('#', ''))}&foregroundColor=\${encodeURIComponent(theme.foregroundColor?.replace('#', ''))}\`;
			if (theme.fontSize) {
				url += \`&fontSize=\${encodeURIComponent(theme.fontSize)}\`;
			}
			if (devToolsFrame.src !== url) {
				devToolsFrame.src = url;
				vscode.setState({ frameUrl: url });
			}
			break;
		case "refresh":
			devToolsFrame.src += '';
			break;
		case "keydown":
			const data = message.data;
			// Forward keypresses up to VS Code so you can access the palette etc.
			// https://github.com/flutter/devtools/issues/2775
			// But suppress if it looks like SelectAll because we never want to handle that.
			// https://github.com/flutter/devtools/issues/5107
			const isSelectAll = data.code === 'KeyA' && (data.ctrlKey || data.metaKey);
			if (!isSelectAll)
				window.dispatchEvent(new KeyboardEvent('keydown', data));
			break;
		case "launchUrl":
			vscode.postMessage({command: 'launchUrl', data: message.data});
			break;
		case "clipboard-write":
			const copyData = message.data;
			navigator.clipboard.writeText(copyData);
			break;
	}
});
window.addEventListener('keydown', (event) => {
	// Move focus back into Frame. This happens if the frame has focus and you tab
	// away from VS Code, then back. The focus moves to this container page, and not
	// the DevTools iframe.
	if (document.activeElement == document.body)
		devToolsFrame?.contentWindow.focus();
});


function sendTheme() {
	const devToolsFrame = document.getElementById('devToolsFrame');
	const theme = getTheme();
	devToolsFrame.contentWindow.postMessage({
		method: 'editor.themeChanged',
		params: {
			kind: 'themeChanged',
			theme: theme,
		}
	}, "*");
}

document.addEventListener('DOMContentLoaded', function () {
	new MutationObserver((mutationList) => {
		for (const mutation of mutationList) {
			if (mutation.type === "attributes" && mutation.attributeName == "class") {
				let newBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background');
				if (newBackgroundColor !== currentBackgroundColor) {
					sendTheme();
					break;
				}
			}
		}
	}).observe(document.body, { attributeFilter : ['class'], attributeOldValue: true });
});
`;
const scriptNonce = Buffer.from(pageScript).toString("base64");
const frameCss = "position: absolute; top: 0; left: 0; width: 100%; height: 100%";
const cssNonce = Buffer.from(frameCss).toString("base64");
class DevToolsEmbeddedView {
    session;
    devToolsUri;
    pageTitle;
    panel;
    onDisposeEmitter = new events_1.EventEmitter();
    messageDisposable;
    onDispose = this.onDisposeEmitter.event;
    openedAutomatically = false;
    constructor(session, devToolsUri, pageTitle, location) {
        this.session = session;
        this.devToolsUri = devToolsUri;
        this.pageTitle = pageTitle;
        const column = location === "active"
            ? vs.ViewColumn.Active
            : ((0, utils_1.firstNonEditorColumn)() ?? vs.ViewColumn.Beside);
        this.panel = vs.window.createWebviewPanel("dartDevTools", pageTitle, column, {
            enableScripts: true,
            localResourceRoots: [],
            retainContextWhenHidden: true,
        });
        this.panel.onDidDispose(() => this.dispose(true));
        this.panel.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'nonce-${scriptNonce}' 'nonce-${cssNonce}' http://${vs.Uri.parse(devToolsUri).authority};">
			<script nonce="${scriptNonce}">${pageScript}</script>
			<style nonce="${cssNonce}">#devToolsFrame { ${frameCss} }</style>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0" allow="clipboard-read; clipboard-write; cross-origin-isolated"></iframe></body>
			</html>
			`;
        this.messageDisposable = this.panel.webview.onDidReceiveMessage(async (message) => {
            if (message.command === "launchUrl") {
                await utils_1.envUtils.openInBrowser(message.data.url);
            }
        });
    }
    load(session, uri) {
        this.session = session;
        void this.panel.webview.postMessage({ command: "setUrl", url: uri });
        this.panel.reveal();
    }
    reload() {
        void this.panel.webview.postMessage({ command: "refresh" });
    }
    dispose(panelDisposed = false) {
        if (!panelDisposed)
            this.panel.dispose();
        this.onDisposeEmitter.fire();
        this.messageDisposable.dispose();
    }
}
exports.DevToolsEmbeddedView = DevToolsEmbeddedView;


/***/ }),

/***/ 4494:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsManager = void 0;
const fs = __importStar(__webpack_require__(9896));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const devtools_server_1 = __webpack_require__(395);
const vscode_2 = __webpack_require__(2461);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const processes_1 = __webpack_require__(4917);
const stdio_service_1 = __webpack_require__(7724);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const constants_2 = __webpack_require__(5706);
const status_bar_1 = __webpack_require__(719);
const utils_2 = __webpack_require__(1894);
const debug_1 = __webpack_require__(394);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
const processes_2 = __webpack_require__(8141);
const embedded_view_1 = __webpack_require__(8059);
const devtoolsPackageID = "devtools";
const devtoolsPackageName = "Dart DevTools";
// This starts off undefined, which means we'll read from config.devToolsPort and fall back to undefined (use default).
// Once we get a port we'll update this variable so that if we restart (eg. a silent extension restart due to
// SDK change or similar) we will try to use the same port, so if the user has browser windows open they're
// still valid.
let portToBind;
// This is static because we want to track embedded views across restarts of DevToolsManager.
const devToolsEmbeddedViews = {};
/// Handles launching DevTools in the browser and managing the underlying service.
class DevToolsManager {
    logger;
    context;
    analytics;
    pubGlobal;
    toolingDaemon;
    dartCapabilities;
    flutterCapabilities;
    extensionRecommentations;
    disposables = [];
    statusBarItem = (0, status_bar_1.getLanguageStatusItem)("dart.devTools", constants_2.ANALYSIS_FILTERS);
    service;
    debugCommands;
    /// Resolves to the DevTools URL. This is created immediately when a new process is being spawned so that
    /// concurrent launches can wait on the same promise.
    devtoolsUrl;
    isShuttingDown = false;
    constructor(logger, context, analytics, pubGlobal, toolingDaemon, dartCapabilities, flutterCapabilities, extensionRecommentations) {
        this.logger = logger;
        this.context = context;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.toolingDaemon = toolingDaemon;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.extensionRecommentations = extensionRecommentations;
        this.statusBarItem.name = "Dart/Flutter DevTools";
        this.statusBarItem.text = "Dart DevTools";
        this.setNotStartedStatusBar();
        void this.handleEagerActivationAndStartup(context.workspaceContext);
        this.disposables.push(vs.debug.onDidTerminateDebugSession((session) => {
            if (config_1.config.closeDevTools === "never")
                return;
            for (const pageId of Object.keys(devToolsEmbeddedViews)) {
                const panels = devToolsEmbeddedViews[pageId];
                if (!panels)
                    continue;
                // If there are disconnected panels for this page, trigger a launch
                // of the page to reuse it.
                const closablePanels = panels
                    .filter((p) => p.session?.session.id === session.id)
                    .filter((p) => p.openedAutomatically || config_1.config.closeDevTools === "always");
                for (const panel of closablePanels) {
                    panel.dispose();
                }
            }
        }));
    }
    setNotStartedStatusBar() {
        this.statusBarItem.command = {
            arguments: [{ commandSource: constants_1.CommandSource.languageStatus }],
            command: "dart.openDevTools",
            title: "start & launch",
            tooltip: "Start and Launch DevTools",
        };
    }
    setStartedStatusBar(url) {
        this.statusBarItem.command = {
            arguments: [{ commandSource: constants_1.CommandSource.languageStatus }],
            command: "dart.openDevTools",
            title: "launch",
            tooltip: `DevTools is running at ${url}`,
        };
    }
    async handleEagerActivationAndStartup(workspaceContext) {
        if (workspaceContext.config?.startDevToolsServerEagerly) {
            try {
                await this.start(true);
            }
            catch (e) {
                this.logger.error("Failed to background start DevTools");
                this.logger.error(e);
                void vs.window.showErrorMessage(`Failed to start DevTools: ${e}`);
            }
        }
    }
    isPageAvailable(hasSession, page) {
        if (page.requiresFlutter && !this.context.workspaceContext.hasAnyFlutterProjects)
            return false;
        if (page.requiredDartSdkVersion && this.context.workspaceContext.sdks.dartVersion && !(0, utils_1.versionIsAtLeast)(this.context.workspaceContext.sdks.dartVersion, page.requiredDartSdkVersion))
            return false;
        if (!page.isStaticTool && !hasSession)
            return false;
        return true;
    }
    routeIdForPage(page) {
        if (!page)
            return undefined;
        if (page.routeId)
            return page.routeId(this.flutterCapabilities.version);
        return page.id;
    }
    async urlFor(page) {
        const base = await this.devtoolsUrl;
        if (!base)
            return base;
        const queryString = this.buildQueryString(this.getDefaultQueryParams());
        const separator = base.endsWith("/") ? "" : "/";
        return `${base}${separator}${page}?${queryString}`;
    }
    async start(silent = false) {
        if (!this.devtoolsUrl) {
            this.setNotStartedStatusBar();
            // Ensure the Pub version of DevTools is installed if we're not launching from the daemon or
            // the version from the Dart SDK.
            if (!this.dartCapabilities.supportsDartDevTools) {
                const installedVersion = await this.pubGlobal.installIfRequired({
                    moreInfoLink: undefined,
                    packageID: devtoolsPackageID,
                    packageName: devtoolsPackageName,
                    requiredVersion: "0.9.6",
                    silent,
                    skipOptionalUpdates: !config_1.config.updateDevTools,
                    updateSilently: true,
                });
                // If install failed, we can't start.
                if (!installedVersion) {
                    return undefined;
                }
            }
            // Ignore silent flag if we're using a custom DevTools, because it could
            // take much longer to start and won't be obvious why launching isn't working.
            const isCustomDevTools = !!config_1.config.customDevTools?.path;
            const startingTitle = isCustomDevTools ? "Starting Custom Dart DevTools…" : "Starting Dart DevTools…";
            if (silent && !isCustomDevTools) {
                this.devtoolsUrl = this.startServer();
            }
            else {
                this.devtoolsUrl = vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                    title: startingTitle,
                }, async () => this.startServer());
            }
            // Allow us to override the URL for DevTools as a simple hack for running from a
            // dev version without having to have the SDK set up.
            if (config_1.config.customDevToolsUri)
                this.devtoolsUrl = Promise.resolve(config_1.config.customDevToolsUri);
            // Trigger a reload of any existing embedded windows.
            this.reloadEmbeddedViews();
        }
        const url = await this.devtoolsUrl;
        this.setStartedStatusBar(url);
        return url;
    }
    getDevToolsLocation(pageId) {
        if (pageId === null)
            return "external";
        const locations = config_1.config.devToolsLocation;
        return locations[pageId ?? ""] ?? locations.default ?? "beside";
    }
    /// Spawns DevTools and returns the full URL to open for that session
    ///   eg. http://127.0.0.1:8123/?port=8543
    async spawn(session, options) {
        this.analytics.logDevToolsOpened(options?.commandSource);
        const url = await this.start();
        if (!url)
            return;
        if (options.location === undefined)
            options.location = this.getDevToolsLocation(options.pageId);
        if (!vscode_2.vsCodeVersion.supportsEmbeddedDevTools)
            options.location = "external";
        if (options.reuseWindows === undefined)
            options.reuseWindows = config_1.config.devToolsReuseWindows;
        // When we're running embedded and were asked to open without a page, we should prompt for a page (plus give an option
        // to open non-embedded view).
        if (options.location !== "external" && !options.pageId) {
            const choice = await this.promptForDevToolsPage(!!session);
            if (!choice) // User cancelled
                return;
            else if (choice === "EXTERNAL")
                options.location = "external";
            else
                options.pageId = choice.page.id;
        }
        try {
            await vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
                title: "Opening DevTools...",
            }, async () => {
                const debugCommands = this.debugCommands;
                const canLaunchDevToolsThroughService = utils_2.isRunningLocally
                    && session
                    && debugCommands
                    && options.location === "external"
                    && !constants_1.isDartCodeTestRun
                    && config_1.config.devToolsBrowser === "chrome"
                    && await (0, promises_1.waitFor)(() => debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.LaunchDevTools), 500);
                await this.launch(!!canLaunchDevToolsThroughService, session, options);
            });
            return { url, dispose: () => this.dispose() };
        }
        catch (e) {
            this.showError(e);
        }
    }
    async promptForDevToolsPage(hasSession) {
        const choices = [
            { label: `Open DevTools in Web Browser`, isExternal: true },
            ...constants_1.devToolsPages
                .filter((page) => this.isPageAvailable(hasSession, page))
                .map((page) => ({
                label: `Open ${page.title} Page`,
                page,
            })),
        ];
        const choice = !choices.length
            ? undefined
            : choices.length === 1
                ? choices[0]
                : await vs.window.showQuickPick(choices, { placeHolder: "Which DevTools page?" });
        if (!choice)
            return undefined;
        else if (choice.isExternal)
            return "EXTERNAL";
        else if (choice.page)
            return { page: choice.page };
        else
            return undefined; // Shouldn't get here...
    }
    showError(e) {
        this.logger.error(e);
        void vs.window.showErrorMessage(`${e}`);
    }
    /// When a new Debug session starts, we can reconnect any views that are still open
    // in the disconnected state.
    async reconnectDisconnectedEmbeddedViews(session) {
        if (!this.devtoolsUrl)
            return;
        for (const pageId of Object.keys(devToolsEmbeddedViews)) {
            const panels = devToolsEmbeddedViews[pageId];
            if (!panels)
                continue;
            // If there are disconnected panels for this page, trigger a launch
            // of the page to reuse it.
            const reusablePanel = panels.find((p) => p.session && p.session.hasEnded);
            if (reusablePanel) {
                reusablePanel.session = session;
                await this.launch(false, session, { location: "beside", pageId });
            }
        }
    }
    /// If the DevTools server is restarted, we'll need to reload any DevTools windows that might have stale
    /// server/DTD connections.
    reloadEmbeddedViews() {
        if (!this.devtoolsUrl)
            return;
        for (const pageId of Object.keys(devToolsEmbeddedViews)) {
            const panels = devToolsEmbeddedViews[pageId];
            if (!panels)
                continue;
            // We'll only reload panels that are either connected, or don't have a session (static tools).
            const connectedPanels = panels.filter((p) => !p.session || !p.session.hasEnded);
            for (const panel of connectedPanels) {
                panel.reload();
            }
        }
    }
    getDefaultPage() {
        // use true for hasSession here, because this page is available with or without if it
        // meets the version requirements.
        return this.isPageAvailable(true, constants_1.devToolsHomePage)
            ? constants_1.devToolsHomePage
            : debug_1.isInFlutterDebugModeDebugSession
                ? constants_1.widgetInspectorPage
                : debug_1.isInFlutterProfileModeDebugSession
                    ? constants_1.performancePage
                    : constants_1.cpuProfilerPage;
    }
    async launch(allowLaunchThroughService, session, options) {
        const url = await this.devtoolsUrl;
        if (!url) {
            this.showError(`DevTools URL not available`);
            return;
        }
        const queryParams = {
            ...this.getDefaultQueryParams(),
            ideFeature: options.commandSource,
            inspectorRef: options.inspectorRef,
            theme: config_1.config.useDevToolsDarkTheme && options.location === "external" ? "dark" : undefined,
        };
        const pageId = options.pageId ?? this.getDefaultPage().id;
        const page = constants_1.devToolsPages.find((p) => p.id === pageId);
        const routeId = page ? this.routeIdForPage(page) : pageId;
        // Try to launch via service if allowed.
        if (allowLaunchThroughService && session && await this.launchThroughService(session, { ...options, queryParams, page: routeId }))
            return true;
        // Otherwise, fall back to embedded or launching manually.
        if (pageId)
            queryParams.page = routeId;
        const vmServiceUri = page?.isStaticTool ? undefined : session?.vmServiceUri;
        // We currently only support embedded for pages we know about statically, although since we seem
        // to only use that for a title, we may be able to relax that.
        if (options.location !== "external") {
            if (this.dartCapabilities.requiresDevToolsEmbedFlag)
                queryParams.embed = "true";
            queryParams.embedMode = "one";
            const fullUrl = await this.buildDevToolsUrl(url, queryParams, vmServiceUri, session?.clientVmServiceUri);
            const exposedUrl = await utils_2.envUtils.exposeUrl(fullUrl);
            const pageInfo = page ?? { id: pageId, title: pageId.replace(/_ext^/, "") };
            this.launchInEmbeddedWebView(exposedUrl, session, pageInfo, options.location, options.triggeredAutomatically);
        }
        else {
            const fullUrl = await this.buildDevToolsUrl(url, queryParams, vmServiceUri, session?.clientVmServiceUri);
            await utils_2.envUtils.openInBrowser(fullUrl, this.logger);
        }
    }
    getCacheBust() {
        // Add the version to the querystring to avoid any caching of the index.html page.
        let cacheBust = `dart-${this.dartCapabilities.version}-flutter-${this.flutterCapabilities.version}`;
        // If using a custom version of DevTools, bust regardless of version.
        if (!!config_1.config.customDevTools?.path) { // Don't just check config.customDevTools as it's a VS Code Proxy object
            cacheBust += `-custom-${new Date().getTime()}`;
        }
        return cacheBust;
    }
    getDefaultQueryParams() {
        return {
            cacheBust: this.getCacheBust(),
            ide: "VSCode",
        };
    }
    buildQueryString(queryParams) {
        return Object.keys(queryParams)
            .filter((key) => queryParams[key] !== undefined)
            .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryParams[key] ?? "")}`)
            .join("&");
    }
    async buildDevToolsUrl(baseUrl, queryParams, vmServiceUri, clientVmServiceUri) {
        queryParams = {
            ...this.getDefaultQueryParams(),
            ...queryParams,
        };
        // Handle new Path URL DevTools.
        let path = "";
        if (this.dartCapabilities.supportsDartDevToolsPathUrls) {
            path = queryParams.page ?? "";
            delete queryParams.page;
        }
        if (vmServiceUri) {
            /**
             * In some environments (for ex. g3), the VM Service/DDS could be running on
             * the end user machine (eg. Mac) while the extension host is an SSH remote
             * (eg. Linux).
             *
             * `clientVmServiceUri` indicates a URI that is already accessible on the end
             * user machine without forwarding. `vmServiceUri` indicates a URI that is
             * accessible to the extension host.
             *
             * If a `clientVmServiceUri` exists, use it directly instead of trying to
             * forward a URI from the extension host.
             */
            if (clientVmServiceUri) {
                queryParams.uri = clientVmServiceUri;
            }
            else {
                const exposedUrl = await utils_2.envUtils.exposeUrl(vmServiceUri, this.logger);
                queryParams.uri = exposedUrl;
            }
        }
        const paramsString = this.buildQueryString(queryParams);
        const urlPathSeperator = baseUrl.endsWith("/") ? "" : "/";
        return `${baseUrl}${urlPathSeperator}${path}?${paramsString}`;
    }
    launchInEmbeddedWebView(uri, session, page, location, triggeredAutomatically) {
        const pageId = page.id;
        const pageTitle = page.title;
        if (!devToolsEmbeddedViews[pageId]) {
            devToolsEmbeddedViews[pageId] = [];
        }
        // Look through any open DevTools frames for this page, to see if any are already our session, or
        // are for a session that has been stopped.
        let frame = devToolsEmbeddedViews[pageId]?.find((dtev) => dtev.session === session || (dtev.session && dtev.session.hasEnded));
        if (!frame) {
            frame = new embedded_view_1.DevToolsEmbeddedView(session, uri, pageTitle, location);
            frame.onDispose(() => delete devToolsEmbeddedViews[pageId]);
            devToolsEmbeddedViews[pageId]?.push(frame);
        }
        frame.openedAutomatically = !!triggeredAutomatically;
        frame.load(session, uri);
    }
    async launchThroughService(session, params) {
        try {
            await session.session.customRequest("callService", {
                method: this.debugCommands.vmServices.getServiceMethodName(enums_1.VmService.LaunchDevTools),
                params,
            });
            return true;
        }
        catch (e) {
            this.logger.error(`DevTools failed to launch Chrome, will launch default browser locally instead: ${e.message}`);
            void vs.window.showWarningMessage(`Dart DevTools was unable to launch Chrome so your default browser was launched instead.`, "Show Full Error").then((res) => {
                if (res) {
                    const fileName = `bug-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
                    const tempPath = path.join(os.tmpdir(), fileName);
                    fs.writeFileSync(tempPath, `${e.message ?? e}`);
                    void vscode_1.workspace.openTextDocument(tempPath).then((document) => {
                        void vscode_1.window.showTextDocument(document);
                    });
                }
            });
            return false;
        }
    }
    /// Starts the devtools server and returns the URL of the running app.
    startServer(hasReinstalled = false) {
        return new Promise(async (resolve, reject) => {
            if (this.service) {
                try {
                    this.service.dispose();
                    this.service = undefined;
                    this.devtoolsUrl = undefined;
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            const service = this.service = new DevToolsService(this.logger, this.context.workspaceContext, this.toolingDaemon, this.dartCapabilities);
            this.disposables.push(service);
            await service.connect();
            service.registerForServerStarted((n) => {
                // When a new debug session starts, we need to wait for its VM
                // Service, then register it with this server.
                if (this.debugCommands) {
                    this.disposables.push(this.debugCommands.onDebugSessionVmServiceAvailable(async (session) => {
                        if (session.vmServiceUri) {
                            void service.vmRegister({ uri: session.vmServiceUri });
                            // Also reconnect any orphaned DevTools views.
                            await this.reconnectDisconnectedEmbeddedViews(session);
                        }
                    }));
                }
                // And send any existing sessions we have.
                for (const session of debug_1.debugSessions) {
                    if (session.vmServiceUri)
                        void service.vmRegister({ uri: session.vmServiceUri });
                }
                // Finally, trigger a check of extensions
                // For initial testing, extension recommendations are allow-list. This comes from config so it can be overridden
                // by the user to allow testing the whole flow before being shipped in the list.
                //
                // Adding "*" to the list allows all extension identifiers, useful for testing.
                const defaultAllowList = [
                    "serverpod.serverpod",
                ];
                setTimeout(async () => {
                    try {
                        await this.promptForExtensionRecommendations();
                    }
                    catch (e) {
                        // This can fail if we're restarting/shutting down before it fires.
                        const message = `Failed to check for extension recommendations: ${e}`;
                        console.error(message);
                        this.logger.error(message);
                    }
                }, constants_1.twentySecondsInMs);
                portToBind = n.port;
                resolve(`http://${n.host}:${n.port}/`);
            });
            service.process?.on("close", async (code) => {
                this.devtoolsUrl = undefined;
                this.setNotStartedStatusBar();
                if (code && code !== 0 && !this.isShuttingDown) {
                    // Reset the port to 0 on error in case it was from us trying to reuse the previous port.
                    portToBind = 0;
                    const errorMessage = `${devtoolsPackageName} exited with code ${code}.`;
                    this.logger.error(errorMessage);
                    // If we haven't tried reinstalling, prompt to retry.
                    if (!hasReinstalled) {
                        const resp = await vs.window.showErrorMessage(`${errorMessage} Would you like to try again?`, constants_1.tryAgainAction, constants_1.skipAction);
                        if (resp === constants_1.tryAgainAction) {
                            try {
                                resolve(await this.startServer(true));
                            }
                            catch (e) {
                                reject(e);
                            }
                            return;
                        }
                    }
                    reject(errorMessage);
                }
            });
        });
    }
    async promptForExtensionRecommendations() {
        if (!config_1.config.showExtensionRecommendations)
            return;
        if (!this.service)
            return;
        // Need a server that has the new API for getting extensions.
        if (!this.service.capabilities.supportsVsCodeExtensions)
            return;
        // Need an SDK that includes a version of devtools_shared with all desired fixes.
        if (!this.dartCapabilities.supportsDevToolsVsCodeExtensions)
            return;
        const projectFolders = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: !this.context.workspaceContext.config.forceFlutterWorkspace, searchDepth: config_1.config.projectSearchDepth, onlyWorkspaceRoots: this.context.workspaceContext.config.forceFlutterWorkspace });
        const results = await this.service?.discoverExtensions(projectFolders);
        if (!results)
            return;
        const ignoredExtensions = this.context.getIgnoredExtensionRecommendationIdentifiers();
        const installedExtension = vs.extensions.all.map((e) => e.id);
        const promotableExtensions = Object.keys(results).flatMap((projectRoot) => results[projectRoot]?.extensions ?? [])
            // Remove user-ignored extensions.
            .filter((e) => ignoredExtensions.find((ignored) => ignored.trim().toLowerCase() === e.extension.trim().toLowerCase()) === undefined)
            // Remove already-installed extensions.
            .filter((e) => installedExtension.find((installed) => installed.trim().toLowerCase() === e.extension.trim().toLowerCase()) === undefined);
        // If there are multiple we'll just pick the first. The user will either install or ignore
        // and then next time we'd pick the next.
        const promotableExtension = promotableExtensions?.at(0);
        if (promotableExtension) {
            void this.extensionRecommentations.promoteExtension({
                identifier: promotableExtension.extension,
                message: `A third-party extension is available for package:${promotableExtension.packageName}`,
            });
        }
    }
    dispose() {
        this.isShuttingDown = true;
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DevToolsManager = DevToolsManager;
/// Handles running the DevTools process (via pub, or dart).
///
/// This is not used for internal workspaces (see startDevToolsFromDaemon).
class DevToolsService extends stdio_service_1.StdIOService {
    workspaceContext;
    toolingDaemon;
    dartCapabilities;
    capabilities = devtools_server_1.DevToolsServerCapabilities.empty;
    constructor(logger, workspaceContext, toolingDaemon, dartCapabilities) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.DevTools), config_1.config.maxLogLineLength);
        this.workspaceContext = workspaceContext;
        this.toolingDaemon = toolingDaemon;
        this.dartCapabilities = dartCapabilities;
    }
    async connect() {
        const workspaceContext = this.workspaceContext;
        const toolingDaemon = this.toolingDaemon;
        const dartCapabilities = this.dartCapabilities;
        const dartVm = path.join(workspaceContext.sdks.dart, constants_1.dartVMPath);
        const customDevTools = config_1.config.customDevTools;
        // Used for both `'dart devtools' and custom devtools
        const devToolsArgs = [
            "--machine",
            "--allow-embedding",
        ];
        if (toolingDaemon) {
            const dtdUri = await toolingDaemon.dtdUri;
            if (dtdUri) {
                devToolsArgs.push("--dtd-uri");
                devToolsArgs.push(dtdUri);
                if (this.dartCapabilities.supportsDevToolsDtdExposedUri) {
                    const exposedDtdUri = await utils_2.envUtils.exposeUrl(dtdUri, this.logger);
                    if (exposedDtdUri !== dtdUri) {
                        devToolsArgs.push("--dtd-exposed-uri");
                        devToolsArgs.push(exposedDtdUri);
                    }
                }
            }
        }
        const executionInfo = customDevTools?.path ?
            {
                args: ["serve", ...(customDevTools.args ?? [])],
                cwd: customDevTools.path,
                env: customDevTools.env,
                executable: path.join(customDevTools.path, customDevTools.legacy ? constants_1.devToolsToolLegacyPath : constants_1.devToolsToolPath),
            }
            : dartCapabilities.supportsDartDevTools
                ? (0, utils_1.usingCustomScript)(dartVm, ["devtools"], workspaceContext.config?.flutterDevToolsScript)
                : (0, processes_1.getPubExecutionInfo)(dartCapabilities, workspaceContext.sdks.dart, ["global", "run", "devtools"]);
        const binPath = executionInfo.executable;
        const binArgs = [...executionInfo.args, ...devToolsArgs];
        const binCwd = executionInfo.cwd;
        const binEnv = executionInfo.env;
        // Store the port we'll use for later so we can re-bind to the same port if we restart.
        portToBind = config_1.config.devToolsPort // Always config first
            || portToBind; // Then try the last port we bound this session
        if (portToBind && !customDevTools?.path) {
            binArgs.push("--port");
            binArgs.push(portToBind.toString());
        }
        this.registerForServerStarted((n) => {
            if (n.protocolVersion)
                this.capabilities.version = n.protocolVersion;
            this.additionalPidsToTerminate.push(n.pid);
        });
        this.createProcess(binCwd, binPath, binArgs, { toolEnv: (0, processes_2.getToolEnv)(), envOverrides: binEnv });
    }
    shouldHandleMessage(message) {
        return message.startsWith("{") && message.endsWith("}");
    }
    // TODO: Remove this if we fix the DevTools server (and rev min version) to not use method for
    // the server.started event.
    isNotification(msg) { return msg.event || msg.method === "server.started"; }
    async handleNotification(evt) {
        switch (evt.method || evt.event) {
            case "server.started":
                await this.notify(this.serverStartedSubscriptions, evt.params);
                break;
        }
    }
    serverStartedSubscriptions = [];
    registerForServerStarted(subscriber) {
        return this.subscribe(this.serverStartedSubscriptions, subscriber);
    }
    vmRegister(request) {
        return this.sendRequest("vm.register", request);
    }
    async discoverExtensions(projectRoots) {
        return this.sendRequest("vscode.extensions.discover", {
            rootPaths: projectRoots,
        });
    }
}


/***/ }),

/***/ 1227:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeFlutterSdk = initializeFlutterSdk;
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const channels = __importStar(__webpack_require__(269));
const extension_1 = __webpack_require__(291);
const utils_1 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
async function initializeFlutterSdk(logger, flutterScript) {
    logger.info(`Flutter is not initialized, running 'flutter doctor' to force...`);
    try {
        await vscode_1.window.withProgress({
            location: vscode_1.ProgressLocation.Notification,
            title: constants_1.initializingFlutterMessage,
        }, async (progress, cancellationToken) => {
            const proc = (0, processes_1.safeToolSpawn)(undefined, flutterScript, ["doctor", "-v"]);
            // Show the output in an output channel so if it gets stuck the user can see it.
            const channel = channels.getOutputChannel(`flutter doctor`);
            channel.show();
            channels.runProcessInOutputChannel(proc, channel);
            cancellationToken.onCancellationRequested((e) => {
                logger.info(`User canceled!`);
                proc.kill();
            });
            // Log this to general as it's startup stuff that can't be captured with
            // Capture Logs so log it to the main log file.
            (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, proc);
            return new Promise((resolve, reject) => proc.on("exit", (code) => {
                if (code) {
                    const ringLogContents = extension_1.ringLog.toString();
                    logger.error(`Failed to initialize Flutter: Process exited with code ${code}.`);
                    void vscode_1.window.showErrorMessage(`Failed to initialize Flutter: Process exited with code ${code}.`, constants_1.showLogAction).then((chosenAction) => {
                        if (chosenAction === constants_1.showLogAction)
                            void (0, utils_1.openLogContents)(undefined, ringLogContents);
                    });
                    reject();
                }
                else {
                    resolve();
                }
            }));
        });
        logger.info(`Flutter initialized!`);
    }
    catch (e) {
        logger.warn(`Flutter initialization failed, proceeding without!`);
    }
}


/***/ }),

/***/ 7030:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlutterSnippets = getFlutterSnippets;
const fs = __importStar(__webpack_require__(9896));
const https = __importStar(__webpack_require__(5692));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const fs_1 = __webpack_require__(2587);
const processes_1 = __webpack_require__(8141);
function getFlutterSnippets(logger, sdks, capabilities) {
    if (capabilities.supportsFlutterCreateListSamples)
        return getFlutterSnippetsFromSdk(logger, sdks);
    return getFlutterSnippetsFromWeb();
}
async function getFlutterSnippetsFromSdk(logger, sdks) {
    if (!sdks.flutter)
        throw new Error("Flutter SDK not available");
    const binPath = path.join(sdks.flutter, constants_1.flutterPath);
    const fileName = `flutter-samples-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
    const tempPath = path.join(os.tmpdir(), fileName);
    try {
        const res = await (0, processes_1.runToolProcess)(logger, undefined, binPath, ["create", "--list-samples", tempPath]);
        if (res.exitCode !== 0)
            throw new Error(`Failed to get Flutter samples from SDK (${res.exitCode})\n\n${res.stderr}\n\n${res.stdout}`);
        const json = fs.readFileSync(tempPath, { encoding: "utf8" });
        return JSON.parse(json);
    }
    finally {
        (0, fs_1.tryDeleteFile)(tempPath);
    }
}
function getFlutterSnippetsFromWeb() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "api.flutter.dev",
            method: "GET",
            path: "/snippets/index.json",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Flutter samples ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                const chunks = [];
                resp.on("data", (b) => chunks.push(b.toString()));
                resp.on("end", () => {
                    const json = chunks.join("");
                    resolve(JSON.parse(json));
                });
            }
        });
        req.end();
    });
}


/***/ }),

/***/ 6357:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSdkManager = exports.DartSdkManager = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
class SdkManager {
    logger;
    sdks;
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    changeSdk() {
        if (this.sdkPaths)
            this.searchForSdks(this.sdkPaths).catch((e) => console.error(e));
        else
            void vs.window.showWarningMessage("Set `${configName}` to enable fast SDK switching.");
    }
    async searchForSdks(sdkPaths) {
        let allPaths = [];
        for (const sdkPath of sdkPaths.filter(fs.existsSync)) {
            allPaths.push(sdkPath);
            // Add immediate children to support folders-of-SDKs.
            allPaths = allPaths.concat(await (0, fs_1.getChildFolders)(this.logger, sdkPath));
        }
        // Add in the current path if it's not there.
        if (this.currentSdk && !allPaths.includes(this.currentSdk))
            allPaths.push(this.currentSdk);
        const sdkFolders = allPaths
            // We don't need to check isDirectory, since existsSync() will just return false
            // if we join a filename on the end of another.
            // .filter((f) => fs.statSync(f).isDirectory()) // Only directories.
            .filter((f) => fs.existsSync(path.join(f, this.executablePath))); // Only those that look like SDKs.
        const sdkItems = sdkFolders.map((f) => {
            // Resolve symlinks so we look in correct folder for version file.
            const actualBinary = fs.realpathSync(path.join(f, this.executablePath));
            // Then we need to take the executable name and /bin back off
            const actualFolder = path.dirname(path.dirname(actualBinary));
            const version = (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: actualFolder });
            return {
                description: f === this.currentSdk && this.configuredSdk ? "Current setting" : "",
                detail: (0, fs_1.homeRelativePath)(f),
                folder: f,
                label: version ? this.getLabel(version) : "Unknown version",
                version,
            };
        })
            .sort((a, b) => (0, utils_1.versionIsAtLeast)(a.version || "0.0.0", b.version || "0.0.0") ? 1 : -1);
        if (sdkItems.length === 0)
            return;
        const items = [{
                description: !this.configuredSdk ? "Current setting" : "",
                detail: !this.configuredSdk ? `Found at ${this.currentSdk}` : undefined,
                folder: undefined,
                label: "Auto-detect SDK location",
                version: undefined,
            }].concat(sdkItems);
        void vs.window.showQuickPick(items, { placeHolder: "Select an SDK to use" })
            .then((sdk) => {
            if (!sdk)
                return;
            const folder = (0, fs_1.homeRelativePath)(sdk.folder);
            if (config_1.config.sdkSwitchingTarget === "global") {
                // Clear any existing workspace setting first.
                this.clearWorkspaceSdk();
                this.setSdk(folder, vs.ConfigurationTarget.Global);
            }
            else {
                this.setSdk(folder, vs.ConfigurationTarget.Workspace);
            }
        });
    }
}
class DartSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.sdkPaths; }
    get currentSdk() { return this.sdks.dart; }
    get configuredSdk() { return config_1.config.sdkPath; }
    get configName() { return "dart.sdkPaths"; }
    get executablePath() { return constants_1.dartVMPath; }
    getLabel(version) {
        return `Dart SDK ${version}`;
    }
    clearWorkspaceSdk() {
        if (config_1.config.workspaceSdkPath)
            void config_1.config.setSdkPath(undefined, vs.ConfigurationTarget.Workspace);
    }
    setSdk(folder, target) {
        void config_1.config.setSdkPath(folder, target);
    }
}
exports.DartSdkManager = DartSdkManager;
class FlutterSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.flutterSdkPaths; }
    get currentSdk() { return this.sdks.flutter; }
    get configuredSdk() { return config_1.config.flutterSdkPath; }
    get configName() { return "dart.flutterSdkPaths"; }
    get executablePath() { return constants_1.flutterPath; }
    getLabel(version) {
        return `Flutter SDK ${version}`;
    }
    clearWorkspaceSdk() {
        if (config_1.config.workspaceFlutterSdkPath)
            void config_1.config.setFlutterSdkPath(undefined, vs.ConfigurationTarget.Workspace);
    }
    setSdk(folder, target) {
        void config_1.config.setFlutterSdkPath(folder, target);
    }
}
exports.FlutterSdkManager = FlutterSdkManager;


/***/ }),

/***/ 2049:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarVersionTracker = void 0;
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const constants_2 = __webpack_require__(5706);
const status_bar_1 = __webpack_require__(719);
const config_1 = __webpack_require__(7678);
class StatusBarVersionTracker {
    disposables = [];
    constructor(workspaceContext, isLsp) {
        const isFlutter = workspaceContext.hasAnyFlutterProjects;
        const dartIsFromFlutter = workspaceContext.sdks.dartSdkIsFromFlutter;
        const canChangeFlutterSdk = config_1.config.flutterSdkPaths && config_1.config.flutterSdkPaths.length > 0;
        const canChangeDartSdk = !isFlutter && config_1.config.sdkPaths && config_1.config.sdkPaths.length > 0;
        const flutterVersion = this.versionOrLatest(workspaceContext.sdks.flutterVersion);
        let dartVersion = this.versionOrLatest(workspaceContext.sdks.dartVersion);
        if (dartIsFromFlutter)
            dartVersion = `${dartVersion} (Flutter)`;
        if (dartVersion) {
            this.addStatusBarItem("dart.sdkVersion", "Dart", dartVersion, canChangeDartSdk ? "dart.changeSdk" : undefined);
        }
        if (isFlutter && flutterVersion) {
            this.addStatusBarItem("dart.flutterSdkVersion", "Flutter", flutterVersion, canChangeFlutterSdk ? "dart.changeFlutterSdk" : undefined);
        }
    }
    versionOrLatest(version) {
        return version === constants_1.MAX_VERSION
            ? "latest"
            : version === constants_1.MISSING_VERSION_FILE_VERSION
                ? "unknown"
                : version;
    }
    addStatusBarItem(id, kind, versionNumber, command) {
        const statusBarItem = (0, status_bar_1.getLanguageStatusItem)(id, constants_2.ANALYSIS_FILTERS);
        statusBarItem.text = versionNumber;
        statusBarItem.detail = `${kind} SDK`;
        statusBarItem.name = `${kind} SDK`;
        if (command) {
            statusBarItem.command = {
                command,
                title: "change",
            };
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.StatusBarVersionTracker = StatusBarVersionTracker;


/***/ }),

/***/ 7663:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkForStandardDartSdkUpdates = checkForStandardDartSdkUpdates;
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
async function checkForStandardDartSdkUpdates(logger, workspaceContext) {
    if (!config_1.config.checkForSdkUpdates || workspaceContext.config.disableSdkUpdateChecks)
        return;
    // Sometimes people use the Dart SDK inside Flutter for non-Flutter projects. Since that SDK is
    // versioned with Flutter, it never makes sense to prompt the user to update the Dart SDK.
    if (workspaceContext.sdks.dartSdkIsFromFlutter)
        return;
    const dartSdkVersion = workspaceContext.sdks.dartVersion;
    try {
        const version = await (0, utils_3.getLatestSdkVersion)();
        if (!dartSdkVersion || (0, utils_1.versionIsAtLeast)(dartSdkVersion, version))
            return;
        const goToDownloadsAction = "Go to Dart Downloads";
        const dontShowAgainAction = "Disable Update Checks";
        const message = `Version ${version} of the Dart SDK is available (you have ${dartSdkVersion}). Some features of Dart Code may not work correctly with an old SDK.`;
        const action = await vscode_1.window.showWarningMessage(message, goToDownloadsAction, dontShowAgainAction);
        if (action === goToDownloadsAction)
            await utils_2.envUtils.openInBrowser(constants_1.DART_DOWNLOAD_URL);
        else if (action === dontShowAgainAction)
            void config_1.config.setCheckForSdkUpdates(false);
    }
    catch (e) {
        logger.error(e);
    }
}


/***/ }),

/***/ 7200:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdkUtils = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const promises_1 = __webpack_require__(1902);
const workspace_1 = __webpack_require__(5851);
const utils_2 = __webpack_require__(1894);
const workspace_2 = __webpack_require__(9329);
const analytics_1 = __webpack_require__(5922);
const add_sdk_to_path_1 = __webpack_require__(439);
const config_1 = __webpack_require__(7678);
const extension_1 = __webpack_require__(291);
const utils_3 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
const flutter_1 = __webpack_require__(1227);
// TODO: Tidy this class up (it exists mainly to share logger).
class SdkUtils {
    logger;
    context;
    analytics;
    constructor(logger, context, analytics) {
        this.logger = logger;
        this.context = context;
        this.analytics = analytics;
    }
    handleMissingSdks(workspaceContext) {
        const context = this.context;
        // Note: This code only runs if we fail to find the Dart SDK, or fail to find the Flutter SDK
        // and are in a Flutter project. In the case where we fail to find the Flutter SDK but are not
        // in a Flutter project (eg. we ran Flutter Doctor without the extension activated) then
        // this code will not be run as the extension will activate normally, and then the command-handling
        // code for each command will detect the missing Flutter SDK and respond appropriately.
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.createProject", () => {
            this.showRelevantActivationFailureMessage(workspaceContext, true, "flutter.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("dart.createProject", () => {
            this.showRelevantActivationFailureMessage(workspaceContext, false, "dart.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("_dart.flutter.createSampleProject", () => {
            this.showRelevantActivationFailureMessage(workspaceContext, true, "_dart.flutter.createSampleProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.doctor", () => {
            this.showRelevantActivationFailureMessage(workspaceContext, true, "flutter.doctor");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.upgrade", () => {
            this.showRelevantActivationFailureMessage(workspaceContext, true, "flutter.upgrade");
        }));
        // Wait a while before showing the error to allow the code above to have run if it will.
        setTimeout(() => {
            // Only show the "startup" message if we didn't already show another message as
            // a result of one of the above commands beinv invoked.
            if (!this.hasShownActivationFailure) {
                if (workspaceContext.hasAnyFlutterProjects) {
                    this.showRelevantActivationFailureMessage(workspaceContext, true);
                }
                else if (workspaceContext.hasAnyStandardDartProjects) {
                    this.showRelevantActivationFailureMessage(workspaceContext, false);
                }
                else {
                    this.logger.error("No Dart or Flutter SDK was found. Suppressing prompt because it doesn't appear that a Dart/Flutter project is open.");
                }
            }
        }, 500);
        return;
    }
    hasShownActivationFailure = false;
    showRelevantActivationFailureMessage(workspaceContext, isFlutter, commandToReRun) {
        if (isFlutter && workspaceContext.sdks.flutter && !workspaceContext.sdks.dart) {
            this.showFluttersDartSdkActivationFailure();
        }
        else if (isFlutter) {
            this.showFlutterActivationFailure(commandToReRun);
        }
        else {
            this.showDartActivationFailure(commandToReRun);
        }
        if (!this.hasShownActivationFailure) {
            this.analytics.logSdkDetectionFailure();
            this.hasShownActivationFailure = true;
        }
    }
    showFluttersDartSdkActivationFailure() {
        void (0, utils_3.promptToReloadExtension)("Could not find Dart in your Flutter SDK. " +
            "Please run 'flutter doctor' in the terminal then reload the project once all issues are resolved.", "Reload", // eslint-disable-line @typescript-eslint/indent
        true);
    }
    showFlutterActivationFailure(commandToReRun) {
        void this.showSdkActivationFailure("Flutter", (p) => this.findFlutterSdk(p), constants_1.FLUTTER_DOWNLOAD_URL, (p) => config_1.config.setGlobalFlutterSdkPath(p), commandToReRun);
    }
    showDartActivationFailure(commandToReRun) {
        void this.showSdkActivationFailure("Dart", (p) => this.findDartSdk(p), constants_1.DART_DOWNLOAD_URL, (p) => config_1.config.setGlobalDartSdkPath(p), commandToReRun);
    }
    async showSdkActivationFailure(sdkType, search, downloadUrl, saveSdkPath, commandToReRun) {
        const downloadAction = "Download SDK";
        const locateAction = "Locate SDK";
        let displayMessage = `Could not find a ${sdkType} SDK. Please download, or, if already downloaded, click '${locateAction}'.`;
        while (true) {
            const ringLogContents = extension_1.ringLog.toString();
            const selectedItem = await vscode_1.window.showErrorMessage(displayMessage, downloadAction, locateAction, constants_1.showLogAction);
            // TODO: Refactor/reformat/comment this code - it's messy and hard to understand!
            if (selectedItem === locateAction) {
                const selectedFolders = await vscode_1.window.showOpenDialog({ canSelectFolders: true, openLabel: `Set ${sdkType} SDK folder` });
                if (selectedFolders && selectedFolders.length > 0) {
                    const matchingSdkFolder = search(selectedFolders.map((f) => (0, fs_1.fsPath)(f)));
                    if (matchingSdkFolder.sdkPath) {
                        await saveSdkPath(matchingSdkFolder.sdkPath);
                        await (0, utils_3.promptToReloadExtension)();
                        if (commandToReRun) {
                            void vscode_1.commands.executeCommand(commandToReRun);
                        }
                        break;
                    }
                    else {
                        displayMessage = `That folder does not appear to be a ${sdkType} SDK.`;
                    }
                }
            }
            else if (selectedItem === downloadAction) {
                if (sdkType === "Flutter") {
                    const cloneResult = await this.tryFlutterCloneIfGitAvailable(commandToReRun);
                    switch (cloneResult) {
                        case analytics_1.CloneSdkResult.succeeded:
                        case analytics_1.CloneSdkResult.cancelled:
                            break;
                        case analytics_1.CloneSdkResult.noGit:
                            if (await vscode_1.window.showErrorMessage("Unable to clone Flutter because Git was not found. Please clone or download the Flutter SDK manually.", "Setup Instructions"))
                                await utils_2.envUtils.openInBrowser(downloadUrl);
                        case analytics_1.CloneSdkResult.failed:
                            if (await vscode_1.window.showErrorMessage("Failed to clone Flutter using Git. Please clone or download the Flutter SDK manually.", "Setup Instructions"))
                                await utils_2.envUtils.openInBrowser(downloadUrl);
                            break;
                    }
                }
                else {
                    await utils_2.envUtils.openInBrowser(downloadUrl);
                    break;
                }
            }
            else if (selectedItem === constants_1.showLogAction) {
                void (0, utils_3.openLogContents)(undefined, ringLogContents);
                break;
            }
            else {
                break;
            }
        }
    }
    async tryFlutterCloneIfGitAvailable(commandToReRun) {
        let gitExecutable = "git";
        const gitAvailable = await vscode_1.window.withProgress({
            cancellable: true,
            location: vscode_1.ProgressLocation.Notification,
            title: "Checking for git",
        }, async (_, cancellationToken) => {
            try {
                // First try to find git from VS Code. It searches both PATH and some other well-known
                // locations.
                try {
                    const gitExtension = vscode_1.extensions.getExtension("vscode.git");
                    // If the extension isn't already activated, probably it's disabled or the user isn't
                    // using it.
                    if (gitExtension && gitExtension.isActive) {
                        const gitApi = gitExtension.exports.getAPI(1);
                        const gitApiPath = gitApi?.git.path;
                        if (gitApiPath)
                            gitExecutable = gitApiPath;
                    }
                }
                catch (e) {
                    // Could be that Git extension is disabled or "git.enabled" setting is false.
                }
                const gitProc = await (0, processes_1.runToolProcess)(this.logger, undefined, gitExecutable, ["--version"], undefined, cancellationToken);
                if (cancellationToken.isCancellationRequested)
                    return GitOperationResult.cancelled;
                if (gitProc.exitCode !== 0) {
                    this.logger.error(`Failed to run "git --version" to detect git, so skipping "Clone Flutter SDK" workflow:\n`
                        + `Exit code: ${gitProc.exitCode}\n`
                        + `stdout: ${gitProc.stdout}\n`
                        + `stderr: ${gitProc.stderr}\n`);
                    return GitOperationResult.error;
                }
            }
            catch (e) {
                if (cancellationToken.isCancellationRequested)
                    return GitOperationResult.cancelled;
                this.logger.error(`Failed to run "git --version" to detect git, so skipping "Clone Flutter SDK" workflow: ${e}`);
                return GitOperationResult.error;
            }
            return GitOperationResult.success;
        });
        if (gitAvailable !== GitOperationResult.success) {
            const result = gitAvailable === GitOperationResult.cancelled
                ? analytics_1.CloneSdkResult.cancelled
                : analytics_1.CloneSdkResult.noGit;
            this.analytics.logGitCloneSdk(result);
            return result;
        }
        const cloneResult = await this.promptForFlutterClone(gitExecutable);
        const flutterSdkFolder = cloneResult.folder;
        if (!flutterSdkFolder)
            return cloneResult.result;
        await config_1.config.setGlobalFlutterSdkPath(flutterSdkFolder);
        await (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkFolder, constants_1.flutterPath));
        await new add_sdk_to_path_1.AddSdkToPath(this.logger, this.context, this.analytics).promptToAddToPath("Flutter", flutterSdkFolder);
        await vscode_1.commands.executeCommand("_dart.reloadExtension");
        if (commandToReRun)
            void vscode_1.commands.executeCommand(commandToReRun);
        return analytics_1.CloneSdkResult.succeeded;
    }
    async promptForFlutterClone(gitExecutable) {
        const selectedFolders = await vscode_1.window.showOpenDialog({
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false,
            openLabel: `Clone Flutter`,
            title: "Select Folder for Flutter SDK",
        });
        if (selectedFolders && selectedFolders.length === 1) {
            const workingDirectory = (0, fs_1.fsPath)(selectedFolders[0]);
            const cloneResult = await this.cloneFlutterWithProgress(gitExecutable, workingDirectory);
            const didClone = cloneResult === GitOperationResult.success;
            const result = cloneResult === GitOperationResult.success
                ? analytics_1.CloneSdkResult.succeeded
                : cloneResult === GitOperationResult.cancelled
                    ? analytics_1.CloneSdkResult.cancelled
                    : analytics_1.CloneSdkResult.failed;
            this.analytics.logGitCloneSdk(result);
            return { result, folder: didClone ? path.join(workingDirectory, "flutter") : undefined };
        }
        return { result: analytics_1.CloneSdkResult.cancelled };
    }
    async cloneFlutterWithProgress(gitExecutable, workingDirectory) {
        const gitUrl = "https://github.com/flutter/flutter.git";
        return await vscode_1.window.withProgress({
            cancellable: true,
            location: vscode_1.ProgressLocation.Notification,
            title: constants_1.cloningFlutterMessage,
        }, async (_, cancellationToken) => {
            try {
                const gitProc = await (0, processes_1.runToolProcess)(this.logger, workingDirectory, gitExecutable, ["clone", "-b", "stable", gitUrl], undefined, cancellationToken);
                if (cancellationToken.isCancellationRequested)
                    return GitOperationResult.cancelled;
                if (gitProc.exitCode !== 0) {
                    this.logger.error(`Failed to run "git clone" to download Flutter, so skipping "clone Flutter SDK" workflow:\n`
                        + `Exit code: ${gitProc.exitCode}\n`
                        + `stdout: ${gitProc.stdout}\n`
                        + `stderr: ${gitProc.stderr}\n`);
                    if (!cancellationToken.isCancellationRequested)
                        void vscode_1.window.showErrorMessage(`Failed to clone Flutter: ${gitProc.stderr}`);
                    return GitOperationResult.error;
                }
                return GitOperationResult.success;
            }
            catch (e) {
                if (cancellationToken.isCancellationRequested)
                    return GitOperationResult.cancelled;
                this.logger.error(`Failed to run "git clone" to download Flutter, so skipping "clone Flutter SDK" workflow: ${e}`);
                return GitOperationResult.error;
            }
        });
    }
    async scanWorkspace() {
        this.logger.info("Searching for SDKs...");
        const pathOverride = process.env.DART_PATH_OVERRIDE || "";
        const normalPath = process.env.PATH || "";
        const paths = (pathOverride + path.delimiter + normalPath).split(path.delimiter).filter((p) => p);
        // Some paths to search after PATH as a final resort.
        const fallbackSdkSearchPaths = [
            process.env.FLUTTER_ROOT,
            constants_1.isLinux ? "~/snap/flutter/common/flutter" : undefined,
            "~/flutter-sdk",
            "/google/flutter",
            "/opt/flutter", // https://github.com/Dart-Code/Dart-Code/issues/5174
        ];
        this.logger.info("Environment PATH:");
        for (const p of paths)
            this.logger.info(`    ${p}`);
        // If we are running the analyzer remotely over SSH, we only support an analyzer, since none
        // of the other SDKs will work remotely. Also, there is no need to validate the sdk path,
        // since that file will exist on a remote machine.
        if (config_1.config.analyzerSshHost) {
            return new workspace_2.WorkspaceContext({
                dart: config_1.config.sdkPath,
                dartSdkIsFromFlutter: false,
                flutter: undefined,
                isPreReleaseSdk: false,
            }, {}, false, false, false, false);
        }
        // TODO: This has gotten very messy and needs tidying up...
        let firstFlutterProject;
        let hasAnyFlutterProject = false;
        let hasAnyWebProject = false;
        let hasAnyStandardDartProject = false;
        const possibleProjects = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { searchDepth: config_1.config.projectSearchDepth });
        // Scan through them all to figure out what type of projects we have.
        for (const folder of possibleProjects) {
            const hasPubspecFile = (0, fs_1.hasPubspec)(folder);
            const refsFlutter = hasPubspecFile && (0, fs_1.projectReferencesFlutter)(folder);
            const refsWeb = false; // hasPubspecFile && referencesWeb(folder);
            const hasFlutterCreateProjectTriggerFile = fs.existsSync(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
            // Special case to detect the Flutter repo root, so we always consider it a Flutter project and will use the local SDK
            const isFlutterRepo = fs.existsSync(path.join(folder, "bin/flutter")) && fs.existsSync(path.join(folder, "bin/cache/dart-sdk"));
            // Since we just blocked on a lot of sync FS, yield.
            await promises_1.resolvedPromise;
            const isSomethingFlutter = refsFlutter || hasFlutterCreateProjectTriggerFile || isFlutterRepo;
            if (isSomethingFlutter) {
                this.logger.info(`Found Flutter project at ${folder}:
			Mobile? ${refsFlutter}
			Web? ${refsWeb}
			Create Trigger? ${hasFlutterCreateProjectTriggerFile}
			Flutter Repo? ${isFlutterRepo}`);
            }
            // Track the first Flutter Project so we can try finding the Flutter SDK from its packages file.
            firstFlutterProject = firstFlutterProject || (isSomethingFlutter ? folder : undefined);
            // Set some flags we'll use to construct the workspace, so we know what things we need to light up.
            hasAnyFlutterProject = hasAnyFlutterProject || isSomethingFlutter;
            hasAnyWebProject = hasAnyWebProject || refsWeb;
            hasAnyStandardDartProject = hasAnyStandardDartProject || (!isSomethingFlutter && hasPubspecFile);
        }
        // Certain types of workspaces will have special config, so read them here.
        const workspaceConfig = {};
        // Helper that searches for a specific folder/file up the tree and
        // runs some specific processing.
        const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
        const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
        const processWorkspaceType = async (search, process) => {
            for (const folder of topLevelFolders) {
                const root = await search(this.logger, folder);
                if (root) {
                    process(this.logger, workspaceConfig, root, config_1.config);
                    return root;
                }
            }
            return undefined;
        };
        await processWorkspaceType(findDartSdkRoot, workspace_1.processDartSdkRepository);
        await processWorkspaceType(findBazelWorkspaceRoot, workspace_1.processBazelWorkspace);
        const fuchsiaRoot = await processWorkspaceType(findFuchsiaRoot, workspace_1.processFuchsiaWorkspace);
        if (fuchsiaRoot) {
            this.logger.info(`Found Fuchsia root at ${fuchsiaRoot}`);
            if (hasAnyStandardDartProject)
                this.logger.info(`Found Fuchsia project that is not vanilla Flutter`);
        }
        let flutterSdkPath;
        if (workspaceConfig.forceFlutterWorkspace) {
            hasAnyFlutterProject = true;
            flutterSdkPath = workspaceConfig?.flutterSdkHome;
        }
        else {
            // User provided custom command to obtain the sdk path
            const flutterSdkPathFromCommand = config_1.config.getFlutterSdkCommand && await this.runCustomGetSDKCommand(config_1.config.getFlutterSdkCommand, "dart.getFlutterSdkCommand", !!config_1.config.workspaceGetFlutterSdkCommand);
            const flutterSdkSearchPaths = [
                config_1.config.flutterSdkPath,
                flutterSdkPathFromCommand?.path,
                // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                fuchsiaRoot && path.join(fuchsiaRoot, "lib/flutter"),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart-pkg/git/flutter"),
                firstFlutterProject,
                firstFlutterProject && (0, fs_1.extractFlutterSdkPathFromPackagesFile)(firstFlutterProject),
                firstFlutterProject && path.join(firstFlutterProject, ".flutter"),
                firstFlutterProject && path.join(firstFlutterProject, "vendor/flutter"),
                ...paths,
                ...fallbackSdkSearchPaths,
            ].filter(utils_1.notUndefined);
            let flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
            const sdkInitScript = flutterSdkResult.sdkInitScript;
            // Handle the case where the Flutter snap has not been initialised.
            if (!flutterSdkResult.sdkPath && sdkInitScript && flutterSdkResult.candidatePaths.includes(sdkInitScript)) {
                // Trigger initialization.
                this.logger.info(`No Flutter SDK found, but ${sdkInitScript} looks like an init script so attempting to initialize...`);
                await (0, flutter_1.initializeFlutterSdk)(this.logger, sdkInitScript);
                // Then search again.
                this.logger.info(`Snap initialization completed, searching for Flutter SDK again...`);
                flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
            }
            if (hasAnyFlutterProject) {
                void this.warnIfBadConfigSdk(config_1.config.flutterSdkPath, flutterSdkResult, "dart.flutterSdkPath", !!config_1.config.workspaceFlutterSdkPath);
            }
            flutterSdkPath = flutterSdkResult.sdkPath;
        }
        // Since we just blocked on a lot of sync FS, yield.
        await promises_1.resolvedPromise;
        // If we're a Flutter workspace but we couldn't get the version, try running Flutter to initialise it first.
        // Do this before searching for the Dart SDK, as it might download the Dart SDK we'd like to find.
        let hasAttemptedFlutterInitialization = false;
        if (hasAnyFlutterProject && flutterSdkPath && !workspaceConfig.skipFlutterInitialization) {
            const flutterVersion = workspaceConfig?.flutterVersion ?? (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath });
            const flutterNeedsInitializing = !flutterVersion
                || !fs.existsSync(path.join(flutterSdkPath, "bin/cache/dart-sdk"));
            if (flutterNeedsInitializing) {
                hasAttemptedFlutterInitialization = true;
                await (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
            }
        }
        // User provided custom command to obtain the sdk path
        const dartSdkPathFromCommand = config_1.config.getDartSdkCommand && await this.runCustomGetSDKCommand(config_1.config.getDartSdkCommand, "dart.getDartSdkCommand", !!config_1.config.workspaceGetDartSdkCommand);
        const dartSdkSearchPaths = [
            // TODO: These could move into processFuchsiaWorkspace and be set on the config?
            fuchsiaRoot && path.join(fuchsiaRoot, "topaz/tools/prebuilt-dart-sdk", `${constants_1.dartPlatformName}-x64`),
            fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks/dart-sdk"),
            fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
            fuchsiaRoot && path.join(fuchsiaRoot, "dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
            firstFlutterProject && flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk"),
            config_1.config.sdkPath,
            dartSdkPathFromCommand?.path,
        ].concat(paths)
            // The above array only has the Flutter SDK	in the search path if we KNOW it's a flutter
            // project, however this doesn't cover the activating-to-run-flutter.createProject so
            // we need to always look in the flutter SDK, but only AFTER the users PATH so that
            // we don't prioritise it over any real Dart versions.
            .concat([flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk")])
            .concat([workspaceConfig.defaultDartSdk])
            .filter(utils_1.notUndefined);
        // Since we just blocked on a lot of sync FS, yield.
        await promises_1.resolvedPromise;
        const dartSdkResult = this.findDartSdk(dartSdkSearchPaths);
        if (!hasAnyFlutterProject && !fuchsiaRoot && !firstFlutterProject && !workspaceConfig.forceFlutterWorkspace) {
            void this.warnIfBadConfigSdk(config_1.config.sdkPath, dartSdkResult, "dart.sdkPath", !!config_1.config.workspaceSdkPath);
        }
        let dartSdkPath = dartSdkResult.sdkPath;
        // Since we just blocked on a lot of sync FS, yield.
        await promises_1.resolvedPromise;
        // If we still don't have a Dart SDK, but we do have a Flutter SDK and we did not already try to initialize, then
        // try again here. This could happen if we were not in a Flutter project (so didn't try to initialize before) but
        // still need a Dart SDK (for example, we were activated by running Flutter: New Project in an empty workspace.. we
        // wouldn't trigger the code above).
        if (!hasAttemptedFlutterInitialization && flutterSdkPath && !dartSdkPath) {
            await (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
            dartSdkPath = this.findDartSdk([path.join(flutterSdkPath, "bin/cache/dart-sdk")]).sdkPath;
        }
        // It's possible we've opened a folder without a pubspec/etc., so before assuming this is a non-Dart project, check
        // for any Dart files in the top few folders.
        if (!hasAnyFlutterProject && !hasAnyStandardDartProject) {
            // Only look in the root and known folders to avoid a potentially slow full workspace search.
            const hasAnyDartFile = !!(await vscode_1.workspace.findFiles("{*.dart,lib/*.dart,bin/*.dart,tool/*.dart,test/*.dart}", undefined, 1)).length;
            hasAnyStandardDartProject = hasAnyDartFile;
        }
        // Sometimes the extension is activated when there's not a Dart/Flutter project open because the
        // events are not fine-grain enough (for example `activationEvent:onDebugDynamicConfigurations`), so
        // if this seems to be the case, turn off a few things that are likely not relevant for the user.
        if (!hasAnyFlutterProject && !hasAnyStandardDartProject) {
            const wc = workspaceConfig;
            wc.disableAnalytics = true;
            wc.disableStartupPrompts = true;
            wc.disableSdkUpdateChecks = true;
        }
        const isDartFromFlutter = (!!dartSdkResult.originalPath && (0, utils_1.isDartSdkFromFlutter)(dartSdkResult.originalPath)) || (!!dartSdkPath && (0, utils_1.isDartSdkFromFlutter)(dartSdkPath));
        const dartVersion = (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: dartSdkPath });
        let flutterVersion = workspaceConfig?.flutterVersion ?? (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath });
        // Sometimes the Flutter 'version' file is missing (see https://github.com/flutter/flutter/issues/142521)
        // but this is almost always on main/master, so in this case treat us as a max version that has everything enabled
        // instead of nothing.
        if (!flutterVersion && flutterSdkPath && !fs.existsSync(path.join(flutterSdkPath, "version")))
            flutterVersion = constants_1.MISSING_VERSION_FILE_VERSION;
        const relevantSdkVersion = hasAnyFlutterProject ? flutterVersion : dartVersion;
        const isPreReleaseSdk = !!relevantSdkVersion?.includes("-");
        return new workspace_2.WorkspaceContext({
            dart: dartSdkPath,
            dartSdkIsFromFlutter: isDartFromFlutter,
            dartVersion,
            flutter: flutterSdkPath,
            flutterVersion,
            isPreReleaseSdk,
        }, workspaceConfig, hasAnyFlutterProject, hasAnyWebProject, hasAnyStandardDartProject, !!fuchsiaRoot && hasAnyStandardDartProject);
    }
    async runCustomGetSDKCommand(command, sdkConfigName, isWorkspaceSetting) {
        const baseWorkDir = this.getWorkingDirectoryForGetSdkCommand();
        // No workspace open, nothing to do
        if (!baseWorkDir)
            return { path: undefined };
        const cmdWorkDir = command.cwd ?? ".";
        const cmdWorkDirAbs = path.isAbsolute(cmdWorkDir) ? cmdWorkDir : path.join(baseWorkDir, cmdWorkDir);
        try {
            const commandResult = await (0, processes_1.runToolProcess)(this.logger, cmdWorkDirAbs, command.executable, command.args ?? [], command.env);
            if (commandResult.exitCode !== 0) {
                throw new Error(`Exited with non-zero code (${commandResult.exitCode})`);
            }
            const sdkPath = commandResult.stdout.trim();
            if (!sdkPath) {
                throw new Error("No output from command");
            }
            // Check if the path exists
            if (!fs.existsSync(sdkPath)) {
                throw new Error(`Path does not exist: ${sdkPath}`);
            }
            return { path: sdkPath };
        }
        catch (e) {
            void this.warnIfBadSDKCommandOutput(e, cmdWorkDirAbs, sdkConfigName, isWorkspaceSetting);
            return { error: `${e}` };
        }
    }
    /**
     * Obtains a sane default as a working directory for the get SDK command.
     * When using a multiroot workspace setup, return the directory of the workspace file
     * Otherwise, return the path of the workspace directory.
     * If there is no workspace directory, return undefined
     */
    getWorkingDirectoryForGetSdkCommand() {
        const workspaceFile = vscode_1.workspace.workspaceFile;
        const workspaceFolders = vscode_1.workspace.workspaceFolders;
        if (workspaceFile) {
            // Use the workspace file's directory in a multi-root setup
            return path.dirname((0, fs_1.fsPath)(workspaceFile));
        }
        else if (workspaceFolders && workspaceFolders.length > 0) {
            // Fallback to the first workspace folder
            return (0, fs_1.fsPath)(workspaceFolders[0].uri);
        }
        // No workspace open
        return undefined;
    }
    async warnIfBadConfigSdk(configSdkPath, foundSdk, sdkConfigName, isWorkspaceSetting) {
        const foundSdkPath = foundSdk?.originalPath;
        if (!configSdkPath || !foundSdkPath)
            return;
        const normalizedConfigSdkPath = path.normalize(path.normalize(configSdkPath).toLowerCase() + path.sep);
        const normalizedFoundSdkPath = path.normalize(path.normalize(foundSdkPath).toLowerCase() + path.sep);
        if (normalizedConfigSdkPath !== normalizedFoundSdkPath) {
            const action = await vscode_1.window.showWarningMessage(`The SDK configured in ${sdkConfigName} is not a valid SDK folder: ${configSdkPath}`, constants_1.openSettingsAction);
            if (constants_1.openSettingsAction === action) {
                await this.openSettingsFile(sdkConfigName, isWorkspaceSetting);
            }
        }
    }
    async warnIfBadSDKCommandOutput(error, workDir, sdkConfigName, isWorkspaceSetting) {
        const action = await vscode_1.window.showWarningMessage(`Failed to obtain the SDK from the command: ${error}. Working directory: ${workDir}.`, constants_1.openSettingsAction);
        if (constants_1.openSettingsAction === action) {
            await this.openSettingsFile(sdkConfigName, isWorkspaceSetting);
        }
    }
    async openSettingsFile(sdkConfigName, isWorkspaceSetting) {
        await vscode_1.commands.executeCommand(isWorkspaceSetting ? "workbench.action.openWorkspaceSettingsFile" : "workbench.action.openSettingsJson", {
            revealSetting: { key: sdkConfigName },
        });
    }
    findDartSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.dart, (p) => this.containsFile(p, constants_1.dartVMPath) && this.containsFile(p, constants_1.analyzerSnapshotPath));
    }
    findFlutterSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.flutter, 
        // Also check for some additional files so we won't detect `/usr/bin/flutter` as a Flutter SDK at `/usr`.
        (p) => this.containsFile(p, constants_1.flutterPath) && (this.containsFile(p, "analysis_options.yaml")
            || this.containsFile(p, "bin/flutter.bat") // Exists on non-Windows clones of Git and is an obvious sign of the SDK.
            || this.containsFile(p, "bin/internal/engine.version")));
    }
    containsFile(folder, filePath) {
        const fullPath = path.join(folder, filePath);
        return fs.existsSync(fullPath) && fs.statSync(fullPath).isFile();
    }
    searchPaths(paths, executableFilename, postFilter) {
        this.logger.info(`Searching for ${executableFilename}`);
        const rawSdkPaths = paths
            .filter((p) => p)
            .map(utils_2.resolvePaths)
            .filter(utils_1.notUndefined);
        // Any that don't end with bin, add it on (as an extra path) since some of our
        // paths may come from places that don't already include it (for ex. the
        // user config.sdkPath).
        const isBinFolder = (f) => ["bin", "sbin"].includes(path.basename(f));
        let sdkPaths = (0, utils_1.flatMap)(rawSdkPaths, (p) => isBinFolder(p)
            ? [{ originalPath: p, sdkPath: p }]
            : [{ originalPath: p, sdkPath: p }, { originalPath: p, sdkPath: path.join(p, "bin") }]);
        // TODO: Make the list unique, but preserve the order of the first occurrences. We currently
        // have uniq() and unique(), so also consolidate them.
        this.logger.info(`    Looking for ${executableFilename} in:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${this.sdkDisplayString(p)}`);
        // Restrict only to the paths that have the executable.
        sdkPaths = sdkPaths.filter((p) => fs.existsSync(path.join(p.sdkPath, executableFilename)));
        this.logger.info(`    Found at:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${this.sdkDisplayString(p)}`);
        // Keep track if we find something that looks like a package manager init script. These are
        // symlinks like `flutter` that resolve to other binaries (like `snap` or `hermit`) and may need
        // to be executed if we don't find a real SDK.
        let sdkInitScript;
        // Convert all the paths to their resolved locations.
        sdkPaths = sdkPaths.map((sdkPath) => {
            // In order to handle symlinks on the binary (not folder), we need to add the executableName before calling realpath.
            const fullPath = path.join(sdkPath.sdkPath, executableFilename);
            const realExecutableLocation = fs.realpathSync(fullPath);
            if (realExecutableLocation.toLowerCase() !== fullPath.toLowerCase())
                this.logger.info(`Following symlink: ${fullPath} -> ${realExecutableLocation}`);
            // If the symlink resolves to a package manager binary, it's not a real SDK
            // and we should return as-is rather than walk up two levels, as we
            // may want to use the presence of this to trigger initialisation.
            const targetBaseName = path.basename(realExecutableLocation);
            if (targetBaseName !== executableFilename) {
                this.logger.info(`Target ${targetBaseName} is not ${executableFilename}, assuming ${fullPath} is a package manager init script`);
                sdkInitScript = fullPath;
                return { originalPath: sdkPath.originalPath, sdkPath: fullPath };
            }
            // Then we need to take the executable name and /bin back off
            return { originalPath: sdkPath.originalPath, sdkPath: path.dirname(path.dirname(realExecutableLocation)) };
        });
        // Now apply any post-filters.
        this.logger.info("    Candidate paths to be post-filtered:");
        for (const p of sdkPaths)
            this.logger.info(`        ${this.sdkDisplayString(p)}`);
        if (!postFilter)
            postFilter = ((_) => true);
        const sdkPath = sdkPaths.find((pathInfo) => postFilter(pathInfo.sdkPath));
        if (sdkPath)
            this.logger.info(`    Found at ${this.sdkDisplayString(sdkPath)}`);
        this.logger.info(`    Returning SDK path ${sdkPath?.sdkPath} for ${executableFilename}`);
        return {
            candidatePaths: sdkPaths.map((p) => p.sdkPath),
            sdkInitScript,
            ...sdkPath,
        };
    }
    sdkDisplayString(sdk) {
        return `${sdk.originalPath}${sdk.sdkPath !== sdk.originalPath ? ` -> ${sdk.sdkPath}` : ""}`;
    }
}
exports.SdkUtils = SdkUtils;
async function findFuchsiaRoot(logger, folder) {
    return findRootContaining(folder, ".jiri_root", "DIRECTORY");
}
async function findBazelWorkspaceRoot(logger, folder) {
    return findRootContaining(folder, "WORKSPACE", "FILE");
}
async function findGitRoot(logger, folder) {
    return findRootContaining(folder, ".git", "ANY");
}
async function findDartSdkRoot(logger, folder) {
    const gitRoot = await findGitRoot(logger, folder);
    if (gitRoot && fs.existsSync(path.join(gitRoot, "README.dart-sdk")) && fs.existsSync(path.join(gitRoot, "DEPS")))
        return gitRoot;
    else
        return undefined;
}
function findRootContaining(folder, childName, expect) {
    if (folder) {
        // Walk up the directories from the workspace root, and see if there
        // exists a directory which has `childName` file/directory as a child.
        let child = folder;
        while (child) {
            try {
                const stat = fs.statSync(path.join(child, childName));
                if (expect === "ANY" || (expect === "FILE" ? stat.isFile() : stat.isDirectory())) {
                    return child;
                }
            }
            catch { }
            const parentDir = path.dirname(child);
            if (child === parentDir)
                break;
            child = parentDir;
        }
    }
    return undefined;
}
var GitOperationResult;
(function (GitOperationResult) {
    GitOperationResult[GitOperationResult["success"] = 0] = "success";
    GitOperationResult[GitOperationResult["error"] = 1] = "error";
    GitOperationResult[GitOperationResult["cancelled"] = 2] = "cancelled";
})(GitOperationResult || (GitOperationResult = {}));
;


/***/ }),

/***/ 3295:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFileUriLinkProvider = void 0;
const vs = __importStar(__webpack_require__(1398));
const fs_1 = __webpack_require__(2587);
const terminal_link_provider_utils_1 = __webpack_require__(494);
class DartFileUriLinkProvider {
    async provideTerminalLinks(context, token) {
        return this.getLinks(context.line);
    }
    getLinks(content) {
        return (0, terminal_link_provider_utils_1.findFileUriLinks)(content);
    }
    handleTerminalLink(link) {
        const filePath = (0, fs_1.fsPath)(link.uri);
        void vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
    async provideDocumentLinks(document, token) {
        const links = await this.getLinks(document.getText());
        return links.map((link) => {
            const range = new vs.Range(document.positionAt(link.startIndex), document.positionAt(link.startIndex + link.length));
            return new vs.DocumentLink(range, link.uri.with({ fragment: (0, terminal_link_provider_utils_1.formatLineColFragment)(link) }));
        });
    }
}
exports.DartFileUriLinkProvider = DartFileUriLinkProvider;


/***/ }),

/***/ 4693:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartPackageUriLinkProvider = void 0;
const vs = __importStar(__webpack_require__(1398));
const package_map_1 = __webpack_require__(1721);
const utils_1 = __webpack_require__(949);
const terminal_link_provider_utils_1 = __webpack_require__(494);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
class DartPackageUriLinkProvider {
    logger;
    context;
    packageMaps;
    packageMapDiscovery;
    constructor(logger, context) {
        this.logger = logger;
        this.context = context;
        context.events.onPackageMapChange.listen(() => {
            this.packageMaps = undefined;
            this.packageMapDiscovery = undefined;
        });
    }
    async discoverPackageMaps() {
        if (this.packageMapDiscovery) {
            return this.packageMapDiscovery;
        }
        this.packageMapDiscovery = new Promise(async (resolve) => {
            const projectFolders = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            this.packageMaps = {};
            for (const projectFolder of projectFolders) {
                this.packageMaps[projectFolder] = package_map_1.PackageMap.loadForProject(this.logger, projectFolder);
            }
            resolve();
        });
        return this.packageMapDiscovery;
    }
    isKnownPackage(packageName) {
        return !!(this.packageMaps && Object.values(this.packageMaps).find((m) => m.packages[packageName]));
    }
    resolvePackageUri(uri) {
        if (!this.packageMaps)
            return undefined;
        for (const packageMap of Object.values(this.packageMaps)) {
            const filePath = packageMap.resolvePackageUri(uri);
            if (filePath)
                return filePath;
        }
        return undefined;
    }
    provideTerminalLinks(context, token) {
        return this.getLinks(context.line);
    }
    async getLinks(content) {
        if (!this.packageMaps)
            await this.discoverPackageMaps();
        return (0, terminal_link_provider_utils_1.findPackageUriLinks)(content, (name) => this.isKnownPackage(name));
    }
    handleTerminalLink(link) {
        const filePath = this.resolvePackageUri(link.uri);
        if (!filePath) {
            void vs.window.showErrorMessage(`Unable to find root for package ${link.packageName}`);
            return;
        }
        void vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
    async provideDocumentLinks(document, token) {
        const links = await this.getLinks(document.getText());
        return links.map((link) => {
            const range = new vs.Range(document.positionAt(link.startIndex), document.positionAt(link.startIndex + link.length));
            const filePath = this.resolvePackageUri(link.uri);
            if (!filePath)
                return undefined;
            return new vs.DocumentLink(range, vs.Uri.file(filePath).with({ fragment: (0, terminal_link_provider_utils_1.formatLineColFragment)(link) }));
        }).filter(utils_1.notUndefined);
    }
}
exports.DartPackageUriLinkProvider = DartPackageUriLinkProvider;


/***/ }),

/***/ 2250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VsCodeTestController = void 0;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_uri_1 = __webpack_require__(8945);
const test_model_1 = __webpack_require__(5871);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const test_1 = __webpack_require__(672);
const config_1 = __webpack_require__(7678);
const terminals_1 = __webpack_require__(5850);
const runnableTestTag = new vs.TestTag("DartRunnableTest");
class VsCodeTestController {
    logger;
    model;
    discoverer;
    disposables = [];
    controller;
    itemForNode = new WeakMap();
    nodeForItem = new WeakMap();
    testRuns = {};
    constructor(logger, model, discoverer) {
        this.logger = logger;
        this.model = model;
        this.discoverer = discoverer;
        const controller = vs.tests.createTestController("dart", "Dart & Flutter");
        this.controller = controller;
        this.disposables.push(controller);
        this.disposables.push(model.onDidChangeTreeData((node) => this.onDidChangeTreeData(node)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((e) => this.handleDebugSessionEnd(e)));
        model.addTestEventListener(this);
        if (discoverer)
            controller.resolveHandler = (item) => this.resolveTestItem(item);
        controller.createRunProfile("Run", vs.TestRunProfileKind.Run, (request, token) => this.runTests(false, request, token), false, runnableTestTag);
        controller.createRunProfile("Debug", vs.TestRunProfileKind.Debug, (request, token) => this.runTests(true, request, token), true, runnableTestTag);
    }
    async resolveTestItem(item) {
        if (!this.discoverer)
            return;
        if (!item) {
            await this.discoverer.ensureSuitesDiscovered();
            return;
        }
        const node = this.nodeForItem.get(item);
        if (node instanceof test_model_1.SuiteNode)
            await this.discoverer.discoverTestsForSuite(node);
    }
    registerTestRun(dartCodeDebugSessionID, run, shouldEndWithSession) {
        this.testRuns[dartCodeDebugSessionID] = { run, shouldEndWithSession };
    }
    handleDebugSessionEnd(e) {
        const run = this.testRuns[e.configuration.dartCodeDebugSessionID];
        if (run?.shouldEndWithSession)
            run.run.end();
    }
    getLatestData(test) {
        return this.nodeForItem.get(test);
    }
    async runTests(debug, request, token) {
        await this.discoverer?.ensureSuitesDiscovered();
        const testsToRun = new Set();
        const testsToExclude = new Set();
        const isRunningAll = !request.include?.length;
        (request.include ?? this.controller.items).forEach((item) => testsToRun.add(item));
        request.exclude?.forEach((item) => { testsToRun.delete(item); testsToExclude.add(item); });
        // For each item in the set, remove any of its descendants because they will be run by the parent.
        this.removeRedundantChildNodes(testsToRun);
        // Similarly, remove any excluded tests that are already excluded by their suite, because that will allow the
        // optimisation below (which requires only excluded suites) to work in more cases.
        this.removeRedundantChildNodes(testsToExclude);
        const run = this.controller.createTestRun(request);
        try {
            // As an optimisation, if we're no-debug and running complete files (eg. all included or excluded items are
            // suites), we can run the "fast path" in a single `dart test` invocation.
            const nodesToRun = [...testsToRun].map((item) => this.nodeForItem.get(item));
            const nodesToExclude = [...testsToExclude].map((item) => this.nodeForItem.get(item));
            if (!debug && nodesToRun.every((item) => item instanceof test_model_1.SuiteNode) && nodesToExclude.every((item) => item instanceof test_model_1.SuiteNode)) {
                await vs.commands.executeCommand("_dart.runAllTestsWithoutDebugging", nodesToRun, nodesToExclude, run, isRunningAll);
                return;
            }
            // Group into suites since we need to run each seperately (although we can run
            // multiple tests witthin one suite together).
            const testsBySuite = new Map();
            testsToRun.forEach((test) => {
                const node = this.nodeForItem.get(test);
                if (!node)
                    return;
                const testNodes = testsBySuite.get(node.suiteData) ?? [];
                testsBySuite.set(node.suiteData, testNodes);
                testNodes.push(node);
            });
            const suppressPrompts = testsBySuite.size > 1;
            for (const suite of testsBySuite.keys()) {
                const nodes = testsBySuite.get(suite);
                if (!nodes)
                    continue;
                const command = debug
                    ? "_dart.startDebuggingTestsFromVsTestController"
                    : "_dart.startWithoutDebuggingTestsFromVsTestController";
                await vs.commands.executeCommand(command, suite, nodes, suppressPrompts, run);
            }
        }
        finally {
            run.end();
        }
    }
    /// Removes any items from a set that are children of other items in the set.
    removeRedundantChildNodes(set) {
        // For each item in the set, remove any of its descendants because they will be run by the parent.
        function removeWithDescendants(item) {
            set.delete(item);
            item.children.forEach((child) => removeWithDescendants(child));
        }
        const all = [...set];
        all.forEach((item) => item.children.forEach((child) => removeWithDescendants(child)));
    }
    /// Replace the whole tree.
    replaceAll() {
        const suiteTestItems = Array.from(this.model.suites.values())
            .map((suite) => this.createOrUpdateNode(suite.node, true))
            .filter(utils_1.notUndefined);
        this.controller.items.replace(suiteTestItems);
    }
    onDidChangeTreeData(event) {
        if (event === undefined) {
            this.replaceAll();
            return;
        }
        if (event.nodeWasRemoved) {
            this.removeNode(event.node);
            return;
        }
        this.createOrUpdateNode(event.node, false);
    }
    /// Creates a node or if it already exists, updates it.
    ///
    /// Recursively creates/updates children unless `updateChildren` is `false` and this node
    /// already existed.
    ///
    /// Does not add the item to its parent, so that the calling code can .replace()
    /// all children if required.
    ///
    /// Returns undefined if in the case of an error or a node that should
    /// not be shown in the tree.
    createOrUpdateNode(node, updateChildren) {
        const shouldShowNode = this.shouldShowNode(node);
        let collection;
        if (node instanceof test_model_1.SuiteNode) {
            collection = this.controller.items;
        }
        else {
            collection = this.itemForNode.get(node.parent)?.children;
        }
        if (!collection) {
            this.logger.error(`Failed to find parent (${node.parent?.label}) of node (${node.label})`);
            return;
        }
        const nodeId = this.idForNode(node);
        let existingItem = collection.get(nodeId);
        const didCreate = !existingItem;
        if (!shouldShowNode && existingItem)
            collection.delete(nodeId);
        // Create new item if required.
        if (!existingItem) {
            const newItem = this.createTestItem(node);
            if (!shouldShowNode)
                return;
            collection.add(newItem);
            existingItem = newItem;
        }
        else {
            // Otherwise, update this item to match the latest state.
            this.updateFields(existingItem, node);
            if (!shouldShowNode)
                return;
        }
        // For new suites without chilren, set canResolveChildren because we can
        // open the file and discover tests from the Outline if the user expands them.
        if (node instanceof test_model_1.SuiteNode && node.children.length === 0)
            existingItem.canResolveChildren = true;
        if (didCreate || updateChildren) {
            existingItem.children.replace(node.children.map((c) => this.createOrUpdateNode(c, updateChildren)).filter(utils_1.notUndefined));
        }
        return existingItem;
    }
    /// Removes a node from the tree.
    removeNode(node) {
        const collection = node instanceof test_model_1.SuiteNode
            ? this.controller.items
            : this.itemForNode.get(node.parent)?.children;
        if (!collection)
            return;
        const nodeId = this.idForNode(node);
        const existingItem = collection.get(nodeId);
        if (existingItem)
            collection.delete(nodeId);
    }
    shouldShowNode(node) {
        if (config_1.config.showSkippedTests)
            return true;
        if (node instanceof test_model_1.TestNode || node instanceof test_model_1.GroupNode) {
            return !node.isSkipped;
        }
        else {
            // Otherwise show eg. suites are always shown.
            return true;
        }
    }
    idForNode(node) {
        if (node instanceof test_model_1.SuiteNode)
            return `SUITE:${node.suiteData.path}`;
        // We use suiteData.path here because we want to treat (tearDownAll) from a shared
        // file as a child of the suite node for the instances where it ran in that suite.
        if (node instanceof test_model_1.GroupNode)
            return `GROUP:${node.suiteData.path}:${node.name}`;
        if (node instanceof test_model_1.TestNode)
            return `TEST:${node.suiteData.path}:${node.name}`;
        throw new Error(`Tried to create ID for unknown node type! ${node.label}`);
    }
    cleanLabel(label) {
        return label.trim().split("\n").map((l) => l.trim()).join(" ");
    }
    labelForSuite(node) {
        const suitePath = node.suiteData.path;
        const wf = vs.workspace.getWorkspaceFolder(vs.Uri.file(suitePath));
        return wf
            ? path.relative((0, fs_1.fsPath)(wf.uri), node.suiteData.path)
            : path.basename(suitePath);
    }
    createTestItem(node) {
        const id = this.idForNode(node);
        const label = node instanceof test_model_1.SuiteNode
            ? this.labelForSuite(node)
            : this.cleanLabel(node.label ?? "<unnamed>");
        // We use path here (and not suiteData.path) because we want to
        // navigate to the source for setup/teardown which may be in a
        // different file to the test.
        const uri = vs.Uri.file(node.path);
        const item = this.controller.createTestItem(id, label, uri);
        this.updateFields(item, node);
        this.nodeForItem.set(item, node);
        this.itemForNode.set(node, item);
        item.children.replace(node.children.map((c) => this.createTestItem(c)));
        return item;
    }
    updateFields(item, node) {
        if (this.isRunnableTest(node))
            item.tags = [runnableTestTag];
        else
            item.tags = [];
        item.description = node.description;
        if ((node instanceof test_model_1.GroupNode || node instanceof test_model_1.TestNode) && node.range) {
            item.range = new vs.Range(new vs.Position(node.range.start.line, node.range.start.character), new vs.Position(node.range.end.line, node.range.end.character));
        }
    }
    isRunnableTest(node) {
        const label = node.label;
        if (!label)
            return false;
        if ((0, test_1.isSetupOrTeardownTestName)(label))
            return false;
        if (this.discoverer?.fileTracker.supportsPackageTest(vscode_uri_1.URI.file(node.suiteData.path)) === false)
            return false;
        return true;
    }
    getOrCreateTestRun(sessionID) {
        let run = this.testRuns[sessionID]?.run;
        if (!run) {
            const request = new vs.TestRunRequest();
            request.preserveFocus = false; // TODO(dantup): Remove this when we crank VS Code min version in future.
            run = this.controller.createTestRun(request, undefined, true);
            this.registerTestRun(sessionID, run, true);
        }
        return run;
    }
    suiteDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    groupDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testStarted(sessionID, node) {
        this.testDiscovered(sessionID, node);
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            run.started(item);
    }
    testOutput(sessionID, node, message) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            this.appendTestOutputLines(run, item, message);
    }
    testErrorOutput(sessionID, node, message, isFailure, stack) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            // TODO(dantup): If the change described here:
            //  https://github.com/microsoft/vscode/issues/185778#issuecomment-1603742803
            //  goes ahead, then if isFailure=true, capture the output of this as the
            //  "lastFailureEvent" and then use that to pass to .failed() in testDone
            //  instead of making a new TestMessage.
            this.appendTestOutputLines(run, item, `${message}\r\n${stack}`.trimEnd());
        }
    }
    appendTestOutputLines(run, item, message) {
        if (message.trim() === "")
            return;
        run.appendOutput(`${(0, terminals_1.formatForTerminal)(message)}\r\n`, undefined, item);
    }
    testDone(sessionID, node, result) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            switch (result) {
                case "skipped":
                    run.skipped(item);
                    break;
                case "success":
                    run.passed(item, node.duration);
                    break;
                default:
                    const outputEvents = node.outputEvents;
                    const output = outputEvents.map((output) => this.formatNotification(output)).join("\n");
                    const testMessage = new vs.TestMessage((0, terminals_1.formatForTerminal)(output));
                    if (result === "failure")
                        run.failed(item, testMessage, node.duration);
                    else
                        run.errored(item, testMessage, node.duration);
                    break;
            }
        }
    }
    suiteDone(sessionID, node) { }
    formatNotification(error) {
        if (!("error" in error))
            return error.message;
        return [
            error.error ?? "",
            error.stackTrace ?? "",
        ].join("\n").trim();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.VsCodeTestController = VsCodeTestController;


/***/ }),

/***/ 3411:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showUserPrompts = showUserPrompts;
exports.handleNewProjects = handleNewProjects;
exports.checkForLargeNumberOfTodos = checkForLargeNumberOfTodos;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const fs_1 = __webpack_require__(2587);
const extension_utils_1 = __webpack_require__(6584);
const user_prompts_1 = __webpack_require__(7020);
const utils_1 = __webpack_require__(1894);
const sdk_1 = __webpack_require__(7177);
const config_1 = __webpack_require__(7678);
async function showUserPrompts(logger, context, webClient, analytics, workspaceContext, dartCapabilities, extensionRecommendations) {
    if (workspaceContext.config.disableStartupPrompts)
        return;
    function shouldSuppress(key) {
        const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
        return context.get(stateKey) === true;
    }
    /// Shows a prompt and stores the return value. Prompt should return `true` to mark
    /// this extension as seen-forever and it won't be shown again. Returning anything
    /// else will allow the prompt to appear again next time.
    function showPrompt(key, prompt) {
        const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
        prompt().then((res) => context.update(stateKey, res), error);
    }
    if (await (0, user_prompts_1.showSdkDeprecationNoticeIfAppropriate)(logger, context, workspaceContext, dartCapabilities))
        return; // We showed it, so skip any more.
    if (workspaceContext.hasAnyFlutterProjects && !extension_utils_1.hasFlutterExtension && !shouldSuppress(constants_1.installFlutterExtensionPromptKey)) {
        // It's possible that we got here when the user installed the Flutter extension, because it causes Dart to install
        // first and activate. So, before showing this prompt we'll wait 30 seconds and then check if we still don't
        // have the Flutter extension, and then show the prompt.
        await new Promise((resolve) => setTimeout(resolve, 20000));
        if (!(0, extension_utils_1.checkHasFlutterExtension)())
            return showPrompt(constants_1.installFlutterExtensionPromptKey, () => extensionRecommendations.promptToInstallFlutterExtension());
    }
    // Check the user hasn't installed Flutter in a forbidden location that will cause issues.
    if (workspaceContext.hasAnyFlutterProjects && workspaceContext.sdks.flutter) {
        if (constants_1.isWin) {
            const forbiddenLocations = [
                process.env.COMMONPROGRAMFILES,
                process.env["COMMONPROGRAMFILES(x86)"],
                process.env.CommonProgramW6432,
                process.env.PROGRAMFILES,
                process.env.ProgramW6432,
                process.env["PROGRAMFILES(X86)"],
            ];
            const installedForbiddenLocation = forbiddenLocations.find((fl) => fl && workspaceContext.sdks.flutter?.toLowerCase().startsWith(fl.toLowerCase()));
            if (installedForbiddenLocation) {
                logger.error(`Flutter is installed in protected folder: ${installedForbiddenLocation}`);
                void vs.window.showErrorMessage("The Flutter SDK is installed in a protected folder and may not function correctly. Please move the SDK to a location that is user-writable without Administration permissions and restart.");
            }
        }
    }
    const extensionVersionForReleaseNotes = (0, extension_utils_1.getExtensionVersionForReleaseNotes)();
    const lastSeenVersionNotification = context.lastSeenVersion;
    if (!lastSeenVersionNotification) {
        // If we've not got a stored version, this is the first install, so just
        // stash the current version and don't show anything.
        context.lastSeenVersion = extensionVersionForReleaseNotes;
    }
    else if (!extension_utils_1.isDevExtension && lastSeenVersionNotification !== extensionVersionForReleaseNotes) {
        const versionLink = extensionVersionForReleaseNotes.split(".").slice(0, 2).join(".").replace(".", "-");
        void promptToShowReleaseNotes(extension_utils_1.extensionVersion, versionLink).then(() => context.lastSeenVersion = extensionVersionForReleaseNotes);
        return;
    }
    if (workspaceContext.hasAnyFlutterProjects) {
        if (await (0, user_prompts_1.showFlutterSurveyNotificationIfAppropriate)(context, webClient, analytics, utils_1.envUtils.openInBrowser, Date.now(), logger))
            return; // Bail if we showed it, so we won't show any other notifications.
    }
    if (!shouldSuppress(constants_1.useRecommendedSettingsPromptKey) && !hasAnyExistingDartSettings()) {
        showPrompt(constants_1.useRecommendedSettingsPromptKey, promptToUseRecommendedSettings);
        return;
    }
}
function hasAnyExistingDartSettings() {
    const topLevelConfig = vs.workspace.getConfiguration("", null);
    for (const configKey of ["dart", "[dart]"]) {
        const dartConfig = topLevelConfig.inspect(configKey);
        if (dartConfig?.globalValue || dartConfig?.globalLanguageValue
            || dartConfig?.workspaceValue || dartConfig?.workspaceLanguageValue
            || dartConfig?.workspaceFolderValue || dartConfig?.workspaceFolderLanguageValue)
            return true;
    }
    return false;
}
async function promptToUseRecommendedSettings() {
    const action = await vs.window.showInformationMessage("Would you like to use recommended VS Code settings for Dart & Flutter?", constants_1.yesAction, constants_1.noAction, constants_1.showRecommendedSettingsAction);
    if (action === constants_1.yesAction) {
        await vs.commands.executeCommand("dart.writeRecommendedSettings");
    }
    else if (action === constants_1.showRecommendedSettingsAction) {
        await utils_1.envUtils.openInBrowser(constants_1.recommendedSettingsUrl);
    }
    return true;
}
async function promptToShowReleaseNotes(versionDisplay, versionLink) {
    const res = await vs.window.showInformationMessage(`Dart Code has been updated to v${versionDisplay}`, `Show Release Notes`);
    if (res) {
        await utils_1.envUtils.openInBrowser(`https://dartcode.org/releases/v${versionLink}/`);
    }
    return true; // Always mark this as done; we don't want to prompt the user multiple times.
}
function error(err) {
    void vs.window.showErrorMessage(`${err.message ?? err}`);
}
async function handleNewProjects(logger, context) {
    await Promise.all((0, utils_1.getDartWorkspaceFolders)().map(async (wf) => {
        try {
            await handleDartCreateTrigger(logger, wf, constants_1.DART_CREATE_PROJECT_TRIGGER_FILE);
            await handleFlutterCreateTrigger(wf);
        }
        catch (e) {
            logger.error("Failed to create project");
            logger.error(e);
            void vs.window.showErrorMessage("Failed to create project");
        }
    }));
}
async function handleDartCreateTrigger(logger, wf, triggerFilename) {
    const triggerFile = path.join((0, fs_1.fsPath)(wf.uri), triggerFilename);
    if (!fs.existsSync(triggerFile))
        return;
    const templateJson = fs.readFileSync(triggerFile).toString().trim();
    let template;
    try {
        template = JSON.parse(templateJson);
    }
    catch (e) {
        logger.error("Failed to get project templates");
        logger.error(e);
        void vs.window.showErrorMessage("Failed to get project templates to create project");
        return;
    }
    fs.unlinkSync(triggerFile);
    logger.info(`Creating Dart project for ${(0, fs_1.fsPath)(wf.uri)}`, enums_1.LogCategory.CommandProcesses);
    try {
        (0, sdk_1.markProjectCreationStarted)();
        const success = await createDartProject((0, fs_1.fsPath)(wf.uri), template.name);
        if (success) {
            logger.info(`Fetching packages for newly-created project`, enums_1.LogCategory.CommandProcesses);
            await vs.commands.executeCommand("dart.getPackages", wf.uri);
            handleDartWelcome(wf, template);
            logger.info(`Finished creating new project!`, enums_1.LogCategory.CommandProcesses);
        }
        else {
            logger.info(`Failed to create new project`, enums_1.LogCategory.CommandProcesses);
        }
    }
    finally {
        (0, sdk_1.markProjectCreationEnded)();
    }
}
async function handleFlutterCreateTrigger(wf) {
    const flutterTriggerFile = path.join((0, fs_1.fsPath)(wf.uri), constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE);
    if (!fs.existsSync(flutterTriggerFile))
        return;
    const jsonString = fs.readFileSync(flutterTriggerFile).toString().trim();
    const json = jsonString ? JSON.parse(jsonString) : undefined;
    fs.unlinkSync(flutterTriggerFile);
    try {
        (0, sdk_1.markProjectCreationStarted)();
        const success = await createFlutterProject((0, fs_1.fsPath)(wf.uri), json);
        if (success)
            handleFlutterWelcome(wf, json);
    }
    finally {
        (0, sdk_1.markProjectCreationEnded)();
    }
}
async function createDartProject(projectPath, templateName) {
    const code = await vs.commands.executeCommand("_dart.create", projectPath, templateName);
    return code === 0;
}
async function createFlutterProject(projectPath, triggerData) {
    const projectName = triggerData?.sample ? "sample" : undefined;
    const args = { projectPath, projectName, triggerData };
    const code = await vs.commands.executeCommand("_flutter.create", args);
    return code === 0;
}
function handleFlutterWelcome(workspaceFolder, triggerData) {
    const entryFile = path.join((0, fs_1.fsPath)(workspaceFolder.uri), "lib/main.dart");
    openFile(entryFile);
    if (triggerData?.sample)
        void vs.window.showInformationMessage(`${triggerData.sample} sample ready! Press F5 to start running.`);
    else
        void vs.window.showInformationMessage("Your Flutter project is ready! Press F5 to start running.");
}
function handleDartWelcome(workspaceFolder, template) {
    const workspacePath = (0, fs_1.fsPath)(workspaceFolder.uri);
    const projectName = path.basename(workspacePath);
    const entryFile = path.join(workspacePath, template.entrypoint.replace("__projectName__", projectName));
    openFile(entryFile);
    void vs.window.showInformationMessage(`${template.label} project ready!`);
}
let checkForLargeNumberOfTodosHasPromptedAboutManyTodosThisSession = false;
/**
 * Checks if there are a large number of TODO diagnostics in the workspace and if so, prompts
 * to turn them off.
 *
 * Does nothing if there is already an explicit setting or we've asked this session. If they choose
 * "Keep Enabled" when we'll write an explicit true into the settings which effectively suppresses.
 */
async function checkForLargeNumberOfTodos(diagnostics) {
    if (config_1.config.hasExplicitShowTodosSetting)
        return;
    if (checkForLargeNumberOfTodosHasPromptedAboutManyTodosThisSession)
        return;
    const threshold = 100;
    let numTodos = 0;
    diagnostics?.forEach((uri, diagnostics) => {
        if (numTodos >= threshold)
            return;
        for (const diagnostic of diagnostics) {
            if (diagnostic.code === "todo") {
                numTodos++;
                if (numTodos >= threshold)
                    return;
            }
        }
    });
    if (numTodos >= threshold) {
        checkForLargeNumberOfTodosHasPromptedAboutManyTodosThisSession = true;
        const disableInWorkspace = "Disable for Workspace";
        const disableGlobally = "Disable Everywhere";
        const keepEnabled = "Keep Enabled";
        const action = await vs.window.showInformationMessage(`Workspace has over ${threshold} TODO comments. Disable showing TODOs as diagnostics?`, disableInWorkspace, disableGlobally, keepEnabled);
        switch (action) {
            case disableGlobally:
                void config_1.config.setShowTodos(false, vs.ConfigurationTarget.Global);
                break;
            case disableInWorkspace:
                void config_1.config.setShowTodos(false, vs.ConfigurationTarget.Workspace);
                break;
            case keepEnabled:
                void config_1.config.setShowTodos(true, vs.ConfigurationTarget.Global);
                break;
        }
    }
}
/// Opens a file, but does it in a setTimeout to work around VS Code reveal bug
/// https://github.com/Microsoft/vscode/issues/71588#event-2252962973
function openFile(entryFile) {
    if (!fs.existsSync(entryFile))
        return;
    // TODO: Remove this setTimeout when it's no longer required.
    setTimeout(() => {
        void vs.commands.executeCommand("vscode.open", vs.Uri.file(entryFile));
    }, 100);
}


/***/ }),

/***/ 279:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logTime = void 0;
exports.isFlutterWorkspaceFolder = isFlutterWorkspaceFolder;
exports.isInsideFlutterProject = isInsideFlutterProject;
exports.isPathInsideFlutterProject = isPathInsideFlutterProject;
exports.insertSessionName = insertSessionName;
exports.insertWorkspaceName = insertWorkspaceName;
exports.isAnalyzable = isAnalyzable;
exports.shouldHotReloadFor = shouldHotReloadFor;
exports.isAnalyzableAndInWorkspace = isAnalyzableAndInWorkspace;
exports.isWithinWorkspace = isWithinWorkspace;
exports.isTestFileOrFolder = isTestFileOrFolder;
exports.isTestFile = isTestFile;
exports.isRunnableTestFile = isRunnableTestFile;
exports.isTestFolder = isTestFolder;
exports.projectCanUsePackageTest = projectCanUsePackageTest;
exports.isDartFile = isDartFile;
exports.isInsideFolderNamed = isInsideFolderNamed;
exports.hasTestFilter = hasTestFilter;
exports.ensureDebugLaunchUniqueId = ensureDebugLaunchUniqueId;
exports.isValidEntryFile = isValidEntryFile;
exports.getLatestSdkVersion = getLatestSdkVersion;
exports.escapeShell = escapeShell;
exports.promptToReloadExtension = promptToReloadExtension;
exports.openLogContents = openLogContents;
exports.getExcludedFolders = getExcludedFolders;
const fs = __importStar(__webpack_require__(9896));
const https = __importStar(__webpack_require__(5692));
const minimatch_1 = __webpack_require__(8722);
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const extension_1 = __webpack_require__(291);
const project_1 = __webpack_require__(5143);
function isFlutterWorkspaceFolder(folder) {
    return !!(folder && (0, utils_2.isDartWorkspaceFolder)(folder) && (0, fs_1.isFlutterProjectFolder)((0, fs_1.fsPath)(folder.uri)));
}
function isInsideFlutterProject(uri) {
    if (!uri)
        return false;
    const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(uri));
    if (projectRoot)
        return (0, fs_1.isFlutterProjectFolder)(projectRoot);
    else
        return isFlutterWorkspaceFolder(vscode_1.workspace.getWorkspaceFolder(uri));
}
function isPathInsideFlutterProject(path) {
    const projectRoot = (0, project_1.locateBestProjectRoot)(path);
    if (!projectRoot)
        return false;
    return (0, fs_1.isFlutterProjectFolder)(projectRoot);
}
function insertSessionName(args, logPath) {
    return logPath
        ? logPath.replace(/\${name}/ig, (0, utils_1.filenameSafe)(args.name || "unnamed-session"))
        : logPath;
}
function insertWorkspaceName(p) {
    if (typeof p !== "string")
        return undefined;
    return p.replace(/\${workspaceName}/ig, (0, utils_1.filenameSafe)(vscode_1.workspace.name ?? "unnamed-workspace"));
}
function isAnalyzable(file) {
    if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
        return false;
    const analyzableLanguages = ["dart", "html"];
    const analyzableFilenames = [".analysis_options", "analysis_options.yaml", "pubspec.yaml"];
    // We have to include dart/html extensions as this function may be called without a language ID
    // (for example when triggered by a file system watcher).
    const analyzableFileExtensions = ["dart", "htm", "html"].concat(config_1.config.additionalAnalyzerFileExtensions);
    const extName = path.extname((0, fs_1.fsPath)(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return (file.languageId && analyzableLanguages.includes(file.languageId))
        || analyzableFilenames.includes(path.basename((0, fs_1.fsPath)(file.uri)))
        || (extension !== undefined && analyzableFileExtensions.includes(extension));
}
function shouldHotReloadFor(file) {
    if (file.isUntitled || file.uri.scheme !== "file")
        return false;
    const filePath = (0, fs_1.fsPath)(file.uri);
    const extension = path.extname(filePath).substr(1);
    const reloadableFileExtensions = ["dart", "htm", "html", "css", "frag"];
    if (reloadableFileExtensions.includes(extension))
        return true;
    const resourceConf = config_1.config.for(file.uri);
    return !!resourceConf.hotReloadPatterns.find((p) => (0, minimatch_1.minimatch)(filePath, p, { dot: true }));
}
function isAnalyzableAndInWorkspace(file) {
    return isAnalyzable(file) && isWithinWorkspace((0, fs_1.fsPath)(file.uri));
}
function isWithinWorkspace(file) {
    return !!vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
}
function isTestFileOrFolder(path) {
    return !!path && (isTestFile(path) || isTestFolder(path));
}
function isTestFile(file) {
    // To be a test, you must be _test.dart AND inside a test folder (unless allowTestsOutsideTestFolder).
    // https://github.com/Dart-Code/Dart-Code/issues/1165
    // https://github.com/Dart-Code/Dart-Code/issues/2021
    // https://github.com/Dart-Code/Dart-Code/issues/2034
    return !!file && isDartFile(file)
        && (isInsideFolderNamed(file, "test")
            || isInsideFolderNamed(file, "integration_test")
            || isInsideFolderNamed(file, "test_driver")
            || config_1.config.allowTestsOutsideTestFolder)
        && file.toLowerCase().endsWith("_test.dart");
}
// Similar to isTestFile, but requires that the file is _test.dart because it will be used as
// an entry point for pub test running.
function isRunnableTestFile(file) {
    return !!file && isDartFile(file) && file.toLowerCase().endsWith("_test.dart");
}
function isTestFolder(path) {
    return !!path
        && (isInsideFolderNamed(path, "test")
            || isInsideFolderNamed(path, "integration_test")) && fs.existsSync(path)
        && fs.statSync(path).isDirectory();
}
function projectCanUsePackageTest(folder, config) {
    // Handle explicit flags.
    if (config.supportsPackageTest === true)
        return true;
    else if (config.supportsPackageTest === false)
        return false;
    return (0, fs_1.hasPubspec)(folder);
}
function isDartFile(file) {
    return !!file && path.extname(file.toLowerCase()) === ".dart" && fs.existsSync(file) && fs.statSync(file).isFile();
}
function isInsideFolderNamed(file, folderName) {
    if (!file)
        return false;
    const ws = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
    if (!ws)
        return false;
    const relPath = path.relative((0, fs_1.fsPath)(ws.uri).toLowerCase(), file.toLowerCase());
    const segments = relPath.split(path.sep);
    return segments.includes(folderName.toLowerCase());
}
function hasTestFilter(args) {
    return args.includes("--name") || args.includes("--pname");
}
/// Ensures a debug config always has a unique ID we can use to match things up.
///
/// Although VS Code assigns an ID, we cannot get at it until after the debug session starts
/// which might be after we recieve some events (since VS Code fires its event late - after all
/// initialisation has completed).
function ensureDebugLaunchUniqueId(config) {
    const conf = config;
    if (!conf.dartCodeDebugSessionID) {
        const dartCodeDebugSessionID = `session-${(0, fs_1.getRandomInt)(0x10000, 0x100000).toString(16)}`;
        conf.dartCodeDebugSessionID = dartCodeDebugSessionID;
    }
    return conf.dartCodeDebugSessionID;
}
function isValidEntryFile(file) {
    if (!file || !isDartFile(file))
        return false;
    // When in a no-folder workspace, all Dart files are considered runnable.
    if (!vscode_1.workspace.workspaceFolders?.length)
        return true;
    return isTestFile(file)
        || isInsideFolderNamed(file, "bin") || isInsideFolderNamed(file, "tool") || isInsideFolderNamed(file, "test_driver")
        || file.endsWith(`lib${path.sep}main.dart`);
}
function getLatestSdkVersion() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "storage.googleapis.com",
            method: "GET",
            path: "/dart-archive/channels/stable/release/latest/VERSION",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Dart SDK Version ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resp.on("data", (d) => {
                    try {
                        const latestVersion = JSON.parse(d.toString()).version;
                        resolve(latestVersion);
                    }
                    catch (e) {
                        reject({ message: `Failed to parse latest Dart SDK Version from JSON: ${d.toString()}` });
                    }
                });
            }
        });
        req.end();
    });
}
// Escapes a set of command line arguments so that the escaped string is suitable for passing as an argument
// to another shell command.
// Implementation is taken from https://github.com/xxorax/node-shell-escape
function escapeShell(args) {
    const ret = [];
    args.forEach((arg) => {
        if (/[^A-Za-z0-9_\/:=-]/.test(arg)) {
            arg = "'" + arg.replace(/'/g, "'\\''") + "'";
            arg = arg.replace(/^(?:'')+/g, "") // unduplicate single-quote at the beginning
                .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
        }
        ret.push(arg);
    });
    return ret.join(" ");
}
async function promptToReloadExtension(prompt, buttonText, offerLog, specificLog) {
    const restartAction = buttonText || "Reload";
    const actions = offerLog ? [restartAction, constants_1.showLogAction] : [restartAction];
    const ringLogContents = extension_1.ringLog.toString();
    let showPromptAgain = true;
    const tempLogPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
    while (showPromptAgain) {
        showPromptAgain = false;
        const chosenAction = prompt && await vscode_1.window.showInformationMessage(prompt, ...actions);
        if (chosenAction === constants_1.showLogAction) {
            showPromptAgain = true;
            if (specificLog && fs.existsSync(specificLog))
                void vscode_1.workspace.openTextDocument(specificLog).then(vscode_1.window.showTextDocument);
            else
                void openLogContents(undefined, ringLogContents, tempLogPath);
        }
        else if (!prompt || chosenAction === restartAction) {
            void vscode_1.commands.executeCommand("_dart.reloadExtension");
        }
    }
}
const shouldLogTimings = false;
const start = process.hrtime.bigint();
let last = start;
function pad(str, length) {
    while (str.length < length)
        str = "0" + str;
    return str;
}
const logTime = (taskFinished) => {
    if (!shouldLogTimings)
        return;
    const end = process.hrtime.bigint();
    console.log(`${pad((end - last).toString(), 15)} ${taskFinished ? "<== " + taskFinished : ""}`);
    last = end;
};
exports.logTime = logTime;
async function openLogContents(logType = `txt`, logContents, tempPath) {
    if (!tempPath)
        tempPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.${logType}`);
    fs.writeFileSync(tempPath, logContents);
    await vscode_1.workspace.openTextDocument(tempPath).then(vscode_1.window.showTextDocument);
}
/// Gets all excluded folders (full absolute paths) for a given workspace
/// folder based on config.
function getExcludedFolders(f) {
    if (!f)
        return [];
    const excludedForWorkspace = config_1.config.for(f.uri).analysisExcludedFolders;
    if (!excludedForWorkspace || !Array.isArray(excludedForWorkspace))
        return [];
    const workspacePath = (0, fs_1.fsPath)(f.uri);
    return excludedForWorkspace.map((folder) => {
        // Handle both relative and absolute paths.
        if (!path.isAbsolute(folder))
            folder = path.join(workspacePath, folder);
        return folder;
    });
}


/***/ }),

/***/ 7962:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debuggingLogCategories = exports.extensionsLogCategories = exports.analysisServerLogCategories = exports.userSelectableLogCategories = void 0;
exports.getExtensionLogPath = getExtensionLogPath;
exports.clearLogHeader = clearLogHeader;
exports.getLogHeader = getLogHeader;
exports.addToLogHeader = addToLogHeader;
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const fs_1 = __webpack_require__(2587);
const config_1 = __webpack_require__(7678);
let extensionLogPath;
function getExtensionLogPath() {
    extensionLogPath = extensionLogPath || config_1.config.extensionLogFile || path.join(process.env.DC_TEST_LOGS || os.tmpdir(), `dart-code-startup-log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
    return extensionLogPath;
}
exports.userSelectableLogCategories = {
    "Analysis Server": enums_1.LogCategory.Analyzer,
    "Analysis Server Timings": enums_1.LogCategory.AnalyzerTiming,
    "Command Processes": enums_1.LogCategory.CommandProcesses,
    "Dart Test": enums_1.LogCategory.DartTest,
    "Dart Tooling Daemon": enums_1.LogCategory.DartToolingDaemon,
    "Debugger DAP Protocol": enums_1.LogCategory.DAP,
    "Debugger VM Service": enums_1.LogCategory.VmService,
    "DevTools": enums_1.LogCategory.DevTools,
    "Flutter Device Daemon": enums_1.LogCategory.FlutterDaemon,
    "Flutter Run": enums_1.LogCategory.FlutterRun,
    "Flutter Test": enums_1.LogCategory.FlutterTest,
    "Web Daemon": enums_1.LogCategory.WebDaemon,
};
exports.analysisServerLogCategories = [
    enums_1.LogCategory.Analyzer,
    enums_1.LogCategory.CommandProcesses,
];
exports.extensionsLogCategories = [
    enums_1.LogCategory.CommandProcesses,
    enums_1.LogCategory.DevTools,
    enums_1.LogCategory.FlutterDaemon,
];
exports.debuggingLogCategories = Object.values(exports.userSelectableLogCategories)
    .filter((c) => c !== enums_1.LogCategory.Analyzer);
const logHeader = [];
function clearLogHeader() {
    logHeader.length = 0;
}
function getLogHeader(suppressHeaderFooter) {
    if (!logHeader.length)
        return "";
    return [
        ...(suppressHeaderFooter ? [] : ["!! ⚠️ PLEASE REVIEW THIS LOG FOR SENSITIVE INFORMATION BEFORE SHARING ⚠️ !!"]),
        ...logHeader,
        ...(suppressHeaderFooter ? [] : [constants_1.platformEol]),
    ].join(constants_1.platformEol);
}
function addToLogHeader(f) {
    try {
        logHeader.push(f().replace(/\r/g, "").replace(/\n/g, "\r\n"));
    }
    catch {
        // Don't log here; we may be trying to access things that aren't available yet.
    }
}


/***/ }),

/***/ 1166:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportAnalyzerTerminatedWithError = reportAnalyzerTerminatedWithError;
exports.getFlutterConfigValue = getFlutterConfigValue;
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const config_1 = __webpack_require__(7678);
const utils_1 = __webpack_require__(279);
const processes_1 = __webpack_require__(8141);
let isShowingAnalyzerError = false;
function reportAnalyzerTerminatedWithError(duringStartup = false) {
    if (isShowingAnalyzerError)
        return;
    isShowingAnalyzerError = true;
    const message = duringStartup
        ? "The Dart Analyzer could not be started."
        : "The Dart Analyzer has terminated.";
    void (0, utils_1.promptToReloadExtension)(message, undefined, true, config_1.config.analyzerLogFile).then(() => isShowingAnalyzerError = false);
}
async function getFlutterConfigValue(logger, flutterSdkPath, folder, flutterConfigKey) {
    if (!flutterSdkPath) {
        throw Error("Cannot find Android Studio without a Flutter SDK");
    }
    const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
    const args = ["config", "--machine"];
    try {
        const proc = await (0, processes_1.runToolProcess)(logger, folder, binPath, args);
        if (proc.exitCode === 0) {
            // It's possible there is Flutter output before the JSON so trim everything before then.
            let jsonString = proc.stdout.trim();
            const firstBrace = jsonString.indexOf("{");
            if (firstBrace > 0) {
                jsonString = jsonString.substring(firstBrace);
            }
            const json = JSON.parse(jsonString);
            return json[flutterConfigKey];
        }
        throw Error(`Failed to run "flutter config --machine" (${proc.exitCode}): ${proc.stderr}`);
    }
    catch (e) {
        logger.error(e);
        throw e;
    }
}


/***/ }),

/***/ 8141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getToolEnv = getToolEnv;
exports.getGlobalFlutterArgs = getGlobalFlutterArgs;
exports.setFlutterRoot = setFlutterRoot;
exports.setupToolEnv = setupToolEnv;
exports.safeToolSpawn = safeToolSpawn;
exports.runToolProcess = runToolProcess;
const constants_1 = __webpack_require__(6709);
const processes_1 = __webpack_require__(4917);
// Environment used when spawning Dart and Flutter processes.
let flutterRoot;
let toolEnv = {};
let globalFlutterArgs = [];
function getToolEnv() {
    return toolEnv;
}
function getGlobalFlutterArgs() {
    return globalFlutterArgs;
}
function setFlutterRoot(root) {
    flutterRoot = root;
}
function setupToolEnv(envOverrides) {
    toolEnv = {};
    globalFlutterArgs = [];
    toolEnv.FLUTTER_HOST = "VSCode";
    toolEnv.PUB_ENVIRONMENT = (toolEnv.PUB_ENVIRONMENT ? `${toolEnv.PUB_ENVIRONMENT}:` : "") + "vscode.dart-code";
    if (constants_1.isDartCodeTestRun) {
        toolEnv.PUB_ENVIRONMENT += ".test.bot";
        globalFlutterArgs.push("--suppress-analytics");
    }
    // Add on any overrides.
    if (envOverrides)
        toolEnv = Object.assign(toolEnv, envOverrides);
    if (!toolEnv.FLUTTER_ROOT && !process.env.FLUTTER_ROOT && flutterRoot)
        toolEnv.FLUTTER_ROOT = flutterRoot;
}
function safeToolSpawn(workingDirectory, binPath, args, envOverrides) {
    const env = Object.assign({}, toolEnv, envOverrides);
    return (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
}
/// Runs a process and returns the exit code, stdout, stderr. Always resolves even for non-zero exit codes.
function runToolProcess(logger, workingDirectory, binPath, args, envOverrides, cancellationToken) {
    return (0, processes_1.runProcess)(logger, binPath, args, workingDirectory, envOverrides, safeToolSpawn, cancellationToken);
}


/***/ }),

/***/ 5940:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressMessage = exports.DartDebugSessionInformation = void 0;
class DartDebugSessionInformation {
    session;
    observatoryUri;
    /*
    * In some environments (for ex. g3), the VM Service/DDS could be running on
    * the end user machine (eg. Mac) while the extension host is an SSH remote
    * (eg. Linux).
    *
    * `vmServiceUri` indicates a URI that is accessible to the extension host.
    * `clientVmServiceUri` indicates a URI that is already accessible on the end
    * user machine without forwarding.
    */
    vmServiceUri;
    clientVmServiceUri;
    sessionStart = new Date();
    hasStarted = false;
    flutterMode;
    flutterDeviceId;
    supportsHotReload;
    hasEnded = false;
    progress = {};
    loadedServiceExtensions = [];
    debuggerType;
    projectRootPath;
    constructor(session, configuration) {
        this.session = session;
        configuration = configuration;
        this.debuggerType = configuration.debuggerType;
        this.projectRootPath = configuration.projectRootPath;
    }
}
exports.DartDebugSessionInformation = DartDebugSessionInformation;
class ProgressMessage {
    reporter;
    completer;
    constructor(reporter, completer) {
        this.reporter = reporter;
        this.completer = completer;
    }
    report(message) {
        this.reporter.report({ message });
    }
    complete() {
        this.completer.resolve();
    }
}
exports.ProgressMessage = ProgressMessage;


/***/ }),

/***/ 5883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDiagnosticErrorCode = getDiagnosticErrorCode;
function getDiagnosticErrorCode(diag) {
    const code = diag.code;
    if (!code)
        return;
    const errorCode = typeof code === "string" || typeof code === "number"
        ? code.toString()
        : ("value" in code)
            ? code.value.toString()
            : undefined;
    return errorCode;
}


/***/ }),

/***/ 7335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showInputBoxWithSettings = showInputBoxWithSettings;
exports.showSimpleSettingsEditor = showSimpleSettingsEditor;
exports.editSetting = editSetting;
const vs = __importStar(__webpack_require__(1398));
async function showInputBoxWithSettings(context, options) {
    const input = vs.window.createInputBox();
    input.ignoreFocusOut = options.ignoreFocusOut;
    input.title = options.title;
    input.prompt = options.prompt;
    input.placeholder = options.placeholder;
    input.value = options.value;
    if (options.validation) {
        input.onDidChangeValue((s) => {
            input.validationMessage = options.validation(s);
        });
    }
    input.buttons = [
        {
            iconPath: {
                dark: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
                light: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
            },
            tooltip: "Settings",
        },
    ];
    const name = await new Promise((resolve) => {
        input.onDidTriggerButton(async (e) => {
            resolve("SETTINGS");
            input.hide();
        });
        input.onDidAccept(() => {
            // Don't accept while there's a validation error.
            if (input.validationMessage)
                return;
            input.value ? resolve({ value: input.value }) : resolve(undefined);
        });
        input.onDidHide(() => {
            resolve(undefined);
        });
        input.show();
    });
    input.dispose();
    return name;
}
async function showSimpleSettingsEditor(title, placeholder, getItems) {
    while (true) {
        const quickPick = vs.window.createQuickPick();
        quickPick.title = title;
        quickPick.placeholder = placeholder;
        quickPick.items = getItems();
        const selectedSetting = await new Promise((resolve) => {
            quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0]));
            quickPick.onDidHide(() => resolve(undefined));
            quickPick.show();
        });
        quickPick.dispose();
        if (selectedSetting) {
            await editSetting(selectedSetting);
        }
        else {
            return;
        }
    }
}
async function editSetting(setting) {
    const title = setting.label;
    let placeholder = `Select an option for ${setting.label} (or 'Escape' to cancel)`;
    const prompt = setting.detail;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const value = setting.currentValue;
    switch (setting.settingKind) {
        case "STRING":
            const stringResult = await vs.window.showInputBox({ prompt, title, value: value });
            if (stringResult !== undefined)
                await setting.setValue(stringResult);
            break;
        case "ENUM": {
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = placeholder;
            quickPick.title = title;
            quickPick.items = setting.enumValues.map((v) => ({ label: v }));
            quickPick.activeItems = quickPick.items.filter((item) => item.label === setting.currentValue);
            const accepted = await new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(true));
                quickPick.onDidHide(() => resolve(false));
                quickPick.show();
            });
            const enumResult = accepted && quickPick.activeItems.length ? quickPick.activeItems[0].label : undefined;
            quickPick.dispose();
            if (enumResult !== undefined)
                await setting.setValue(enumResult);
            break;
        }
        case "MULTI_ENUM": {
            placeholder = `Select options for ${setting.label} (or 'Escape' to cancel)`;
            const quickPick = vs.window.createQuickPick();
            quickPick.canSelectMany = true;
            quickPick.placeholder = placeholder;
            quickPick.title = title;
            const items = [];
            for (const group of setting.enumValues) {
                items.push({ label: group.group, kind: vs.QuickPickItemKind.Separator });
                for (const value of group.values) {
                    items.push({ label: value });
                }
            }
            quickPick.items = items;
            quickPick.selectedItems = quickPick.items.filter((item) => setting.currentValue.find((current) => current === item.label));
            const accepted = await new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(true));
                quickPick.onDidHide(() => resolve(false));
                quickPick.show();
            });
            quickPick.dispose();
            if (accepted)
                await setting.setValue(quickPick.selectedItems.map((item) => item.label));
            break;
        }
        case "BOOL":
            const boolResult = await vs.window.showQuickPick([
                { label: "enable" },
                { label: "disable" },
            ], { placeHolder: placeholder, title });
            if (boolResult !== undefined)
                await setting.setValue(boolResult.label === "enable");
            break;
    }
}


/***/ }),

/***/ 8693:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findNearestOutlineNode = findNearestOutlineNode;
function findNearestOutlineNode(fileTracker, document, position, useReducedRange = false, kinds = ["CLASS", "METHOD", "GETTER", "SETTER"]) {
    const outline = fileTracker.getOutlineFor(document.uri);
    return outline && findNode([outline], document.offsetAt(position), useReducedRange, kinds);
}
function findNode(outlines, offset, useReducedRange, kinds) {
    if (!outlines)
        return undefined;
    for (const outline of outlines) {
        const outlineStart = outline.offset;
        const outlineEnd = outline.offset + outline.length;
        // Bail if this node is not spanning us.
        if (outlineStart > offset || outlineEnd < offset)
            continue;
        // Although we use the full code range above so that we can walk into children, when performing a match we want to stop
        // at the end of the element, so we use a reduce range to avoid returning a method for the whole of its body.
        const isInReducedRange = !useReducedRange || !outline.element || !outline.element.location
            || (offset >= outlineStart && offset <= outline.element.location.offset + outline.element.location.length);
        return findNode(outline.children, offset, useReducedRange, kinds)
            || (kinds.includes(outline.element.kind) && isInReducedRange ? outline : undefined);
    }
}


/***/ }),

/***/ 6265:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFolderToRunCommandIn = getFolderToRunCommandIn;
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const editors_1 = __webpack_require__(9451);
const project_1 = __webpack_require__(5143);
const utils_3 = __webpack_require__(279);
async function getFolderToRunCommandIn(logger, placeHolder, selection, flutterOnly = false) {
    // Attempt to find a project based on the supplied folder of active file.
    let file = selection && (0, fs_1.fsPath)(selection);
    if (!file) {
        const editor = (0, editors_1.getActiveRealFileEditor)();
        if (editor)
            file = (0, fs_1.fsPath)(editor.document.uri);
    }
    const folder = file && (0, project_1.locateBestProjectRoot)(file);
    if (folder)
        return folder;
    // Otherwise look for what projects we have.
    const selectableFolders = (await (0, utils_2.getAllProjectFolders)(logger, utils_3.getExcludedFolders, { requirePubspec: true, sort: true, searchDepth: config_1.config.projectSearchDepth }))
        .filter(flutterOnly ? fs_1.isFlutterProjectFolder : () => true);
    if (!selectableFolders || !selectableFolders.length) {
        const projectTypes = flutterOnly ? "Flutter" : "Dart/Flutter";
        void vs.window.showWarningMessage(`No ${projectTypes} project roots were found. Do you have a pubspec.yaml file?`);
        return undefined;
    }
    return showFolderPicker(selectableFolders, placeHolder); // TODO: What if the user didn't pick anything?
}
async function showFolderPicker(folders, placeHolder) {
    // No point asking the user if there's only one.
    if (folders.length === 1) {
        return folders[0];
    }
    const items = folders.map((f) => {
        const workspaceFolder = vs.workspace.getWorkspaceFolder(vscode_1.Uri.file(f));
        if (!workspaceFolder)
            return undefined;
        const workspacePathParent = path.dirname((0, fs_1.fsPath)(workspaceFolder.uri));
        return {
            description: (0, fs_1.homeRelativePath)(workspacePathParent),
            label: path.relative(workspacePathParent, f),
            path: f,
        };
    }).filter(utils_1.notUndefined);
    const selectedFolder = await vs.window.showQuickPick(items, { placeHolder });
    return selectedFolder && selectedFolder.path;
}


/***/ }),

/***/ 5850:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeToPseudoTerminal = writeToPseudoTerminal;
exports.formatForTerminal = formatForTerminal;
const vs = __importStar(__webpack_require__(1398));
function writeToPseudoTerminal(messages) {
    const emitter = new vs.EventEmitter();
    const pseudoterminal = {
        close: () => { },
        onDidWrite: emitter.event,
        open: () => {
            for (const output of messages) {
                if (output)
                    emitter.fire(formatForTerminal(output));
            }
        },
    };
    const currentTestTerminal = [
        vs.window.createTerminal({ name: "Test Output", pty: pseudoterminal }),
        emitter,
    ];
    currentTestTerminal[0].show();
    return currentTestTerminal;
}
function formatForTerminal(output) {
    // For terminal, if we send \n without a \r the rendering will be bad.
    return output.replace(/\n/g, "\r\n").replace(/\r\r\n/g, "\r\n");
}


/***/ }),

/***/ 6437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MyBaseWebViewProvider = void 0;
const utils_1 = __webpack_require__(1894);
class MyBaseWebViewProvider {
    devTools;
    dartCapabilities;
    webviewView;
    constructor(devTools, dartCapabilities) {
        this.devTools = devTools;
        this.dartCapabilities = dartCapabilities;
    }
    async resolveWebviewView(webviewView, context, token) {
        this.webviewView = webviewView;
        await this.devTools.start();
        let pageUrl = await this.devTools.urlFor(this.pageRoute);
        if (!pageUrl) {
            webviewView.webview.html = `
			<html>
			<body><h1>${this.pageName} Unavailable</h1><p>The ${this.pageName} requires DevTools but DevTools failed to start.</p></body>
			</html>
			`;
            return;
        }
        pageUrl = await utils_1.envUtils.exposeUrl(pageUrl);
        const pageScript = this.getScript();
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [],
        };
        webviewView.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src *; script-src 'unsafe-inline'; style-src 'unsafe-inline';">
			<script>${pageScript}</script>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0" allow="clipboard-read; clipboard-write; cross-origin-isolated" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%"></iframe></body>
			</html>
			`;
        void webviewView.webview.postMessage({ command: "_dart-code.setUrl", url: pageUrl });
    }
    getScript() {
        const embedFlags = this.dartCapabilities.requiresDevToolsEmbedFlag ? "embed=true&embedMode=one" : "embedMode=one";
        return `
	// Track the background color as an indicator of whether the theme changed.
	let currentBackgroundColor;

	function getTheme() {
		const isDarkMode = !document.body.classList.contains('vscode-light');
		const backgroundColor = currentBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-background');
		const foregroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-foreground');
		const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
		const fontSize = fontSizeWithUnits && fontSizeWithUnits.endsWith('px') ? parseFloat(fontSizeWithUnits) : undefined;

		return {
			isDarkMode: isDarkMode,
			backgroundColor: backgroundColor,
			foregroundColor: foregroundColor,
			fontSize: fontSize,
		};
	}

	const vscode = acquireVsCodeApi();
	window.addEventListener('message', (event) => {
		const devToolsFrame = document.getElementById('devToolsFrame');
		const message = event.data;

		// Handle any special commands first.
		switch (message.command) {
			case "_dart-code.setUrl":
				const theme = document.body.classList.contains('vscode-light') ? 'light': 'dark';
				const background = currentBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-background');
				const foreground = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBarTitle-foreground');
				const qsSep = message.url.includes("?") ? "&" : "?";
				// Don't include # in colors
				// https://github.com/flutter/flutter/issues/155992
				let url = \`\${message.url}\${qsSep}${embedFlags}&theme=\${theme}&backgroundColor=\${encodeURIComponent(background?.replace('#', ''))}&foregroundColor=\${encodeURIComponent(foreground?.replace('#', ''))}\`;
				const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
				if (fontSizeWithUnits && fontSizeWithUnits.endsWith('px')) {
					url += \`&fontSize=\${encodeURIComponent(parseFloat(fontSizeWithUnits))}\`;
				}
				if (devToolsFrame.src !== url)
					devToolsFrame.src = url;
				return;
		}
	});

	function sendTheme() {
		const devToolsFrame = document.getElementById('devToolsFrame');
		const theme = getTheme();
		devToolsFrame.contentWindow.postMessage({
			method: 'editor.themeChanged',
			params: {
				kind: 'themeChanged',
				theme: theme,
			}
		}, "*");
	}

	document.addEventListener('DOMContentLoaded', function () {
		new MutationObserver((mutationList) => {
			for (const mutation of mutationList) {
				if (mutation.type === "attributes" && mutation.attributeName == "class") {
					let newBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-background');
					if (newBackgroundColor !== currentBackgroundColor) {
						sendTheme();
						break;
					}
				}
			}
		}).observe(document.body, { attributeFilter : ['class'], attributeOldValue: true });
	});
			`;
    }
}
exports.MyBaseWebViewProvider = MyBaseWebViewProvider;


/***/ }),

/***/ 6557:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartApi = void 0;
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const utils_1 = __webpack_require__(949);
const debug_1 = __webpack_require__(394);
const apiDebugMode = false;
class DartApi {
    commandSource;
    post;
    deviceManager;
    disposables = [];
    apis = {};
    constructor(commandSource, onReceiveMessage, post, deviceManager) {
        this.commandSource = commandSource;
        this.post = post;
        this.deviceManager = deviceManager;
        const addApi = (api) => this.apis[api.apiName] = api;
        addApi(new VsCodeApiHandler(this, commandSource, deviceManager));
        this.disposables.push(onReceiveMessage(this.handleMessage, this));
    }
    postMessage(message) {
        this.post({ jsonrpc: "2.0", ...message });
    }
    async handleMessage(message) {
        if (apiDebugMode)
            console.log(`VS CODE GOT: ${JSON.stringify(message)}`);
        const method = message.method;
        if (typeof method !== "string")
            return;
        const apiName = method.split(".")[0];
        const methodName = method.substring(apiName.length + 1);
        const handler = this.apis[apiName];
        if (!handler) {
            if (message.id) {
                this.postMessage({ id: message.id, error: "No handler for '${apiName}' API" });
            }
            return;
        }
        try {
            const result = await handler.handleRequest(methodName, message.params);
            if (message.id !== undefined) {
                this.postMessage({ id: message.id, result: result ?? null });
            }
        }
        catch (e) {
            if (message.id !== undefined) {
                this.postMessage({ id: message.id, error: `${e}` });
            }
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
        (0, utils_1.disposeAll)(Object.values(this.apis));
    }
}
exports.DartApi = DartApi;
class ToolApi {
    dartApi;
    disposables = [];
    constructor(dartApi) {
        this.dartApi = dartApi;
    }
    sendEvent(method, params) {
        this.dartApi.postMessage({ method: `${this.apiName}.${method}`, params });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
class VsCodeApiHandler extends ToolApi {
    api;
    constructor(dartApi, commandSource, deviceManager) {
        super(dartApi);
        const api = this.api = new VsCodeApiImpl(commandSource, deviceManager);
        this.disposables.push(api.devicesChanged((e) => this.sendEvent("devicesChanged", e)));
        this.disposables.push(api.debugSessionsChanged((e) => this.sendEvent("debugSessionsChanged", e)));
    }
    apiName = "vsCode";
    async handleRequest(method, params) {
        // IMPORTANT: Optional values here could be either `null` or `undefined` so should be
        //  converted with `nullToUndefined` to match type signatures elsewhere (otherwise
        //  checks for `== undefined` may fail because the value was null).
        if (method === "getCapabilities") {
            return this.api.capabilities;
        }
        else if (method === "initialize") {
            return await this.api.initialize();
        }
        else if (method === "selectDevice") {
            return this.api.selectDevice((0, utils_1.nullToUndefined)(params.id));
        }
        else if (method === "enablePlatformType") {
            return this.api.enablePlatformType(params.platformType);
        }
        else if (method === "openDevToolsPage") {
            return this.api.openDevToolsPage((0, utils_1.nullToUndefined)(params.debugSessionId), (0, utils_1.nullToUndefined)(params.page), (0, utils_1.nullToUndefined)(params.forceExternal), (0, utils_1.nullToUndefined)(params.requiresDebugSession), (0, utils_1.nullToUndefined)(params.prefersDebugSession));
        }
        else if (method === "hotReload") {
            return this.api.hotReload(params.debugSessionId);
        }
        else if (method === "hotRestart") {
            return this.api.hotRestart(params.debugSessionId);
        }
        else if (method === "executeCommand") {
            return await this.api.executeCommand(params.command, (0, utils_1.nullToUndefined)(params.arguments));
        }
    }
}
class VsCodeApiImpl {
    commandSource;
    deviceManager;
    devicesChangedEmitter = new vs.EventEmitter();
    devicesChanged = this.devicesChangedEmitter.event;
    debugSessionsChangedEmitter = new vs.EventEmitter();
    debugSessionsChanged = this.debugSessionsChangedEmitter.event;
    disposables = [];
    constructor(commandSource, deviceManager) {
        this.commandSource = commandSource;
        this.deviceManager = deviceManager;
        if (deviceManager) {
            this.disposables.push(deviceManager?.onCurrentDeviceChanged(this.onDevicesChanged, this));
            this.disposables.push(deviceManager?.onDevicesChanged(this.onDevicesChanged, this));
            this.disposables.push((0, debug_1.debugSessionsChanged)(this.onDebugSessionsChanged, this));
        }
    }
    capabilities = {
        executeCommand: true,
        hotReload: true,
        hotRestart: true,
        openDevToolsExternally: true,
        openDevToolsPage: true,
        openDevToolsWithOptionalDebugSessionFlags: true,
        selectDevice: true,
    };
    async initialize() {
        // Trigger initial events to get the client the existing data from before they
        // started listening.
        void this.onDevicesChanged();
        this.onDebugSessionsChanged();
    }
    async executeCommand(command, args) {
        return await vs.commands.executeCommand(command, { commandSource: this.commandSource, ...args });
    }
    async selectDevice(id) {
        return this.deviceManager?.selectDeviceById(id) ?? false;
    }
    async enablePlatformType(platformType) {
        return this.deviceManager?.enablePlatformType(platformType) ?? false;
    }
    async openDevToolsPage(debugSessionId, pageId, forceExternal, requiresDebugSession, prefersDebugSession) {
        const location = forceExternal ? "external" : undefined;
        return vs.commands.executeCommand("dart.openDevTools", { debugSessionId, pageId, location, commandSource: this.commandSource, requiresDebugSession, prefersDebugSession });
    }
    async hotReload(debugSessionId) {
        const session = debug_1.debugSessions.find((s) => s.session.id === debugSessionId);
        if (!session)
            return;
        await session.session.customRequest("hotReload", { reason: constants_1.restartReasonManual });
    }
    async hotRestart(debugSessionId) {
        const session = debug_1.debugSessions.find((s) => s.session.id === debugSessionId);
        if (!session)
            return;
        await session.session.customRequest("hotRestart", { reason: constants_1.restartReasonManual });
    }
    async onDevicesChanged() {
        let devices = [];
        let unsupportedDevices = [];
        const deviceManager = this.deviceManager;
        if (deviceManager) {
            const supportedTypes = await deviceManager.getSupportedPlatformsForWorkspace();
            const allDevices = deviceManager.getDevicesSortedByName() ?? [];
            const isSupported = (d) => deviceManager.isSupported(supportedTypes, d);
            devices = allDevices.filter((d) => isSupported(d));
            unsupportedDevices = allDevices.filter((d) => !isSupported(d));
        }
        this.devicesChangedEmitter.fire({
            devices: devices.map((d) => this.asApiDevice(d)),
            selectedDeviceId: this.deviceManager?.currentDevice?.id,
            unsupportedDevices: unsupportedDevices.map((d) => this.asApiDevice(d)),
        });
    }
    onDebugSessionsChanged() {
        this.debugSessionsChangedEmitter.fire({
            sessions: debug_1.debugSessions.map((d) => this.asApiDebugSession(d)),
        });
    }
    asApiDevice(device) {
        return {
            category: (0, utils_1.nullToUndefined)(device.category),
            emulator: !!device.emulator,
            emulatorId: (0, utils_1.nullToUndefined)(device.emulatorId),
            ephemeral: !!device.ephemeral,
            id: device.id,
            name: this.deviceManager?.friendlyNameForDevice(device) ?? device.name,
            platform: device.platform,
            platformType: (0, utils_1.nullToUndefined)(device.platformType),
            rawDeviceName: device.name,
        };
    }
    asApiDebugSession(session) {
        return {
            debuggerType: enums_1.DebuggerType[session.debuggerType],
            flutterDeviceId: session.flutterDeviceId,
            flutterMode: session.flutterMode,
            id: session.session.id,
            name: session.session.name,
            projectRootPath: session.projectRootPath,
            vmServiceUri: session.vmServiceUri,
        };
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}


/***/ }),

/***/ 5792:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterPostMessageSidebar = void 0;
const vs = __importStar(__webpack_require__(1398));
const vscode_uri_1 = __webpack_require__(8945);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const dart_tooling_api_1 = __webpack_require__(6557);
class FlutterPostMessageSidebar {
    devTools;
    deviceManager;
    disposables = [];
    constructor(devTools, deviceManager, dartCapabilities) {
        this.devTools = devTools;
        this.deviceManager = deviceManager;
        const webViewProvider = new MyWebViewProvider(devTools, deviceManager, dartCapabilities);
        this.disposables.push(webViewProvider);
        this.disposables.push(vs.window.registerWebviewViewProvider("dartFlutterSidebar", webViewProvider, { webviewOptions: { retainContextWhenHidden: true } }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterPostMessageSidebar = FlutterPostMessageSidebar;
class MyWebViewProvider {
    devTools;
    deviceManager;
    dartCapabilities;
    disposables = [];
    webviewView;
    api;
    constructor(devTools, deviceManager, dartCapabilities) {
        this.devTools = devTools;
        this.deviceManager = deviceManager;
        this.dartCapabilities = dartCapabilities;
    }
    dispose() {
        this.api?.dispose();
        (0, utils_1.disposeAll)(this.disposables);
    }
    async resolveWebviewView(webviewView, context, token) {
        this.webviewView = webviewView;
        this.api?.dispose();
        await this.devTools.start();
        let sidebarUrl = await this.devTools.urlFor("vsCodeFlutterPanel");
        if (!sidebarUrl) {
            webviewView.webview.html = `
			<html>
			<body><h1>Sidebar Unavailable</h1><p>The Flutter sidebar requires DevTools but DevTools failed to start.</p></body>
			</html>
			`;
            return;
        }
        sidebarUrl = await utils_2.envUtils.exposeUrl(sidebarUrl);
        const sidebarUri = vscode_uri_1.URI.parse(sidebarUrl);
        const frameOrigin = `${sidebarUri.scheme}://${sidebarUri.authority}`;
        const embedFlags = this.dartCapabilities.requiresDevToolsEmbedFlag ? "embed=true&embedMode=one" : "embedMode=one";
        const pageScript = `
		let currentBackgroundColor;
		let currentBaseUrl;

		function setIframeSrc() {
			const devToolsFrame = document.getElementById('devToolsFrame');
			const theme = document.body.classList.contains('vscode-light') ? 'light': 'dark';
			const background = currentBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-background');
			const foreground = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBarTitle-foreground');
			const qsSep = currentBaseUrl.includes("?") ? "&" : "?";
			// Don't include # in colors
			// https://github.com/flutter/flutter/issues/155992
			let url = \`\${currentBaseUrl}\${qsSep}${embedFlags}&theme=\${theme}&backgroundColor=\${encodeURIComponent(background?.replace('#', ''))}&foregroundColor=\${encodeURIComponent(foreground?.replace('#', ''))}\`;
			const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
			if (fontSizeWithUnits && fontSizeWithUnits.endsWith('px')) {
				url += \`&fontSize=\${encodeURIComponent(parseFloat(fontSizeWithUnits))}\`;
			}
			if (devToolsFrame.src !== url)
				devToolsFrame.src = url;
		}

		const vscode = acquireVsCodeApi();
		window.addEventListener('message', (event) => {
			const devToolsFrame = document.getElementById('devToolsFrame');
			const message = event.data;

			// Handle any special commands first.
			switch (message.command) {
				case "_dart-code.setUrl":
					currentBaseUrl = message.url;
					setIframeSrc();
					return;
			}

			if (event.origin == ${JSON.stringify(frameOrigin)}) {
				// Messages from the frame go up to VS Code.
				// console.log(\`FRAME: Code <-- DevTools: \${JSON.stringify(message)}\`);
				vscode.postMessage(message);
			} else {
				// Messages not from the frame go to the frame.
				// console.log(\`FRAME: Code --> DevTools: \${JSON.stringify(message)}\`);
				devToolsFrame.contentWindow.postMessage(message, ${JSON.stringify(frameOrigin)});
			}
		});

		document.addEventListener('DOMContentLoaded', function () {
			new MutationObserver((mutationList) => {
				for (const mutation of mutationList) {
					if (mutation.type === "attributes" && mutation.attributeName == "class") {
						let newBackgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--vscode-sideBar-background');
						if (newBackgroundColor !== currentBackgroundColor) {
							setIframeSrc();
						}
					}
				}
			}).observe(document.body, { attributeFilter : ['class'], attributeOldValue: true });
		});
		`;
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [],
        };
        webviewView.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src *; script-src 'unsafe-inline'; style-src 'unsafe-inline';">
			<script>${pageScript}</script>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0" allow="clipboard-read; clipboard-write; cross-origin-isolated" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%"></iframe></body>
			</html>
			`;
        this.api = new dart_tooling_api_1.DartApi(constants_1.CommandSource.sidebarContent, webviewView.webview.onDidReceiveMessage, (message) => webviewView.webview.postMessage(message), this.deviceManager);
        void webviewView.webview.postMessage({ command: "_dart-code.setUrl", url: sidebarUrl });
    }
}


/***/ }),

/***/ 2305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PropertyEditor = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const base_view_provider_1 = __webpack_require__(6437);
class PropertyEditor {
    devTools;
    disposables = [];
    constructor(devTools, dartCapabilities) {
        this.devTools = devTools;
        const webViewProvider = new MyWebViewProvider(devTools, dartCapabilities);
        this.disposables.push(vs.window.registerWebviewViewProvider("flutterPropertyEditor", webViewProvider, { webviewOptions: { retainContextWhenHidden: true } }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.PropertyEditor = PropertyEditor;
class MyWebViewProvider extends base_view_provider_1.MyBaseWebViewProvider {
    get pageName() {
        return "Flutter Property Editor";
    }
    get pageRoute() {
        return "propertyEditor";
    }
}


/***/ }),

/***/ 2470:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDtdSidebar = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const base_view_provider_1 = __webpack_require__(6437);
class FlutterDtdSidebar {
    devTools;
    disposables = [];
    constructor(devTools, dartCapabilities) {
        this.devTools = devTools;
        const webViewProvider = new MyWebViewProvider(devTools, dartCapabilities);
        this.disposables.push(vs.window.registerWebviewViewProvider("dartFlutterSidebar", webViewProvider, { webviewOptions: { retainContextWhenHidden: true } }));
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterDtdSidebar = FlutterDtdSidebar;
class MyWebViewProvider extends base_view_provider_1.MyBaseWebViewProvider {
    get pageName() {
        return "Flutter Sidebar";
    }
    get pageRoute() {
        return "editorSidebar";
    }
}


/***/ }),

/***/ 5684:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageDepPackage = exports.PackageDepProjectPackageGroup = exports.PackageDepProject = exports.PackageDepFolder = exports.PackageDepFile = exports.PackageDep = exports.DartPackagesProvider = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_contexts_1 = __webpack_require__(4471);
const deps_1 = __webpack_require__(5308);
const package_map_1 = __webpack_require__(1721);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
class DartPackagesProvider {
    logger;
    context;
    dartCapabilities;
    disposables = [];
    onDidChangeTreeDataEmitter = new vs.EventEmitter();
    onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    deps;
    packageMapLoader;
    projectFinder;
    processPackageMapChangeEvents = true;
    constructor(logger, context, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependencyFromTreeNode", this.removeDependency, this));
        context.events.onPackageMapChange.listen(() => {
            // Calling "pub deps --json" modifies .dart_tool/package_config.json which
            // causes a loop here. The file is modified, we rebuild the tree, which triggers
            // the file to be modified, which rebuilds...
            //
            // As a workaround, when this fires, suppress any further events for a short period.
            // This may result in dropped events, but it's better than the loop.
            if (!this.processPackageMapChangeEvents)
                return;
            this.processPackageMapChangeEvents = false;
            setTimeout(() => this.processPackageMapChangeEvents = true, 5000);
            this.onDidChangeTreeDataEmitter.fire(undefined);
        });
        this.deps = new deps_1.PubDeps(logger, context, dartCapabilities);
        this.packageMapLoader = new package_map_1.PackageMapLoader(logger);
        this.projectFinder = new utils_2.ProjectFinder(logger);
    }
    getTreeItem(element) {
        return element;
    }
    async getChildren(element) {
        if (!element) {
            const allProjects = await this.projectFinder.findAllProjectFolders(utils_3.getExcludedFolders, { requirePubspec: true, sort: true, searchDepth: config_1.config.projectSearchDepth });
            const nodes = allProjects.map((folder) => new PackageDepProject(vs.Uri.file(folder)));
            // If there's only one, just skip over to the deps.
            return nodes.length === 1
                ? this.getChildren(nodes[0])
                : nodes;
        }
        else if (element instanceof PackageDepProject) {
            const rootPackageFolder = element.rootPackageFolder;
            // Fetch dependencies with "pub deps --json".
            const packageMap = this.packageMapLoader.loadForProject(rootPackageFolder);
            const root = await this.deps.getTree(rootPackageFolder);
            const rootPackage = root?.roots.at(0); // TODO(dantup): Fix this!
            const dependencies = rootPackage?.dependencies ?? [];
            const devDependencies = rootPackage?.devDependencies ?? [];
            const transitiveDependencies = rootPackage?.transitiveDependencies ?? [];
            const dependenciesNodes = dependencies.map((dep) => this.createDependencyNode(packageMap, rootPackageFolder, dep, constants_contexts_1.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT)).filter(utils_1.notNullOrUndefined);
            const devDependenciesNodes = devDependencies.map((dep) => this.createDependencyNode(packageMap, rootPackageFolder, dep, constants_contexts_1.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT)).filter(utils_1.notNullOrUndefined);
            const transitiveDependenciesNodes = transitiveDependencies.map((dep) => this.createDependencyNode(packageMap, rootPackageFolder, dep, constants_contexts_1.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT)).filter(utils_1.notNullOrUndefined);
            // Split the packages into groups.
            const nodes = [];
            if (dependenciesNodes.length)
                nodes.push(new PackageDepProjectPackageGroup("direct dependencies", constants_contexts_1.DART_DEP_DEPENDENCIES_NODE_CONTEXT, dependenciesNodes));
            if (devDependenciesNodes.length)
                nodes.push(new PackageDepProjectPackageGroup("dev dependencies", constants_contexts_1.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT, devDependenciesNodes));
            if (transitiveDependenciesNodes.length)
                nodes.push(new PackageDepProjectPackageGroup("transitive dependencies", constants_contexts_1.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT, transitiveDependenciesNodes));
            return nodes;
        }
        else if (element instanceof PackageDepProjectPackageGroup) {
            // For the package groups, we've already computed the children when we split
            // them into the grous, so just return them directly.
            return element.packages;
        }
        else if (element instanceof PackageDepPackage) {
            return this.getFilesAndFolders(element);
        }
        else if (element instanceof PackageDepFolder) {
            return this.getFilesAndFolders(element);
        }
        else if (element instanceof PackageDepFile) {
            return [];
        }
        else {
            this.logger.warn(`Don't know how to show children of ${element.label}/${element.resourceUri}`);
            return [];
        }
    }
    createDependencyNode(packageMap, rootPackageFolder, dependency, contextValue) {
        let dependencyPath = packageMap.getPackagePath(dependency.name);
        if (!dependencyPath || (0, fs_1.areSameFolder)(dependencyPath, path.join(rootPackageFolder, "lib")))
            return;
        if (path.basename(dependencyPath) === "lib")
            dependencyPath = path.normalize(path.join(dependencyPath, ".."));
        const shortestPath = "shortestPath" in dependency ? dependency.shortestPath : undefined;
        const node = new PackageDepPackage(`${dependency.name}`, vs.Uri.file(dependencyPath), rootPackageFolder, shortestPath);
        node.contextValue = contextValue;
        return node;
    }
    getFilesAndFolders(folder) {
        if (!folder.resourceUri)
            return [];
        let children;
        try {
            children = fs.readdirSync((0, fs_1.fsPath)(folder.resourceUri), { withFileTypes: true });
        }
        catch {
            return [];
        }
        children = (0, array_1.sortBy)(children, (s) => s.name.toLowerCase());
        const folders = [];
        const files = [];
        const folderPath = (0, fs_1.fsPath)(folder.resourceUri);
        children.forEach((child) => {
            const filePath = path.join(folderPath, child.name);
            if (child.isFile()) {
                files.push(new PackageDepFile(vs.Uri.file(filePath)));
            }
            else if (child.isDirectory()) {
                folders.push(new PackageDepFolder(vs.Uri.file(filePath)));
            }
        });
        return [...folders, ...files];
    }
    async removeDependency(treeNode) {
        const packageName = treeNode?.packageName;
        const projectFolder = treeNode?.rootPackageFolder;
        if (packageName && projectFolder)
            await vs.commands.executeCommand("_dart.removeDependency", treeNode.rootPackageFolder, treeNode.packageName);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartPackagesProvider = DartPackagesProvider;
/// A tree node in the packages tree.
class PackageDep extends vs.TreeItem {
    constructor(label, resourceUri, collapsibleState) {
        if (label) {
            super(label, collapsibleState);
            this.resourceUri = resourceUri;
        }
        else if (resourceUri) {
            super(resourceUri, collapsibleState);
        }
        else {
            super("<unnamed>", collapsibleState);
        }
    }
}
exports.PackageDep = PackageDep;
/// A file  within a dependency.
class PackageDepFile extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.None);
        this.contextValue = constants_contexts_1.DART_DEP_FILE_NODE_CONTEXT;
        this.command = {
            arguments: [resourceUri],
            command: "dart.package.openFile",
            title: "Open File",
        };
    }
}
exports.PackageDepFile = PackageDepFile;
/// A folder within a dependency.
class PackageDepFolder extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_contexts_1.DART_DEP_FOLDER_NODE_CONTEXT;
    }
}
exports.PackageDepFolder = PackageDepFolder;
/// A tree node representing a project in the workspace.
class PackageDepProject extends PackageDep {
    rootPackageFolder;
    constructor(rootPackageUri) {
        const rootPackageFolder = (0, fs_1.fsPath)(rootPackageUri);
        const wf = vs.workspace.getWorkspaceFolder(rootPackageUri);
        const label = wf
            // Show the relative path from the wf unless it is the wf, in which case show its name.
            ? path.relative((0, fs_1.fsPath)(wf.uri), rootPackageFolder) || path.basename((0, fs_1.fsPath)(wf.uri))
            : path.basename(rootPackageFolder);
        // Show folder name if there is a wf and we're not that folder.
        const description = wf && path.relative((0, fs_1.fsPath)(wf.uri), rootPackageFolder)
            ? path.basename((0, fs_1.fsPath)(wf.uri))
            : undefined;
        super(label, undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.rootPackageFolder = rootPackageFolder;
        this.contextValue = constants_contexts_1.DART_DEP_PROJECT_NODE_CONTEXT;
        this.description = description;
    }
}
exports.PackageDepProject = PackageDepProject;
/// A tree node representing a group (dependencies, dev dependencies, transitive dependencies).
class PackageDepProjectPackageGroup extends PackageDep {
    packages;
    constructor(label, context, packages) {
        super(label, undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.packages = packages;
        this.contextValue = context;
    }
}
exports.PackageDepProjectPackageGroup = PackageDepProjectPackageGroup;
/// A tree node represending a dependency (of any kind).
class PackageDepPackage extends PackageDep {
    packageName;
    rootPackageFolder;
    constructor(packageName, resourceUri, rootPackageFolder, shortestPath) {
        super(packageName, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.packageName = packageName;
        this.rootPackageFolder = rootPackageFolder;
        this.contextValue = constants_contexts_1.DART_DEP_PACKAGE_NODE_CONTEXT;
        if (shortestPath)
            this.tooltip = shortestPath.join(" → ");
    }
}
exports.PackageDepPackage = PackageDepPackage;


/***/ }),

/***/ 8028:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageDepPackage = exports.PackageDepProjectPackageGroup = exports.PackageDepProject = exports.PackageDepFolder = exports.PackageDepFile = exports.PackageDep = exports.DartPackagesProviderLegacy = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_contexts_1 = __webpack_require__(4471);
const package_map_1 = __webpack_require__(1721);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const utils_2 = __webpack_require__(1894);
const config_1 = __webpack_require__(7678);
const utils_3 = __webpack_require__(279);
class DartPackagesProviderLegacy {
    logger;
    context;
    dartCapabilities;
    disposables = [];
    onDidChangeTreeDataEmitter = new vs.EventEmitter();
    onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    processPackageMapChangeEvents = true;
    constructor(logger, context, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependencyFromTreeNode", this.removeDependency, this));
        context.events.onPackageMapChange.listen(() => {
            // Calling "pub deps --json" modifies .dart_tool/package_config.json which
            // causes a loop here. The file is modified, we rebuild the tree, which triggers
            // the file to be modified, which rebuilds...
            //
            // As a workaround, when this fires, suppress any further events for a short period.
            // This may result in dropped events, but it's better than the loop.
            if (!this.processPackageMapChangeEvents)
                return;
            this.processPackageMapChangeEvents = false;
            setTimeout(() => this.processPackageMapChangeEvents = true, 5000);
            this.onDidChangeTreeDataEmitter.fire(undefined);
        });
    }
    getTreeItem(element) {
        return element;
    }
    async getChildren(element) {
        if (!element) {
            const allProjects = await (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            const nodes = allProjects.map((folder) => new PackageDepProject(vs.Uri.file(folder)));
            // If there's only one, just skip over to the deps.
            return nodes.length === 1
                ? this.getChildren(nodes[0])
                : nodes;
        }
        else if (element instanceof PackageDepProject) {
            // Get packages from package file.
            return await this.getPackages(element);
        }
        else if (element instanceof PackageDepProjectPackageGroup) {
            // For the package groups, we've already computed the children when we split
            // them into the grous, so just return them directly.
            return element.packages;
        }
        else if (element instanceof PackageDepPackage) {
            return this.getFilesAndFolders(element);
        }
        else if (element instanceof PackageDepFolder) {
            return this.getFilesAndFolders(element);
        }
        else if (element instanceof PackageDepFile) {
            return [];
        }
        else {
            this.logger.warn(`Don't know how to show children of ${element.label}/${element.resourceUri}`);
            return [];
        }
    }
    async getPackages(project) {
        const map = package_map_1.PackageMap.loadForProject(this.logger, project.projectFolder);
        const packages = map.packages;
        const packageNames = (0, array_1.sortBy)(Object.keys(packages), (s) => s.toLowerCase());
        const packageDepNodes = packageNames
            .filter((name) => packages[name] && !(0, fs_1.areSameFolder)(packages[name], path.join(project.projectFolder, "lib")))
            .map((name) => {
            let packagePath = packages[name];
            if (path.basename(packagePath) === "lib")
                packagePath = path.normalize(path.join(packagePath, ".."));
            return new PackageDepPackage(`${name}`, vs.Uri.file(packagePath), project.projectFolder, undefined);
        });
        return packageDepNodes;
    }
    getFilesAndFolders(folder) {
        const children = (0, array_1.sortBy)(fs.readdirSync((0, fs_1.fsPath)(folder.resourceUri), { withFileTypes: true }), (s) => s.name.toLowerCase());
        const folders = [];
        const files = [];
        if (!folder.resourceUri)
            return [];
        const folderPath = (0, fs_1.fsPath)(folder.resourceUri);
        children.forEach((child) => {
            const filePath = path.join(folderPath, child.name);
            if (child.isFile()) {
                files.push(new PackageDepFile(vs.Uri.file(filePath)));
            }
            else if (child.isDirectory()) {
                folders.push(new PackageDepFolder(vs.Uri.file(filePath)));
            }
        });
        return [...folders, ...files];
    }
    async removeDependency(treeNode) {
        const packageName = treeNode?.packageName;
        const projectFolder = treeNode?.projectFolder;
        if (packageName && projectFolder)
            await vs.commands.executeCommand("_dart.removeDependency", treeNode.projectFolder, treeNode.packageName);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartPackagesProviderLegacy = DartPackagesProviderLegacy;
class PackageDep extends vs.TreeItem {
    constructor(label, resourceUri, collapsibleState) {
        if (label) {
            super(label, collapsibleState);
            this.resourceUri = resourceUri;
        }
        else if (resourceUri) {
            super(resourceUri, collapsibleState);
        }
        else {
            super("<unnamed>", collapsibleState);
        }
    }
}
exports.PackageDep = PackageDep;
class PackageDepFile extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.None);
        this.contextValue = constants_contexts_1.DART_DEP_FILE_NODE_CONTEXT;
        this.command = {
            arguments: [resourceUri],
            command: "dart.package.openFile",
            title: "Open File",
        };
    }
}
exports.PackageDepFile = PackageDepFile;
class PackageDepFolder extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_contexts_1.DART_DEP_FOLDER_NODE_CONTEXT;
    }
}
exports.PackageDepFolder = PackageDepFolder;
class PackageDepProject extends PackageDep {
    projectFolder;
    constructor(projectUri) {
        const projectFolder = (0, fs_1.fsPath)(projectUri);
        super(path.basename(projectFolder), undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.projectFolder = projectFolder;
        this.contextValue = constants_contexts_1.DART_DEP_PROJECT_NODE_CONTEXT;
        // Calculate relative path to the folder for the description.
        const wf = vs.workspace.getWorkspaceFolder(projectUri);
        if (wf) {
            const workspaceFolder = (0, fs_1.fsPath)(wf.uri);
            this.description = path.relative(path.dirname(workspaceFolder), path.dirname(projectFolder));
        }
    }
}
exports.PackageDepProject = PackageDepProject;
class PackageDepProjectPackageGroup extends PackageDep {
    packages;
    constructor(label, context, packages) {
        super(label, undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.packages = packages;
        this.contextValue = context;
    }
}
exports.PackageDepProjectPackageGroup = PackageDepProjectPackageGroup;
class PackageDepPackage extends PackageDep {
    packageName;
    projectFolder;
    constructor(packageName, resourceUri, projectFolder, shortestPath) {
        super(packageName, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.packageName = packageName;
        this.projectFolder = projectFolder;
        this.contextValue = constants_contexts_1.DART_DEP_PACKAGE_NODE_CONTEXT;
        if (shortestPath)
            this.tooltip = shortestPath.join(" → ");
    }
}
exports.PackageDepPackage = PackageDepPackage;


/***/ }),

/***/ 815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteStatementRequest = exports.ReanalyzeRequest = exports.ConnectToDtdRequest = exports.DiagnosticServerRequest = exports.AugmentationRequest = exports.AugmentedRequest = exports.ImportsRequest = exports.SuperRequest = exports.PublishFlutterOutlineNotification = exports.PublishOutlineNotification = exports.PublishClosingLabelsNotification = exports.OpenUriNotification = exports.AnalyzerStatusNotification = void 0;
const vscode_languageclient_1 = __webpack_require__(99);
class AnalyzerStatusNotification {
    static type = new vscode_languageclient_1.NotificationType("$/analyzerStatus");
}
exports.AnalyzerStatusNotification = AnalyzerStatusNotification;
class OpenUriNotification {
    static type = new vscode_languageclient_1.NotificationType("dart/openUri");
}
exports.OpenUriNotification = OpenUriNotification;
class PublishClosingLabelsNotification {
    static type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishClosingLabels");
}
exports.PublishClosingLabelsNotification = PublishClosingLabelsNotification;
class PublishOutlineNotification {
    static type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishOutline");
}
exports.PublishOutlineNotification = PublishOutlineNotification;
class PublishFlutterOutlineNotification {
    static type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishFlutterOutline");
}
exports.PublishFlutterOutlineNotification = PublishFlutterOutlineNotification;
class SuperRequest {
    static type = new vscode_languageclient_1.RequestType("dart/textDocument/super");
}
exports.SuperRequest = SuperRequest;
class ImportsRequest {
    static type = new vscode_languageclient_1.RequestType("dart/textDocument/imports");
}
exports.ImportsRequest = ImportsRequest;
class AugmentedRequest {
    static type = new vscode_languageclient_1.RequestType("dart/textDocument/augmented");
}
exports.AugmentedRequest = AugmentedRequest;
class AugmentationRequest {
    static type = new vscode_languageclient_1.RequestType("dart/textDocument/augmentation");
}
exports.AugmentationRequest = AugmentationRequest;
class DiagnosticServerRequest {
    static type = new vscode_languageclient_1.RequestType0("dart/diagnosticServer");
}
exports.DiagnosticServerRequest = DiagnosticServerRequest;
class ConnectToDtdRequest {
    static type = new vscode_languageclient_1.RequestType("dart/connectToDtd");
}
exports.ConnectToDtdRequest = ConnectToDtdRequest;
class ReanalyzeRequest {
    static type = new vscode_languageclient_1.RequestType0("dart/reanalyze");
}
exports.ReanalyzeRequest = ReanalyzeRequest;
class CompleteStatementRequest {
    static type = new vscode_languageclient_1.RequestType("dart/completeStatement");
}
exports.CompleteStatementRequest = CompleteStatementRequest;


/***/ }),

/***/ 5244:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Analyzer = void 0;
const events_1 = __webpack_require__(9495);
const utils_1 = __webpack_require__(949);
const promises_1 = __webpack_require__(1902);
class Analyzer {
    logger;
    disposables = [];
    onReadyCompleter = new utils_1.PromiseCompleter();
    onReady = this.onReadyCompleter.promise;
    onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
    // InitialAnalysis uses the very first promise from onAnalysisCompleteCompleter.
    onInitialAnalysis = this.onAnalysisCompleteCompleter.promise;
    get onCurrentAnalysisComplete() { return this.isAnalyzing ? this.onAnalysisCompleteCompleter.promise : promises_1.resolvedPromise; }
    get onNextAnalysisComplete() { return this.onAnalysisCompleteCompleter.promise; }
    // TODO: Remove suppressProgress when non-LSP is gone and Flutter stable has LSP server that uses $/progress.
    onAnalysisStatusChangeEmitter = new events_1.EventEmitter();
    onAnalysisStatusChange = this.onAnalysisStatusChangeEmitter.event;
    isAnalyzing = false;
    constructor(logger) {
        this.logger = logger;
        this.disposables.push(this.onAnalysisStatusChangeEmitter);
        void this.setup();
    }
    async setup() {
        await this.onReady;
        this.onAnalysisStatusChange((status) => {
            this.isAnalyzing = status.isAnalyzing;
            if (!status.isAnalyzing) {
                this.onAnalysisCompleteCompleter.resolve();
                this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
            }
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.Analyzer = Analyzer;


/***/ }),

/***/ 6854:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCapabilities = void 0;
const utils_1 = __webpack_require__(949);
const constants_1 = __webpack_require__(6709);
class DartCapabilities {
    static get empty() { return new DartCapabilities("0.0.0"); }
    version;
    constructor(dartVersion) {
        this.version = dartVersion;
    }
    get canDefaultLsp() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get canDefaultSdkDaps() {
        // For Windows, we need a higher version.
        // https://github.com/Dart-Code/Dart-Code/issues/4149
        // https://github.com/dart-lang/sdk/commit/1b9adcb502c5e4ec1bc5ce8e8b0387db25216833
        if (constants_1.isWin)
            return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-196");
        else
            return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-0");
    }
    get hasLspInsertTextModeSupport() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-0"); }
    // No SDKs are currently unsupported.
    get isUnsupportedNow() { return false; }
    // SDKs older than 3.0 are deprecated as of the release of Dart 3.6.
    // https://groups.google.com/g/flutter-announce/c/JQHzM3FbBGI
    get isUnsupportedSoon() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.0.0"); }
    get supportsSnippetTextEdits() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-150"); }
    get supportsRefactorValidate() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0"); }
    get supportsWriteServiceInfo() { return (0, utils_1.versionIsAtLeast)(this.version, "2.7.1"); }
    get supportsDartCreate() { return (0, utils_1.versionIsAtLeast)(this.version, "2.10.0"); }
    get supportsDebugInternalLibraries() { return (0, utils_1.versionIsAtLeast)(this.version, "2.9.0-a"); }
    get supportsLanguageServerCommand() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.4"); }
    get supportsNoServeDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-172.0"); }
    get supportsPubUpgradeMajorVersions() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0"); }
    get needsNoExampleForPubGet() { return (0, utils_1.versionIsAtLeast)(this.version, "3.1.0"); }
    get omitsVoidForSetters() { return (0, utils_1.versionIsAtLeast)(this.version, "3.3.0-0"); }
    get supportsAugmentations() { return (0, utils_1.versionIsAtLeast)(this.version, "3.7.0-0"); }
    get supportsPubOutdated() { return (0, utils_1.versionIsAtLeast)(this.version, "2.8.0-a"); }
    get supportsGoToImports() { return (0, utils_1.versionIsAtLeast)(this.version, "3.7.0-0"); }
    get supportsFlutterSidebar() { return (0, utils_1.versionIsAtLeast)(this.version, "3.2.0-201"); }
    get supportsPubDepsJson() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-0"); }
    get supportsPubAddMultiple() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0"); }
    get supportsDartPub() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsDartRunForPub() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0-0"); }
    get supportsDartDoc() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0"); }
    get supportsDartDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.15.0"); }
    get supportsDartDevToolsPathUrls() { return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-0"); }
    get requiresDevToolsEmbedFlag() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.7.0-0"); }
    get supportsDevToolsDtdExposedUri() { return (0, utils_1.versionIsAtLeast)(this.version, "3.6.0-255"); }
    get supportsDartRunTest() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsLegacyAnalyzerProtocol() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.3.0"); }
    get supportsMacroGeneratedFiles() { return (0, utils_1.versionIsAtLeast)(this.version, "3.5.0-0"); }
    get supportsMoveTopLevelToFile() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-283"); }
    get supportsNonFileSchemeWorkspaces() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-28"); }
    get supportsCommandParameterSupportedKinds() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-283"); }
    get supportsServerSnippets() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0-258"); }
    get supportsFormatSpecifiers() { return (0, utils_1.versionIsAtLeast)(this.version, "3.0.0-0"); }
    get supportsSdkDap() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0-0"); }
    get supportsShowTodoArray() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0-0"); }
    get sdkDapProvidesExceptionText() { return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-265"); }
    get supportsSetIsolatePauseModeForWeb() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0"); }
    get supportsDevToolsVsCodeExtensions() { return (0, utils_1.versionIsAtLeast)(this.version, "3.3.0-247"); }
    get supportsDevToolsDtdSidebar() { return (0, utils_1.versionIsAtLeast)(this.version, "3.6.0-160"); }
    /**
     * Whether this version of the SDK supports DTD. This should be checked only for
     * spawning DTD and not whether it's available within the extension.
     */
    get supportsToolingDaemon() { return (0, utils_1.versionIsAtLeast)(this.version, "3.4.0-139"); }
    // TODO: Update these (along with Flutter) when supported.
    get webSupportsHotReload() { return false; }
    get workspaceSymbolSearchUsesFuzzy() { return (0, utils_1.versionIsAtLeast)(this.version, "3.1.0"); }
}
exports.DartCapabilities = DartCapabilities;


/***/ }),

/***/ 3877:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTestCapabilities = void 0;
const utils_1 = __webpack_require__(949);
class DartTestCapabilities {
    static get empty() { return new DartTestCapabilities("0.0.0"); }
    version;
    constructor(testVersion) {
        this.version = testVersion;
    }
    get supportsIgnoreTimeouts() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.1"); }
    get supportsRunTestsByLine() { return (0, utils_1.versionIsAtLeast)(this.version, "1.23.1"); }
}
exports.DartTestCapabilities = DartTestCapabilities;


/***/ }),

/***/ 395:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsServerCapabilities = void 0;
const utils_1 = __webpack_require__(949);
class DevToolsServerCapabilities {
    static get empty() { return new DevToolsServerCapabilities("0.0.0"); }
    version;
    constructor(devToolsServerVersion) {
        this.version = devToolsServerVersion;
    }
    get supportsVsCodeExtensions() { return (0, utils_1.versionIsAtLeast)(this.version, "1.2.0"); }
}
exports.DevToolsServerCapabilities = DevToolsServerCapabilities;


/***/ }),

/***/ 8997:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DaemonCapabilities = exports.FlutterCapabilities = void 0;
const utils_1 = __webpack_require__(949);
class FlutterCapabilities {
    static get empty() { return new FlutterCapabilities("0.0.0"); }
    version;
    constructor(flutterVersion) {
        this.version = flutterVersion;
    }
    get canDefaultSdkDaps() { return (0, utils_1.versionIsAtLeast)(this.version, "3.9.0-14"); }
    /// Used to keep the percentage of DAP users on < 3.13 lower and increase only for newer.
    get useLegacyDapExperiment() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.13.0"); }
    get supportsCreateSkeleton() { return (0, utils_1.versionIsAtLeast)(this.version, "2.5.0"); }
    get supportsCreateEmpty() { return (0, utils_1.versionIsAtLeast)(this.version, "3.6.0-3"); }
    get supportsCreatingSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.0.0"); }
    get hasLatestStructuredErrorsWork() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-5.0"); }
    get hasSdkDapWithStructuredErrors() { return (0, utils_1.versionIsAtLeast)(this.version, "3.16.0-0"); }
    get supportsFlutterCreateListSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.3.10"); }
    get supportsFlutterHostVmServicePort() { return (0, utils_1.versionIsAtLeast)(this.version, "3.0.0"); }
    get supportsWsVmService() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsWsDebugBackend() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsWsInjectedClient() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-13.0"); }
    get supportsExposeUrl() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsDartDefine() { return (0, utils_1.versionIsAtLeast)(this.version, "1.17.0"); }
    get supportsRestartDebounce() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsRunSkippedTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-11"); }
    get supportsShowWebServerDevice() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-0"); }
    get supportsIOSLanguage() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.23.0"); } // https://github.com/flutter/flutter/issues/148586#issuecomment-2137140743
    get supportsAddPubRootDirectories() { return (0, utils_1.versionIsAtLeast)(this.version, "3.19.0"); }
    get supportsWebRendererOption() { return (0, utils_1.versionIsAtLeast)(this.version, "1.25.0-0"); }
    get supportsDevToolsServerAddress() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-12"); }
    get supportsRunningIntegrationTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.2.0-10"); }
    get supportsRunTestsByLine() { return (0, utils_1.versionIsAtLeast)(this.version, "3.10.0-0"); }
    get supportsSdkDap() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-0"); }
    get requiresDdsDisabledForSdkDapTestRuns() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.1.0"); }
    get requiresForcedDebugModeForNoDebug() { return (0, utils_1.versionIsAtLeast)(this.version, "3.13.0-0"); } // TODO(dantup): Add upper bound when we don't need this.
    // TODO: Update these (along with Dart) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.FlutterCapabilities = FlutterCapabilities;
class DaemonCapabilities {
    static get empty() { return new DaemonCapabilities("0.0.0"); }
    version;
    constructor(daemonProtocolVersion) {
        this.version = daemonProtocolVersion;
    }
    get canCreateEmulators() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.0"); }
    get canFlutterAttach() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.1"); }
    get providesPlatformTypes() { return (0, utils_1.versionIsAtLeast)(this.version, "0.5.2"); }
    get supportsAvdColdBootLaunch() { return (0, utils_1.versionIsAtLeast)(this.version, "0.6.1"); }
}
exports.DaemonCapabilities = DaemonCapabilities;


/***/ }),

/***/ 2461:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vsCodeVersion = exports.CodeCapabilities = void 0;
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const utils_cloud_1 = __webpack_require__(2056);
class CodeCapabilities {
    version;
    constructor(version) {
        this.version = version;
    }
    // This version should match the minimum the LSP client we're using supports.
    // https://github.com/microsoft/vscode-languageserver-node/blob/main/client/src/node/main.ts#L25
    get supportsLatestLspClient() { return (0, utils_1.versionIsAtLeast)(this.version, "1.67.0"); }
    // Theia doesn't currently support launching without a launch.json. This may need updating to also
    // check the version in future.
    get supportsDebugWithoutLaunchJson() { return !(0, utils_cloud_1.isTheia)(vscode_1.env.appName); }
    // Cloud IDEs may have authentication issues trying to use embedded DevTools so just disable it.
    get supportsEmbeddedDevTools() { return !(0, utils_cloud_1.isKnownCloudIde)(vscode_1.env.appName); }
    get supportsDevTools() { return !(0, utils_cloud_1.isCloudShell)(vscode_1.env.appName); } // Until DevTools can work without SSE, it will not work on Cloud Shell.
    get editorConfigFolder() { return (0, utils_cloud_1.isTheia)(vscode_1.env.appName) ? ".theia" : ".vscode"; }
}
exports.CodeCapabilities = CodeCapabilities;
exports.vsCodeVersion = new CodeCapabilities(vscode_1.version);


/***/ }),

/***/ 4471:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DART_DEP_FILE_NODE_CONTEXT = exports.DART_DEP_FOLDER_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_PACKAGE_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_PROJECT_NODE_CONTEXT = exports.isInFlutterReleaseModeDebugSessionContext = exports.isInFlutterProfileModeDebugSessionContext = exports.isInFlutterDebugModeDebugSessionContext = exports.isInDartDebugSessionContext = exports.HAS_LAST_TEST_DEBUG_CONFIG = exports.HAS_LAST_DEBUG_CONFIG = exports.SERVICE_CONTEXT_PREFIX = exports.SERVICE_EXTENSION_CONTEXT_PREFIX = exports.FLUTTER_SUPPORTS_ATTACH = exports.LSP_REQUEST_CONTEXT_PREFIX = exports.LSP_COMMAND_CONTEXT_PREFIX = exports.DTD_AVAILABLE = exports.SUPPORTS_DEBUG_VALUE_FORMAT = exports.FLUTTER_SIDEBAR_SUPPORTED_CONTEXT = exports.GO_TO_IMPORTS_SUPPORTED_CONTEXT = exports.PUB_OUTDATED_SUPPORTED_CONTEXT = exports.SDK_IS_PRE_RELEASE = exports.DART_PLATFORM_NAME = exports.WEB_PROJECT_LOADED = exports.FLUTTER_PROJECT_LOADED = exports.DART_PROJECT_LOADED = exports.PROJECT_LOADED = exports.IS_RUNNING_LOCALLY_CONTEXT = exports.DART_IS_CAPTURING_LOGS_CONTEXT = exports.IS_LSP_CONTEXT = void 0;
// General.
exports.IS_LSP_CONTEXT = "dart-code:isLsp";
exports.DART_IS_CAPTURING_LOGS_CONTEXT = "dart-code:isCapturingLogs";
exports.IS_RUNNING_LOCALLY_CONTEXT = "dart-code:isRunningLocally";
// Project/workspace kinds.
exports.PROJECT_LOADED = "dart-code:anyProjectLoaded";
exports.DART_PROJECT_LOADED = "dart-code:anyStandardDartProjectLoaded";
exports.FLUTTER_PROJECT_LOADED = "dart-code:anyFlutterProjectLoaded";
exports.WEB_PROJECT_LOADED = "dart-code:WebProjectLoaded";
exports.DART_PLATFORM_NAME = "dart-code:dartPlatformName";
// SDK version specific.
exports.SDK_IS_PRE_RELEASE = "dart-code:isPreReleaseSdk";
exports.PUB_OUTDATED_SUPPORTED_CONTEXT = "dart-code:pubOutdatedSupported";
exports.GO_TO_IMPORTS_SUPPORTED_CONTEXT = "dart-code:goToImportsSupported";
exports.FLUTTER_SIDEBAR_SUPPORTED_CONTEXT = "dart-code:flutterSidebarSupported";
exports.SUPPORTS_DEBUG_VALUE_FORMAT = "dart-code:supportsDebugValueFormat";
exports.DTD_AVAILABLE = "dart-code:dtdAvailable";
exports.LSP_COMMAND_CONTEXT_PREFIX = "dart-code:lsp.command.";
exports.LSP_REQUEST_CONTEXT_PREFIX = "dart-code:lsp.request.";
exports.FLUTTER_SUPPORTS_ATTACH = "dart-code:flutterSupportsAttach";
// Debug session related.
exports.SERVICE_EXTENSION_CONTEXT_PREFIX = "dart-code:serviceExtension.";
exports.SERVICE_CONTEXT_PREFIX = "dart-code:service.";
exports.HAS_LAST_DEBUG_CONFIG = "dart-code:hasLastDebugConfig";
exports.HAS_LAST_TEST_DEBUG_CONFIG = "dart-code:hasLastTestDebugConfig";
exports.isInDartDebugSessionContext = "dart-code:isInDartDebugSession";
exports.isInFlutterDebugModeDebugSessionContext = "dart-code:isInFlutterDebugModeDebugSession";
exports.isInFlutterProfileModeDebugSessionContext = "dart-code:isInFlutterProfileModeDebugSession";
exports.isInFlutterReleaseModeDebugSessionContext = "dart-code:isInFlutterReleaseModeDebugSession";
// Dependencies tree.
exports.DART_DEP_PROJECT_NODE_CONTEXT = "dart-code:depProjectNode";
exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDependenciesNode";
exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDevDependenciesNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = "dart-code:depTransitiveDependenciesNode";
exports.DART_DEP_PACKAGE_NODE_CONTEXT = "dart-code:depPackageNode";
exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDependencyPackageNode";
exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDevDependencyPackageNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depTransitiveDependencyPackageNode";
exports.DART_DEP_FOLDER_NODE_CONTEXT = "dart-code:depFolderNode";
exports.DART_DEP_FILE_NODE_CONTEXT = "dart-code:depFileNode";


/***/ }),

/***/ 6709:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unableToAddToPathPrompt = exports.addSdkToPathPrompt = exports.addedToPathPrompt = exports.sdkAlreadyOnPathPrompt = exports.noSdkAvailablePrompt = exports.skipThisSurveyAction = exports.takeSurveyAction = exports.flutterSurveyDataUrl = exports.moreInfoAction = exports.doNotAskAgainAction = exports.notTodayAction = exports.alwaysOpenAction = exports.openAction = exports.wantToTryDevToolsPrompt = exports.issueTrackerUri = exports.issueTrackerAction = exports.pubGlobalDocsUrl = exports.debugTerminatingProgressId = exports.debugLaunchProgressId = exports.restartReasonSave = exports.restartReasonManual = exports.captureLogsMaxLineLength = exports.showLogAction = exports.stopLoggingAction = exports.FLUTTER_DOWNLOAD_URL = exports.DART_DOWNLOAD_URL = exports.androidStudioPaths = exports.analyzerSnapshotPath = exports.pubSnapshotPath = exports.flutterPath = exports.pubPath = exports.dartDocPath = exports.devToolsToolLegacyPath = exports.devToolsToolPath = exports.dartVMPath = exports.getExecutableName = exports.executableNames = exports.androidStudioExecutableNames = exports.platformEol = exports.platformDisplayName = exports.dartPlatformName = exports.isChromeOS = exports.isLinux = exports.isMac = exports.isWin = exports.isDartCodeTestRun = exports.isCI = exports.debugAdapterPath = exports.flutterExtensionIdentifier = exports.dartCodeExtensionIdentifier = void 0;
exports.runFlutterCreatePrompt = exports.CommandSource = exports.sdkDeprecationInformationUrl = exports.vmServiceHttpLinkPattern = exports.vmServiceListeningBannerPattern = exports.tryAgainAction = exports.openSettingsAction = exports.recommendedSettingsUrl = exports.showRecommendedSettingsAction = exports.iUnderstandAction = exports.skipAction = exports.noThanksAction = exports.noAction = exports.yesAction = exports.useRecommendedSettingsPromptKey = exports.installFlutterExtensionPromptKey = exports.userPromptContextPrefix = exports.runAnywayAction = exports.showErrorsAction = exports.REFACTOR_ANYWAY = exports.REFACTOR_FAILED_DOC_MODIFIED = exports.flutterCreateTemplatesSupportingPlatforms = exports.flutterCreateAvailablePlatforms = exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = exports.DART_CREATE_PROJECT_TRIGGER_FILE = exports.CHROME_OS_VM_SERVICE_PORT = exports.CHROME_OS_DEVTOOLS_PORT = exports.projectSearchCacheTimeInMs = exports.projectSearchProgressNotificationDelayInMs = exports.projectSearchProgressText = exports.pleaseReportBug = exports.longRepeatPromptThreshold = exports.noRepeatPromptThreshold = exports.fortyHoursInMs = exports.twentyHoursInMs = exports.twoHoursInMs = exports.twentyMinutesInMs = exports.tenMinutesInMs = exports.fiveMinutesInMs = exports.twentySecondsInMs = exports.tenSecondsInMs = exports.closeAction = exports.cancelAction = exports.cloningFlutterMessage = exports.initializingFlutterMessage = exports.modifyingFilesOutsideWorkspaceInfoUrl = exports.addToPathInstructionsUrl = exports.addSdkToPathAction = exports.copySdkPathToClipboardAction = exports.openInstructionsAction = void 0;
exports.MISSING_VERSION_FILE_VERSION = exports.MAX_VERSION = exports.defaultLaunchJson = exports.dartRecommendedConfig = exports.devToolsPages = exports.performancePage = exports.cpuProfilerPage = exports.widgetInspectorPage = exports.devToolsHomePage = exports.validClassNameRegex = exports.validMethodNameRegex = void 0;
const fs = __importStar(__webpack_require__(9896));
const utils_1 = __webpack_require__(949);
exports.dartCodeExtensionIdentifier = "Dart-Code.dart-code";
exports.flutterExtensionIdentifier = "Dart-Code.flutter";
exports.debugAdapterPath = "out/dist/debug.js";
exports.isCI = !!process.env.CI;
exports.isDartCodeTestRun = !!process.env.DART_CODE_IS_TEST_RUN;
exports.isWin = process.platform.startsWith("win");
exports.isMac = process.platform === "darwin";
exports.isLinux = !exports.isWin && !exports.isMac;
exports.isChromeOS = exports.isLinux && fs.existsSync("/dev/.cros_milestone");
// Used for code checks and in Dart SDK urls so Chrome OS is considered Linux.
exports.dartPlatformName = exports.isWin ? "win" : exports.isMac ? "mac" : "linux";
// Used for display (logs, analytics) so Chrome OS is its own.
exports.platformDisplayName = exports.isWin ? "win" : exports.isMac ? "mac" : exports.isChromeOS ? "chromeos" : "linux";
exports.platformEol = exports.isWin ? "\r\n" : "\n";
exports.androidStudioExecutableNames = exports.isWin ? ["studio64.exe"] : ["studio.sh", "studio"];
exports.executableNames = {
    dart: exports.isWin ? "dart.exe" : "dart",
    dartdoc: exports.isWin ? "dartdoc.bat" : "dartdoc",
    devToolsToolBinary: exports.isWin ? "dt.bat" : "dt",
    devToolsToolLegacyBinary: exports.isWin ? "devtools_tool.bat" : "devtools_tool",
    flutter: exports.isWin ? "flutter.bat" : "flutter",
    pub: exports.isWin ? "pub.bat" : "pub",
};
const getExecutableName = (cmd) => exports.executableNames[cmd] ?? cmd;
exports.getExecutableName = getExecutableName;
exports.dartVMPath = "bin/" + exports.executableNames.dart;
exports.devToolsToolPath = "tool/bin/" + exports.executableNames.devToolsToolBinary;
exports.devToolsToolLegacyPath = "tool/bin/" + exports.executableNames.devToolsToolLegacyBinary;
exports.dartDocPath = "bin/" + exports.executableNames.dartdoc;
exports.pubPath = "bin/" + exports.executableNames.pub;
exports.flutterPath = "bin/" + exports.executableNames.flutter;
exports.pubSnapshotPath = "bin/snapshots/pub.dart.snapshot";
exports.analyzerSnapshotPath = "bin/snapshots/analysis_server.dart.snapshot";
exports.androidStudioPaths = exports.androidStudioExecutableNames.map((s) => "bin/" + s);
exports.DART_DOWNLOAD_URL = "https://dart.dev/get-dart";
exports.FLUTTER_DOWNLOAD_URL = "https://flutter.dev/setup/";
exports.stopLoggingAction = "Stop Logging";
exports.showLogAction = "Show Log";
exports.captureLogsMaxLineLength = 999999999;
exports.restartReasonManual = "manual";
exports.restartReasonSave = "save";
exports.debugLaunchProgressId = "launch";
exports.debugTerminatingProgressId = "terminate";
exports.pubGlobalDocsUrl = "https://www.dartlang.org/tools/pub/cmd/pub-global";
exports.issueTrackerAction = "Issue Tracker";
exports.issueTrackerUri = "https://github.com/Dart-Code/Dart-Code/issues";
exports.wantToTryDevToolsPrompt = "Dart DevTools includes additional tools for debugging and profiling Flutter apps, including a Widget Inspector. Try it?";
exports.openAction = "Open";
exports.alwaysOpenAction = "Always Open";
exports.notTodayAction = "Not Now";
exports.doNotAskAgainAction = "Never Ask";
exports.moreInfoAction = "More Info";
exports.flutterSurveyDataUrl = "https://docs.flutter.dev/f/flutter-survey-metadata.json";
exports.takeSurveyAction = "Take Survey";
exports.skipThisSurveyAction = "Skip This Survey";
exports.noSdkAvailablePrompt = "No SDK is available to add to PATH";
const sdkAlreadyOnPathPrompt = (sdkType) => `The ${sdkType} SDK is already in your PATH`;
exports.sdkAlreadyOnPathPrompt = sdkAlreadyOnPathPrompt;
const addedToPathPrompt = (sdkType) => `The ${sdkType} SDK was added to your PATH`;
exports.addedToPathPrompt = addedToPathPrompt;
const addSdkToPathPrompt = (sdkType) => `Do you want to add the ${sdkType} SDK to PATH so it's accessible in external terminals?`;
exports.addSdkToPathPrompt = addSdkToPathPrompt;
const unableToAddToPathPrompt = (sdkType) => `Unable to add the ${sdkType} SDK to PATH automatically. Show instructions to add manually?`;
exports.unableToAddToPathPrompt = unableToAddToPathPrompt;
exports.openInstructionsAction = "Open Instructions";
exports.copySdkPathToClipboardAction = "Copy SDK path to Clipboard";
exports.addSdkToPathAction = "Add SDK to PATH";
exports.addToPathInstructionsUrl = exports.isWin
    ? "https://flutter.dev/to/update-windows-path"
    : exports.isMac
        ? "https://flutter.dev/to/update-macos-path"
        : exports.isLinux && !exports.isChromeOS
            ? "https://flutter.dev/to/update-linux-path"
            : undefined;
exports.modifyingFilesOutsideWorkspaceInfoUrl = "https://dartcode.org/docs/modifying-files-outside-workspace/";
exports.initializingFlutterMessage = "Initializing the Flutter SDK. This may take a few minutes.";
exports.cloningFlutterMessage = "Downloading the Flutter SDK. This may take a few minutes.";
exports.cancelAction = "Cancel";
exports.closeAction = "Close";
// Seconds.
exports.tenSecondsInMs = 1000 * 10;
exports.twentySecondsInMs = 1000 * 20;
exports.fiveMinutesInMs = 1000 * 60 * 5;
exports.tenMinutesInMs = 1000 * 60 * 10;
exports.twentyMinutesInMs = 1000 * 60 * 20;
// Hours.
exports.twoHoursInMs = 1000 * 60 * 60 * 2;
exports.twentyHoursInMs = 1000 * 60 * 60 * 20;
exports.fortyHoursInMs = 1000 * 60 * 60 * 40;
// Duration for not showing a prompt that has been shown before.
exports.noRepeatPromptThreshold = exports.twentyHoursInMs;
exports.longRepeatPromptThreshold = exports.fortyHoursInMs;
exports.pleaseReportBug = "Please raise a bug against the Dart extension for VS Code.";
exports.projectSearchProgressText = "Searching for projects...";
// Search for 2s before showing progress notification.
exports.projectSearchProgressNotificationDelayInMs = 2000;
exports.projectSearchCacheTimeInMs = exports.fiveMinutesInMs;
// Chrome OS exposed ports: 8000, 8008, 8080, 8085, 8888, 9005, 3000, 4200, 5000
exports.CHROME_OS_DEVTOOLS_PORT = 8080;
exports.CHROME_OS_VM_SERVICE_PORT = 8085;
exports.DART_CREATE_PROJECT_TRIGGER_FILE = "dart.create";
exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = "flutter.create";
exports.flutterCreateAvailablePlatforms = ["android", "ios", "linux", "macos", "windows", "web"];
exports.flutterCreateTemplatesSupportingPlatforms = ["app", "plugin", "plugin_ffi", "skeleton"];
exports.REFACTOR_FAILED_DOC_MODIFIED = "This refactor cannot be applied because the document has changed.";
exports.REFACTOR_ANYWAY = "Refactor Anyway";
exports.showErrorsAction = "Show Errors";
exports.runAnywayAction = "Run Anyway";
exports.userPromptContextPrefix = "hasPrompted.";
exports.installFlutterExtensionPromptKey = "install_flutter_extension_3";
exports.useRecommendedSettingsPromptKey = "use_recommended_settings";
exports.yesAction = "Yes";
exports.noAction = "No";
exports.noThanksAction = "No Thanks";
exports.skipAction = "Skip";
exports.iUnderstandAction = "I Understand";
exports.showRecommendedSettingsAction = "Show Recommended Settings";
exports.recommendedSettingsUrl = "https://dartcode.org/docs/recommended-settings/";
exports.openSettingsAction = "Open Settings File";
exports.tryAgainAction = "Try Again";
exports.vmServiceListeningBannerPattern = new RegExp("(?:Observatory|Dart VM [Ss]ervice) .* (?:listening on|available at:) (http:.+)");
exports.vmServiceHttpLinkPattern = new RegExp("(http://[\\d\\.:]+/)");
exports.sdkDeprecationInformationUrl = "https://dartcode.org/sdk-version-compatibility/";
/// Constants used in reporting of where commands are executed from.
///
/// Used in DevTools querystring, so do not change.
class CommandSource {
    static commandPalette = "command";
    static dtdServiceRequest = "dtdServiceRequest";
    static sidebarContent = "sidebarContent";
    static sidebarTitle = "sidebarToolbar";
    static touchbar = "touchbar"; // MacOS touchbar button
    static launchConfiguration = "launchConfiguration"; // Configured explicitly in launch configuration
    static onDebugAutomatic = "onDebugAutomatic"; // Configured to always run on debug session start
    static onDebugPrompt = "onDebugPrompt"; // Responded to prompt when running a debug session
    static languageStatus = "languageStatus"; // Launched from the language status popout
}
exports.CommandSource = CommandSource;
const runFlutterCreatePrompt = (platformType, platformNeedsGloballyEnabling) => platformNeedsGloballyEnabling
    ? `Enable the ${platformType} platform and add it to this project?`
    : `Add the ${platformType} platform to this project?`;
exports.runFlutterCreatePrompt = runFlutterCreatePrompt;
exports.validMethodNameRegex = new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
exports.validClassNameRegex = exports.validMethodNameRegex;
// This isn't included in [devToolsPages] because we only use it as a default.
exports.devToolsHomePage = { id: "home", commandSuffix: "Home", title: "DevTools Home", requiredDartSdkVersion: "3.3.0-0" };
exports.widgetInspectorPage = { id: "inspector", commandSuffix: "Inspector", title: "Widget Inspector", requiresFlutter: true };
exports.cpuProfilerPage = { id: "cpu-profiler", commandSuffix: "CpuProfiler", title: "CPU Profiler" };
exports.performancePage = {
    commandSuffix: "Performance",
    id: "performance",
    requiresFlutter: true,
    routeId: (flutterVersion) => !flutterVersion || (0, utils_1.versionIsAtLeast)(flutterVersion, "2.3.1" /* 2.3.0-16.0? */) ? "performance" : "legacy-performance",
    title: "Performance",
};
exports.devToolsPages = [
    exports.widgetInspectorPage,
    exports.cpuProfilerPage,
    { id: "memory", commandSuffix: "Memory", title: "Memory" },
    exports.performancePage,
    { id: "network", commandSuffix: "Network", title: "Network" },
    { id: "logging", commandSuffix: "Logging", title: "Logging" },
    { id: "deep-links", commandSuffix: "DeepLinks", title: "Deep Links", requiresFlutter: true, requiredDartSdkVersion: "3.3.0-277", isStaticTool: true },
];
exports.dartRecommendedConfig = {
    // Automatically format code on save and during typing of certain characters
    // (like `;` and `}`).
    "editor.formatOnSave": true,
    "editor.formatOnType": true,
    // Draw a guide line at 80 characters, where Dart's formatting will wrap code.
    "editor.rulers": [80],
    // Disables built-in highlighting of words that match your selection. Without
    // this, all instances of the selected text will be highlighted, interfering
    // with Dart's ability to highlight only exact references to the selected variable.
    "editor.selectionHighlight": false,
    // Allows pressing <TAB> to complete snippets such as `for` even when the
    // completion list is not visible.
    "editor.tabCompletion": "onlySnippets",
    // By default, VS Code will populate code completion with words found in the
    // matching documents when a language service does not provide its own completions.
    // This results in code completion suggesting words when editing comments and
    // strings. This setting will prevent that.
    "editor.wordBasedSuggestions": "off",
};
exports.defaultLaunchJson = JSON.stringify({
    configurations: [
        {
            name: "Dart & Flutter",
            request: "launch",
            type: "dart",
        },
    ],
    version: "0.2.0",
}, undefined, "\t");
// This indicates that a version is the latest possible, used for Bazel workspaces.
exports.MAX_VERSION = "999.999.999";
// This indicates the Flutter version file was missing and we are also assuming the highest.
exports.MISSING_VERSION_FILE_VERSION = "999.999.888";


/***/ }),

/***/ 3962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugOption = exports.debugOptionNames = exports.LogSeverity = exports.LogCategory = exports.VersionStatus = exports.VmService = exports.VmServiceExtension = exports.TestStatus = exports.DebuggerType = void 0;
var DebuggerType;
(function (DebuggerType) {
    DebuggerType[DebuggerType["Dart"] = 0] = "Dart";
    DebuggerType[DebuggerType["DartTest"] = 1] = "DartTest";
    DebuggerType[DebuggerType["Flutter"] = 2] = "Flutter";
    DebuggerType[DebuggerType["FlutterTest"] = 3] = "FlutterTest";
    DebuggerType[DebuggerType["Web"] = 4] = "Web";
    DebuggerType[DebuggerType["WebTest"] = 5] = "WebTest";
})(DebuggerType || (exports.DebuggerType = DebuggerType = {}));
var TestStatus;
(function (TestStatus) {
    // This should be in order such that the highest number is the one to show
    // when aggregating (eg. from children).
    TestStatus[TestStatus["Waiting"] = 0] = "Waiting";
    TestStatus[TestStatus["Skipped"] = 1] = "Skipped";
    TestStatus[TestStatus["Passed"] = 2] = "Passed";
    TestStatus[TestStatus["Unknown"] = 3] = "Unknown";
    TestStatus[TestStatus["Failed"] = 4] = "Failed";
    TestStatus[TestStatus["Running"] = 5] = "Running";
})(TestStatus || (exports.TestStatus = TestStatus = {}));
/// The service extensions we know about.
var VmServiceExtension;
(function (VmServiceExtension) {
    VmServiceExtension["PlatformOverride"] = "ext.flutter.platformOverride";
    VmServiceExtension["DebugBanner"] = "ext.flutter.debugAllowBanner";
    VmServiceExtension["DebugPaint"] = "ext.flutter.debugPaint";
    VmServiceExtension["Driver"] = "ext.flutter.driver";
    VmServiceExtension["PaintBaselines"] = "ext.flutter.debugPaintBaselinesEnabled";
    VmServiceExtension["InspectorSelectMode"] = "ext.flutter.inspector.show";
    VmServiceExtension["InspectorAddPubRootDirectories"] = "ext.flutter.inspector.addPubRootDirectories";
    VmServiceExtension["InspectorSetPubRootDirectories"] = "ext.flutter.inspector.setPubRootDirectories";
    VmServiceExtension["BrightnessOverride"] = "ext.flutter.brightnessOverride";
    VmServiceExtension["RepaintRainbow"] = "ext.flutter.repaintRainbow";
    VmServiceExtension["PerformanceOverlay"] = "ext.flutter.showPerformanceOverlay";
    VmServiceExtension["SlowAnimations"] = "ext.flutter.timeDilation";
})(VmServiceExtension || (exports.VmServiceExtension = VmServiceExtension = {}));
/// The service extensions we know about and allow toggling via commands.
var VmService;
(function (VmService) {
    VmService["HotReload"] = "reloadSources";
    VmService["LaunchDevTools"] = "launchDevTools";
})(VmService || (exports.VmService = VmService = {}));
var VersionStatus;
(function (VersionStatus) {
    VersionStatus[VersionStatus["NotInstalled"] = 0] = "NotInstalled";
    VersionStatus[VersionStatus["UpdateRequired"] = 1] = "UpdateRequired";
    VersionStatus[VersionStatus["UpdateAvailable"] = 2] = "UpdateAvailable";
    VersionStatus[VersionStatus["Valid"] = 3] = "Valid";
})(VersionStatus || (exports.VersionStatus = VersionStatus = {}));
var LogCategory;
(function (LogCategory) {
    LogCategory[LogCategory["General"] = 0] = "General";
    LogCategory[LogCategory["CI"] = 1] = "CI";
    LogCategory[LogCategory["CommandProcesses"] = 2] = "CommandProcesses";
    LogCategory[LogCategory["DAP"] = 3] = "DAP";
    LogCategory[LogCategory["DevTools"] = 4] = "DevTools";
    LogCategory[LogCategory["Analyzer"] = 5] = "Analyzer";
    LogCategory[LogCategory["AnalyzerTiming"] = 6] = "AnalyzerTiming";
    LogCategory[LogCategory["DartTest"] = 7] = "DartTest";
    LogCategory[LogCategory["FlutterDaemon"] = 8] = "FlutterDaemon";
    LogCategory[LogCategory["FlutterRun"] = 9] = "FlutterRun";
    LogCategory[LogCategory["FlutterTest"] = 10] = "FlutterTest";
    LogCategory[LogCategory["VmService"] = 11] = "VmService";
    LogCategory[LogCategory["WebDaemon"] = 12] = "WebDaemon";
    LogCategory[LogCategory["DartToolingDaemon"] = 13] = "DartToolingDaemon";
})(LogCategory || (exports.LogCategory = LogCategory = {}));
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Info"] = 0] = "Info";
    LogSeverity[LogSeverity["Warn"] = 1] = "Warn";
    LogSeverity[LogSeverity["Error"] = 2] = "Error";
})(LogSeverity || (exports.LogSeverity = LogSeverity = {}));
exports.debugOptionNames = ["my code", "my code + packages", "my code + packages + SDK", "my code + SDK"];
var DebugOption;
(function (DebugOption) {
    DebugOption[DebugOption["MyCode"] = 0] = "MyCode";
    DebugOption[DebugOption["MyCodePackages"] = 1] = "MyCodePackages";
    DebugOption[DebugOption["MyCodePackagesSdk"] = 2] = "MyCodePackagesSdk";
    DebugOption[DebugOption["MyCodeSdk"] = 3] = "MyCodeSdk";
})(DebugOption || (exports.DebugOption = DebugOption = {}));


/***/ }),

/***/ 9495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventsEmitter = exports.EventEmitter = void 0;
const evt = __importStar(__webpack_require__(4434));
class EventEmitter {
    emitter = new evt.EventEmitter();
    fire(x) {
        this.emitter.emit("thing", x);
    }
    listen(listener, thisArgs) {
        if (thisArgs)
            listener = listener.bind(thisArgs);
        this.emitter.on("thing", listener);
        return {
            dispose: () => { this.emitter.removeListener("thing", listener); },
        };
    }
    get event() { return this.listen.bind(this); }
    dispose() {
        this.emitter.removeAllListeners();
    }
}
exports.EventEmitter = EventEmitter;
class EventsEmitter {
    emitter = new evt.EventEmitter();
    fire(event, x) {
        this.emitter.emit(event, x);
    }
    listen(event, listener, thisArgs) {
        if (thisArgs)
            listener = listener.bind(thisArgs);
        this.emitter.on(event, listener);
        return {
            dispose: () => { this.emitter.removeListener(event, listener); },
        };
    }
    dispose() {
        this.emitter.removeAllListeners();
    }
}
exports.EventsEmitter = EventsEmitter;


/***/ }),

/***/ 924:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebClient = void 0;
const http = __importStar(__webpack_require__(8611));
const https = __importStar(__webpack_require__(5692));
const url = __importStar(__webpack_require__(7016));
const zlib = __importStar(__webpack_require__(3106));
class WebClient {
    userAgent;
    constructor(extensionVersion) {
        this.userAgent = `Dart-Code/${extensionVersion} (https://dartcode.org/)`;
    }
    // TODO: Move over things over to this...
    fetch(urlString, headers) {
        const u = url.parse(urlString);
        if (u.protocol === "https:" && u.hostname)
            return this.fetchHttps(u.hostname, u.port || "443", u.path || "", headers);
        else if (u.protocol === "http:" && u.hostname)
            return this.fetchHttp(u.hostname, u.port || "80", u.path || "", headers);
        else
            throw new Error(`Cannot fetch URL ${urlString}`);
    }
    fetchHttps(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: {
                    ...headers,
                    "User-Agent": this.userAgent,
                },
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = https.request(options, (res) => this.handleResponse(headers, res, resolve, reject, path));
            req.end();
        });
    }
    handleResponse(headers, resp, resolve, reject, path) {
        if (!resp || !resp.statusCode) {
            reject({ message: `Failed to get ${path}: ${resp && resp.statusMessage}` });
        }
        else if (resp.statusCode >= 301 && resp.statusCode <= 302) {
            const newLocation = resp.headers.location;
            if (!newLocation) {
                reject({ message: `Redirect with no 'location' header for ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resolve(this.fetch(newLocation, headers));
            }
        }
        else if (resp.statusCode < 200 || resp.statusCode > 300) {
            reject({ message: `Bad status code for ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
        }
        else {
            const chunks = [];
            resp.on("data", (b) => chunks.push(b));
            resp.on("end", () => {
                const buffer = Buffer.concat(chunks);
                const encoding = resp.headers["content-encoding"];
                if (encoding === "gzip") {
                    zlib.gunzip(buffer, (err, decoded) => {
                        if (err)
                            reject(err);
                        else
                            resolve(decoded?.toString());
                    });
                }
                else {
                    resolve(buffer.toString());
                }
            });
        }
    }
    fetchHttp(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: {
                    ...headers,
                    "User-Agent": this.userAgent,
                },
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = http.request(options, (res) => this.handleResponse(headers, res, resolve, reject, path));
            req.end();
        });
    }
}
exports.WebClient = WebClient;


/***/ }),

/***/ 3960:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFutterWebRenderer = getFutterWebRenderer;
function getFutterWebRenderer(flutterCapabilities, renderer) {
    if (!flutterCapabilities.supportsWebRendererOption)
        return;
    if (!renderer || renderer === "flutter-default")
        return;
    return renderer;
}


/***/ }),

/***/ 5045:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RingLog = exports.nullLogger = exports.CategoryLogger = exports.EmittingLogger = void 0;
exports.logProcess = logProcess;
exports.logToConsole = logToConsole;
exports.captureLogs = captureLogs;
const events_1 = __webpack_require__(4434);
const fs = __importStar(__webpack_require__(9896));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
class LogEmitter extends events_1.EventEmitter {
    fire(msg) {
        this.emit("log", msg);
    }
    onLog(listener) {
        this.on("log", listener);
        return {
            dispose: () => { this.removeListener("log", listener); },
        };
    }
}
class EmittingLogger {
    onLogEmitter = new LogEmitter();
    onLog = (listener) => this.onLogEmitter.onLog(listener);
    log(message, severity, category = enums_1.LogCategory.General) {
        this.onLogEmitter.fire(new LogMessageImpl(message, severity, category));
    }
    info(message, category) {
        this.log(message, enums_1.LogSeverity.Info, category);
    }
    warn(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Warn, category);
    }
    error(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Error, category);
    }
    dispose() {
        this.onLogEmitter.removeAllListeners();
    }
}
exports.EmittingLogger = EmittingLogger;
class LogMessageImpl {
    message;
    severity;
    category;
    constructor(message, severity, category) {
        this.message = message;
        this.severity = severity;
        this.category = category;
    }
    toLine(maxLength) {
        const logMessage = (maxLength && this.message && this.message.length > maxLength
            ? this.message.substring(0, maxLength) + "…"
            : (this.message || "<empty message>")).trimRight();
        const time = `[${(new Date()).toLocaleTimeString()}]`;
        const prefix = `[${enums_1.LogCategory[this.category]}] [${enums_1.LogSeverity[this.severity]}]`;
        return `${time} ${prefix} ${logMessage}`;
    }
}
class CategoryLogger {
    base;
    defaultCategory;
    constructor(base, defaultCategory) {
        this.base = base;
        this.defaultCategory = defaultCategory;
    }
    info(message, category = this.defaultCategory) {
        this.base.info(message, category);
    }
    warn(errorOrMessage, category = this.defaultCategory) {
        this.base.warn(errorOrMessage, category);
    }
    error(errorOrMessage, category = this.defaultCategory) {
        this.base.error(errorOrMessage, category);
    }
}
exports.CategoryLogger = CategoryLogger;
class NullLogger {
    // tslint:disable-next-line: no-empty
    info(message, category) { }
    // tslint:disable-next-line: no-empty
    warn(message, category) { }
    // tslint:disable-next-line: no-empty
    error(error, category) { }
}
exports.nullLogger = new NullLogger();
function logProcess(logger, category, process) {
    const prefix = `(PROC ${process.pid})`;
    logger.info(`${prefix} Logging data for process...`, category);
    process.stdout.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.stderr.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.on("close", (code, signal) => logger.info(`${prefix} closed (${code}, ${signal})`, category));
    process.on("error", (e) => logger.info(`${prefix} errored (${e})`, category));
    process.on("exit", (code, signal) => logger.info(`${prefix} exited (${code}, ${signal})`, category));
}
function logToConsole(logger) {
    return logger.onLog((m) => {
        if (m.severity === enums_1.LogSeverity.Error)
            console.error(m.toLine(1000));
        else if (m.severity === enums_1.LogSeverity.Warn)
            console.warn(m.toLine(1000));
    });
}
function captureLogs(logger, file, header, maxLogLineLength, logCategories, excludeLogCategories = false) {
    if (!file || !path.isAbsolute(file))
        throw new Error("Path passed to logTo must be an absolute path");
    const time = (detailed = false) => detailed ? `[${(new Date()).toTimeString()}] ` : `[${(new Date()).toLocaleTimeString()}] `;
    (0, fs_1.createFolderForFile)(file);
    let logStream = fs.createWriteStream(file);
    if (header)
        logStream.write(header);
    const categoryNames = logCategories.map((c) => enums_1.LogCategory[c]);
    logStream.write(`${excludeLogCategories ? "Not " : ""}Logging Categories:${constants_1.platformEol}    ${categoryNames.join(", ")}${constants_1.platformEol}${constants_1.platformEol}`);
    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file started${constants_1.platformEol}`);
    let fileLogger = logger.onLog((e) => {
        if (!logStream)
            return;
        // We should log this event if:
        // - We don't have a category filter; or
        // - The category filter includes this category; or
        // - The log is WARN/ERROR (they get logged everywhere).
        const shouldLog = (excludeLogCategories
            ? !logCategories.includes(e.category)
            : logCategories.includes(e.category))
            || e.severity === enums_1.LogSeverity.Warn
            || e.severity === enums_1.LogSeverity.Error;
        if (!shouldLog)
            return;
        logStream.write(`${e.toLine(maxLogLineLength)}${os.EOL}`);
    });
    return {
        async dispose() {
            if (fileLogger) {
                await fileLogger.dispose();
                fileLogger = undefined;
            }
            return new Promise((resolve) => {
                if (logStream) {
                    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file ended${os.EOL}`);
                    logStream.once("finish", resolve);
                    logStream.end();
                    logStream = undefined;
                }
            });
        },
    };
}
class RingLog {
    size;
    lines;
    pointer = 0;
    get rawLines() { return this.lines; }
    constructor(size) {
        this.size = size;
        this.lines = new Array(this.size);
    }
    log(message) {
        this.lines[this.pointer] = message;
        this.pointer = (this.pointer + 1) % this.size;
    }
    toString() {
        return this.lines.slice(this.pointer, this.size).concat(this.lines.slice(0, this.pointer)).filter((l) => l).join("\n");
    }
}
exports.RingLog = RingLog;


/***/ }),

/***/ 4917:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunProcessResult = void 0;
exports.safeSpawn = safeSpawn;
exports.runProcess = runProcess;
exports.getPubExecutionInfo = getPubExecutionInfo;
const child_process = __importStar(__webpack_require__(5317));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const simpleCommandRegex = new RegExp("^[\\w\\-.]+$");
function safeSpawn(workingDirectory, binPath, args, env) {
    const customEnv = Object.assign({}, process.env, env);
    // On Windows we need to use shell-execute for running `.bat` files.
    // Try to limit when we use this, because terminating a shell might not terminate
    // the spawned process, so not using shell-execute may improve reliability of
    // terminating processes.
    if (constants_1.isWin && binPath.endsWith(".bat")) {
        const quotedArgs = args.map(quoteAndEscapeArg);
        // Putting quotes around something like "git" will cause it to fail, so don't do it if binPath is just a single identifier.
        binPath = simpleCommandRegex.test(binPath) ? binPath : `"${binPath}"`;
        return child_process.spawn(binPath, quotedArgs, { cwd: workingDirectory, env: customEnv, shell: true });
    }
    return child_process.spawn(binPath, args, { cwd: workingDirectory, env: customEnv });
}
function quoteAndEscapeArg(arg) {
    // Spawning processes on Windows with funny symbols in the path requires quoting. However if you quote an
    // executable with a space in its path and an argument also has a space, you have to then quote _all_ of the
    // arguments!
    // https://github.com/nodejs/node/issues/7367
    let escaped = arg.replace(/"/g, `\\"`).replace(/`/g, "\\`");
    // Additionally, on Windows escape redirection symbols with ^ if they come
    // directly after quotes (?).
    // https://ss64.com/nt/syntax-esc.html
    if (constants_1.isWin)
        escaped = escaped.replace(/"([<>])/g, "\"^$1");
    return `"${escaped}"`;
}
class RunProcessResult {
    exitCode;
    stdout;
    stderr;
    constructor(exitCode, stdout, stderr) {
        this.exitCode = exitCode;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.RunProcessResult = RunProcessResult;
function runProcess(logger, binPath, args, workingDirectory, env, spawn, cancellationToken) {
    return new Promise((resolve, reject) => {
        logger.info(`Spawning ${binPath} with args ${JSON.stringify(args)} in ${workingDirectory} with env ${JSON.stringify(env)}`);
        const proc = spawn(workingDirectory, binPath, args, env);
        cancellationToken?.onCancellationRequested(() => proc.kill());
        (0, logging_1.logProcess)(logger, enums_1.LogCategory.CommandProcesses, proc);
        const out = [];
        const err = [];
        proc.stdout.on("data", (data) => out.push(data.toString()));
        proc.stderr.on("data", (data) => err.push(data.toString()));
        proc.on("exit", (code) => {
            resolve(new RunProcessResult((0, utils_1.nullToUndefined)(code), out.join(""), err.join("")));
        });
        // Handle things like ENOENT which are async and come via error, but mean exit will never fire.
        proc.on("error", (e) => reject(e));
    });
}
function getPubExecutionInfo(dartCapabilities, dartSdkPath, args) {
    if (dartCapabilities.supportsDartPub) {
        return {
            args: ["pub", ...args],
            executable: path.join(dartSdkPath, constants_1.dartVMPath),
        };
    }
    else {
        return {
            args,
            executable: path.join(dartSdkPath, constants_1.pubPath),
        };
    }
}


/***/ }),

/***/ 4908:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubApi = void 0;
class PubApi {
    webClient;
    pubUrlBase;
    constructor(webClient) {
        this.webClient = webClient;
        this.pubUrlBase = process.env.PUB_HOSTED_URL || "https://pub.dev";
    }
    async getPackage(packageID) {
        return this.get(`packages/${packageID}`);
    }
    async getPackageNames() {
        return this.get(`package-name-completion-data`);
    }
    async get(url) {
        const headers = {
            "Accept": "application/vnd.pub.v2+json",
            "Accept-Encoding": "gzip",
        };
        const response = await this.webClient.fetch(`${this.pubUrlBase}/api/${url}`, headers);
        return JSON.parse(response);
    }
}
exports.PubApi = PubApi;


/***/ }),

/***/ 5308:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubDeps = void 0;
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
const processes_1 = __webpack_require__(4917);
const fs_1 = __webpack_require__(2587);
/// Interacts with "pub deps --json" to look up types of dependencies.
class PubDeps {
    logger;
    context;
    dartCapabilities;
    constructor(logger, context, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
    }
    buildTree(json, packageName) {
        const packages = {};
        const rootPackageNames = [];
        for (const p of json.packages) {
            packages[p.name] = p;
            // TODO(dantup): Right now we only find the root for the specific package name. For non-workspaces
            //  this is the only root. For Workspaces, this means we're running "pub deps" for each project
            //  in the workspace and discarding the results for the others. This could potentially be optimized,
            //  however since we expand the nodes lazily, there might not be much benefit.
            if (p.kind === "root" && p.name === packageName)
                rootPackageNames.push(p.name);
        }
        rootPackageNames.sort();
        return {
            roots: rootPackageNames.map((name) => packages[name]).filter((pkg) => pkg).map((pkg) => this._buildRoot(pkg, packages)),
        };
    }
    _buildRoot(pkg, packages) {
        // If a node has a "directDependencies" node then we've got the new format
        // (see https://github.com/dart-lang/pub/pull/4383).
        //
        // For the new format, we use:
        //   directDependencies: `pkg.directDependencies`
        //   devDependencies: `pkg.devDependencies`
        //   transitiveDependencies: walk down `pkg.dependencies` collecting from child `dependencies` where not already seen
        //
        // Otherwise, we use:
        //   directDependencies: `pkg.dependencies.filter((dep) => dep?.kind === "direct")`
        //   devDependencies: `pkg.devDependencies.filter((dep) => dep?.kind === "dev")`
        //   transitiveDependencies: walk down `pkg.dependencies` collecting from child `dependencies` where not already seen
        const isNewFormat = !!pkg.directDependencies;
        const allDependencies = pkg.dependencies?.map((name) => packages[name]).filter((pkg) => pkg) ?? [];
        const directDependencies = isNewFormat
            ? pkg.directDependencies?.map((name) => packages[name]).filter((pkg) => pkg) ?? []
            : allDependencies.filter((dep) => dep?.kind === "direct");
        const devDependencies = isNewFormat
            ? pkg.devDependencies?.map((name) => packages[name]).filter((pkg) => pkg) ?? []
            : allDependencies.filter((dep) => dep?.kind === "dev");
        directDependencies.sort((d1, d2) => d1.name.localeCompare(d2.name));
        devDependencies.sort((d1, d2) => d1.name.localeCompare(d2.name));
        return {
            dependencies: directDependencies.map((pkg) => this._buildDependency(pkg)),
            devDependencies: devDependencies.map((pkg) => this._buildDependency(pkg)),
            name: pkg.name,
            transitiveDependencies: this._buildTransitiveDependencies(pkg, packages),
            version: pkg.version,
        };
    }
    _buildDependency(pkg) {
        return {
            name: pkg.name,
            version: pkg.version,
        };
    }
    _buildTransitiveDependencies(pkg, packages) {
        const pkgDependencies = [...(pkg.dependencies ?? []), ...(pkg.devDependencies ?? [])].map((name) => packages[name]).filter((pkg) => pkg);
        const results = {};
        // Queue is a list of pairs of packages to process, and the first (shortest) paths to get to them.
        const queue = [];
        for (const dependency of pkgDependencies) {
            queue.push([dependency.name, {
                    name: dependency.name,
                    shortestPath: [dependency.name],
                    version: dependency.version,
                }]);
        }
        // Traverse the tree breadth-first, so that the first time we come across any node, we know that is
        // the shortest path.
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < queue.length; i++) {
            const [pkgName, transitiveDependency] = queue[i];
            // Loop over this packages dependencies, and if we've not previously been to them
            // this is (one of) the shortest paths there.
            const dependencies = (packages[pkgName]?.dependencies ?? []).map((name) => packages[name]).filter((pkg) => pkg); // We don't have dev deps for non-roots.
            for (const dependency of dependencies) {
                if (results[dependency.name])
                    continue;
                const newTransitiveDependency = {
                    name: dependency.name,
                    shortestPath: [...transitiveDependency.shortestPath, dependency.name],
                    version: dependency.version,
                };
                results[dependency.name] = newTransitiveDependency;
                // Also push the dependency onto the queue to process its dependencies.
                queue.push([dependency.name, newTransitiveDependency]);
            }
        }
        const resultDependencies = Object.values(results);
        resultDependencies.sort((d1, d2) => d1.name.localeCompare(d2.name));
        return resultDependencies;
    }
    async getTree(projectDirectory) {
        const packageName = (0, fs_1.tryGetPackageName)(projectDirectory) ?? path.basename(projectDirectory);
        const json = await this.getJson(projectDirectory);
        return json ? this.buildTree(json, packageName) : undefined;
    }
    async getJson(projectDirectory) {
        if (!this.dartCapabilities.supportsPubDepsJson || this.context.config.disableAutomaticPub) {
            return undefined;
        }
        const sdks = this.context.sdks;
        const binPath = (0, fs_1.isFlutterProjectFolder)(projectDirectory) && sdks.flutter
            ? path.join(sdks.flutter, constants_1.flutterPath)
            : path.join(sdks.dart, constants_1.dartVMPath);
        const result = await (0, processes_1.runProcess)(this.logger, binPath, ["pub", "deps", "--json"], projectDirectory, undefined, processes_1.safeSpawn);
        if (result.exitCode !== 0) {
            this.logger.error(`Running "pub deps --json" returned exit code ${result.exitCode}:\n${result.stdout}\n${result.stderr}`);
            return undefined;
        }
        let json = result.stdout;
        try {
            // If this is the first run of Flutter, it might output a banner ("Welcome to Flutter"). We can't use the
            // usual JSON-parsing here, because it's not all on one line, so just trim anything before the first `{` which
            // handle any additional output (as long as it doesn't include a brace itself).
            let bracePosition;
            if (!json.startsWith("{") && (bracePosition = json.indexOf("{")) !== -1) {
                json = json.substring(bracePosition);
            }
            return JSON.parse(json);
        }
        catch (e) {
            this.logger.error(`"pub deps --json" returned invalid JSON ${e}:\n${json}`);
            return undefined;
        }
    }
}
exports.PubDeps = PubDeps;


/***/ }),

/***/ 1721:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MissingPackageMap = exports.PackageMap = exports.PackageMapLoader = void 0;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const url = __importStar(__webpack_require__(7016));
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
class PackageMapLoader {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    loadForProject(projectFolder) {
        return PackageMap.loadForProject(this.logger, projectFolder);
    }
}
exports.PackageMapLoader = PackageMapLoader;
class PackageMap {
    static findPackagesFile(entryPoint) {
        if (!entryPoint)
            return undefined;
        const file = (0, utils_1.findFileInAncestor)([path.join(".dart_tool/package_config.json"), ".packages"], entryPoint);
        return file;
    }
    static loadForProject(logger, projectFolder) {
        const packagesFile = PackageMap.findPackagesFile(projectFolder);
        return packagesFile
            ? this.load(logger, packagesFile)
            : new MissingPackageMap();
    }
    static load(logger, file) {
        if (!file)
            return new MissingPackageMap();
        try {
            if (path.basename(file).toLowerCase() === ".packages")
                return new DotPackagesPackageMap(file);
            else
                return new PackageConfigJsonPackageMap(logger, file);
        }
        catch (e) {
            logger.error(e);
            return new MissingPackageMap();
        }
    }
    getPackagePath(name) {
        return this.packages[name];
    }
    resolvePackageUri(uri) {
        if (!uri)
            return undefined;
        let name = uri;
        if (name.startsWith("package:"))
            name = name.substring(8);
        const index = name.indexOf("/");
        if (index === -1)
            return undefined;
        const rest = name.substring(index + 1);
        name = name.substring(0, index);
        const location = this.getPackagePath(name);
        if (location)
            return path.join(location, rest);
        else
            return undefined;
    }
}
exports.PackageMap = PackageMap;
class MissingPackageMap extends PackageMap {
    get packages() {
        return {};
    }
    getPackagePath(name) {
        return undefined;
    }
    resolvePackageUri(uri) {
        return undefined;
    }
    reload() { }
}
exports.MissingPackageMap = MissingPackageMap;
class DotPackagesPackageMap extends PackageMap {
    map = {};
    file;
    localPackageRoot;
    get packages() { return Object.assign({}, this.map); }
    constructor(file) {
        super();
        if (!file)
            return;
        this.file = file;
        this.localPackageRoot = path.dirname(file);
        this.load();
    }
    reload() {
        this.load();
    }
    load() {
        if (!this.file || !this.localPackageRoot)
            return;
        this.map = {};
        const lines = fs.readFileSync(this.file, { encoding: "utf8" }).split("\n");
        for (let line of lines) {
            line = line.trim();
            if (line.length === 0 || line.startsWith("#"))
                continue;
            const index = line.indexOf(":");
            if (index !== -1) {
                const name = line.substr(0, index);
                const rest = line.substring(index + 1);
                if (rest.startsWith("file:"))
                    this.map[name] = (0, utils_1.uriToFilePath)(rest);
                else
                    this.map[name] = path.join(this.localPackageRoot, rest);
            }
        }
    }
}
class PackageConfigJsonPackageMap extends PackageMap {
    logger;
    packageConfigPath;
    map = {};
    config;
    constructor(logger, packageConfigPath) {
        super();
        this.logger = logger;
        this.packageConfigPath = packageConfigPath;
        this.load();
    }
    reload() {
        this.load();
    }
    load() {
        const json = fs.readFileSync(this.packageConfigPath, "utf8");
        this.config = JSON.parse(json);
        this.map = {};
        for (const pkg of this.config.packages) {
            try {
                const packageConfigFolderPath = path.dirname(this.packageConfigPath);
                const packageRootPath = this.getPathForUri(pkg.rootUri);
                const packageLibPath = this.getPathForUri(pkg.packageUri);
                this.map[pkg.name] = path.resolve(packageConfigFolderPath, packageRootPath ?? "", packageLibPath ?? "");
            }
            catch (e) {
                this.logger.error(`Failed to resolve path for package ${pkg.name}: ${e}`);
            }
        }
    }
    getPathForUri(uri) {
        if (!uri)
            return undefined;
        const parsedPath = (0, fs_1.normalizeSlashes)(uri.startsWith("file:")
            ? url.fileURLToPath(uri)
            : unescape(uri));
        return parsedPath.endsWith(path.sep) ? parsedPath : `${parsedPath}${path.sep}`;
    }
    get packages() { return Object.assign({}, this.map); }
    getPackagePath(name) {
        return this.map[name];
    }
}


/***/ }),

/***/ 703:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCacheData = void 0;
class PackageCacheData {
    lastUpdated;
    packages;
    static cacheVersion = 1;
    static maxCacheAgeHours = 18;
    static get maxCacheAgeMs() { return PackageCacheData.maxCacheAgeHours * 60 * 60 * 1000; }
    static maxPackageDetailsRequestsInFlight = 5;
    constructor(lastUpdated, packages) {
        this.lastUpdated = lastUpdated;
        this.packages = packages;
    }
    static fromPackageNames(packages) {
        const packageMap = new Map();
        packages.forEach((p) => packageMap.set(p, undefined));
        return new PackageCacheData(new Date().getTime(), packageMap);
    }
    get packageNames() {
        // TODO: Can we avoid this and just iterate in the callee, since we often
        // bail out early?
        return Array.from(this.packages.keys());
    }
    get cacheTimeRemainingMs() {
        const ageMs = new Date().getTime() - this.lastUpdated;
        const timeRemainingMs = PackageCacheData.maxCacheAgeMs - ageMs;
        return timeRemainingMs < 0
            ? 0
            : timeRemainingMs;
    }
    static fromJson(json) {
        const data = JSON.parse(json, PackageCacheData.mapReviver);
        if (data.version !== PackageCacheData.cacheVersion)
            return undefined;
        return new PackageCacheData(data.lastUpdated, data.packages);
    }
    toJson() {
        return JSON.stringify({
            lastUpdated: this.lastUpdated,
            packages: this.packages,
            version: PackageCacheData.cacheVersion,
        }, PackageCacheData.mapReplacer, 2);
    }
    static mapReplacer(key, value) {
        return value instanceof Map
            ? {
                dataType: "Map",
                value: [...value],
            }
            : value;
    }
    static mapReviver(key, value) {
        return typeof value === "object" && value?.dataType === "Map"
            ? new Map(value.value) // eslint-disable-line @typescript-eslint/no-unsafe-argument
            : value;
    }
}
exports.PackageCacheData = PackageCacheData;


/***/ }),

/***/ 7385:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanPubOutput = cleanPubOutput;
function cleanPubOutput(pubOutput) {
    // Sometimes pub will output additional text that we need to discard:
    // Precompiling executable...\nPrecompiled test:test.\n[{"name":"console-full","label"
    const precompilingHeaderPattern = RegExp("^Precompil(?:ing|ed).*$", "gm");
    const json = pubOutput.replace(precompilingHeaderPattern, "");
    return json;
}


/***/ }),

/***/ 7724:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StdIOService = void 0;
const fs = __importStar(__webpack_require__(9896));
const processes_1 = __webpack_require__(4917);
// Reminder: This class is used in the debug adapter as well as the main Code process!
class StdIOService {
    logger;
    maxLogLineLength;
    messagesWrappedInBrackets;
    treatHandlingErrorsAsUnhandledMessages;
    treatCarriageReturnsAsNewlines;
    logFile;
    disposables = [];
    process;
    additionalPidsToTerminate = [];
    nextRequestID = 1;
    activeRequests = {};
    messageBuffers = [];
    openLogFile;
    logStream;
    requestErrorSubscriptions = [];
    processExited = false;
    description;
    constructor(logger, maxLogLineLength, messagesWrappedInBrackets = false, treatHandlingErrorsAsUnhandledMessages = false, treatCarriageReturnsAsNewlines = false, logFile) {
        this.logger = logger;
        this.maxLogLineLength = maxLogLineLength;
        this.messagesWrappedInBrackets = messagesWrappedInBrackets;
        this.treatHandlingErrorsAsUnhandledMessages = treatHandlingErrorsAsUnhandledMessages;
        this.treatCarriageReturnsAsNewlines = treatCarriageReturnsAsNewlines;
        this.logFile = logFile;
    }
    createProcess(workingDirectory, binPath, args, envOverrides) {
        this.logTraffic(`Spawning ${binPath} with args ${JSON.stringify(args)}`);
        this.description = binPath;
        if (workingDirectory)
            this.logTraffic(`..  in ${workingDirectory}`);
        if (envOverrides.envOverrides || envOverrides.toolEnv)
            this.logTraffic(`..  with ${JSON.stringify(envOverrides)}`);
        const env = Object.assign({}, envOverrides.toolEnv, envOverrides.envOverrides);
        this.process = (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
        this.logTraffic(`    PID: ${process.pid}`);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => this.handleError(error));
    }
    /// Flutter may send only \r as a line terminator for improved terminal output
    /// but we should always treat this as a standard newline (eg. terminating a message)
    /// so all \r's can be replaced with \n immediately. Blank lines (from \n\n)
    /// are already handled gracefully.
    ///
    /// https://github.com/flutter/flutter/pull/57590
    normalizeNewlines(data) {
        const normalised = this.treatCarriageReturnsAsNewlines
            ? Buffer.from(data.toString().replace(/\r/g, "\n"))
            : data;
        return Buffer.from(normalised);
    }
    handleStdOut(data) {
        data = this.normalizeNewlines(data);
        // Add this message to the buffer for processing.
        this.messageBuffers.push(data);
        // Kick off processing if we have a full message.
        if (data.indexOf("\n") >= 0)
            this.processMessageBuffer();
    }
    handleStdErr(data) {
        this.logTraffic(`${data.toString()}`, true);
    }
    handleExit(code, signal) {
        this.logTraffic(`Process ${this.description} terminated! ${code}, ${signal}`);
        this.processExited = true;
    }
    handleError(error) {
        this.logTraffic(`Process errored! ${error}`);
    }
    buildRequest(id, method, params) {
        return {
            id: id.toString(),
            method,
            params,
        };
    }
    notifyRequestAfterExit() { }
    sendRequest(method, params) {
        // Generate an ID for this request so we can match up the response.
        const id = this.nextRequestID++;
        return new Promise((resolve, reject) => {
            if (this.processExited) {
                this.notifyRequestAfterExit();
                reject(`Tried to call "${method}" but process has already exited with code ${this.process?.exitCode}`);
                return;
            }
            // Stash the callbacks so we can call them later.
            this.activeRequests[id.toString()] = [resolve, reject, method];
            const req = this.buildRequest(id, method, params);
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(req) + "]\r\n"
                : JSON.stringify(req) + "\r\n";
            this.sendMessage(json);
        });
    }
    cancelAllRequests() {
        Object.keys(this.activeRequests).forEach((key) => this.activeRequests[key] = "CANCELLED");
    }
    sendMessage(json) {
        this.logTraffic(`==> ${json}`);
        if (this.process)
            this.process.stdin.write(json);
        else
            this.logTraffic(`  (not sent: no process)`);
    }
    processMessageBuffer() {
        let fullBuffer = Buffer.concat(this.messageBuffers);
        this.messageBuffers = [];
        // If the message doesn't end with \n then put the last part back into the buffer.
        const lastNewline = fullBuffer.lastIndexOf("\n");
        if (lastNewline !== fullBuffer.length - 1) {
            const incompleteMessage = fullBuffer.slice(lastNewline + 1);
            fullBuffer = fullBuffer.slice(0, lastNewline);
            this.messageBuffers.push(incompleteMessage);
        }
        // Process the complete messages in the buffer.
        fullBuffer.toString().split("\n").filter((m) => m.trim() !== "").forEach((m) => this.handleMessage(`${m}\n`));
    }
    // tslint:disable-next-line:no-empty
    async processUnhandledMessage(message) { }
    async handleMessage(message) {
        this.logTraffic(`<== ${message.trimRight()}\r\n`);
        if (!this.shouldHandleMessage(message.trim())) {
            return this.processUnhandledMessage(message);
        }
        let msg;
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            msg = JSON.parse(message);
            if (this.messagesWrappedInBrackets && msg && msg.length === 1)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                msg = msg[0];
        }
        catch (e) {
            if (this.treatHandlingErrorsAsUnhandledMessages) {
                this.logger.error(`Unexpected non-JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                return this.processUnhandledMessage(message);
            }
            else {
                throw e;
            }
        }
        try {
            if (msg && this.isNotification(msg))
                void this.handleNotification(msg).catch((e) => this.logger.error(e));
            else if (msg && this.isRequest(msg))
                this.processServerRequest(msg).catch((e) => this.logger.error(e));
            else if (msg && this.isResponse(msg))
                this.handleResponse(msg).catch((e) => this.logger.error(e));
            else {
                this.logger.error(`Unexpected JSON message, assuming normal stdout : ${message}`);
                this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
            }
        }
        catch (e) {
            if (this.treatHandlingErrorsAsUnhandledMessages) {
                this.logger.error(`Failed to handle JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
            }
            else {
                throw e;
            }
        }
    }
    // tslint:disable-next-line: no-empty
    async handleRequest(method, args) { }
    isNotification(msg) { return !!msg.event; }
    isRequest(msg) { return !!msg.method && !!msg.id; }
    isResponse(msg) { return !!msg.id; }
    async processServerRequest(request) {
        let result;
        let error;
        try {
            result = await this.handleRequest(request.method, request.params);
        }
        catch (e) {
            error = e;
        }
        const resp = { id: request.id, result, error };
        const json = this.messagesWrappedInBrackets
            ? "[" + JSON.stringify(resp) + "]\r\n"
            : JSON.stringify(resp) + "\r\n";
        this.sendMessage(json);
    }
    async handleResponse(evt) {
        const handler = this.activeRequests[evt.id];
        delete this.activeRequests[evt.id];
        if (handler === "CANCELLED") {
            this.logger.info(`Ignoring response to ${evt.id} because it was cancelled:\n\n${JSON.stringify(evt, undefined, 4)}`);
            return;
        }
        else if (!handler) {
            this.logger.error(`Unable to handle response with ID ${evt.id} because its handler is not available`);
            return;
        }
        const method = handler[2];
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const error = evt.error;
        if (error && error.code === "SERVER_ERROR") {
            error.method = method;
            this.notify(this.requestErrorSubscriptions, error).catch((e) => this.logger.error(e));
        }
        if (error) {
            await handler[1](error);
        }
        else {
            await handler[0](evt.result);
        }
    }
    notify(subscriptions, notification) {
        return Promise.all(subscriptions.slice().map((sub) => sub(notification))).catch((e) => console.error(e));
    }
    subscribe(subscriptions, subscriber) {
        subscriptions.push(subscriber);
        const disposable = {
            dispose: () => {
                // Remove from the subscription list.
                let index = subscriptions.indexOf(subscriber);
                if (index >= 0) {
                    subscriptions.splice(index, 1);
                }
                // Also remove from our disposables (else we'll leak it).
                index = this.disposables.indexOf(disposable);
                if (index >= 0) {
                    this.disposables.splice(index, 1);
                }
            },
        };
        this.disposables.push(disposable);
        return disposable;
    }
    registerForRequestError(subscriber) {
        return this.subscribe(this.requestErrorSubscriptions, subscriber);
    }
    logTraffic(message, isError = false) {
        if (isError)
            this.logger.error(message);
        else
            this.logger.info(message);
        if (this.openLogFile !== this.logFile && this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
        if (!this.logFile)
            return;
        if (!this.logStream) {
            this.logStream = fs.createWriteStream(this.logFile);
            this.openLogFile = this.logFile;
        }
        this.logStream.write(`[${(new Date()).toLocaleTimeString()}]: `);
        if (this.maxLogLineLength && message.length > this.maxLogLineLength)
            this.logStream.write(message.substring(0, this.maxLogLineLength) + "…\r\n");
        else
            this.logStream.write(message.trim() + "\r\n");
    }
    dispose() {
        this.logTraffic(`Process ${this.description} is being disposed`);
        for (const pid of this.additionalPidsToTerminate) {
            try {
                this.logTraffic(`Process ${this.description} is terminating process ${pid}`);
                process.kill(pid);
            }
            catch (e) {
                // TODO: Logger knows the category!
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                this.logger.error({ message: e.toString() });
            }
        }
        this.additionalPidsToTerminate.length = 0;
        try {
            if (!this.processExited && this.process && !this.process.killed) {
                this.logTraffic(`Process ${this.description} is terminating the main process`);
                this.process.kill();
            }
            else {
                if (this.processExited) {
                    this.logTraffic(`Process ${this.description} skipped terminating because it had already exited`);
                }
                else if (!this.process) {
                    this.logTraffic(`Process ${this.description} skipped terminating because there is no process`);
                }
                else if (this.process?.killed) {
                    this.logTraffic(`Process ${this.description} skipped terminating because it was already killed`);
                }
                else {
                    this.logTraffic(`Process ${this.description} skipped terminating because 🤷‍♂️`);
                }
            }
        }
        catch (e) {
            // This tends to throw a lot because the shell process quit when we terminated the related
            // process above, so just swallow the error.
        }
        this.process = undefined;
        this.disposables.forEach(async (d) => {
            try {
                return await d.dispose();
            }
            catch (e) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                this.logger.error({ message: e.toString() });
            }
        });
        this.disposables.length = 0;
        // Clear log file so if any more log events come through later, we don't
        // create a new log file and overwrite what we had.
        this.logFile = undefined;
        if (this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
    }
}
exports.StdIOService = StdIOService;


/***/ }),

/***/ 6517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartToolingDaemon = void 0;
/* eslint-disable @typescript-eslint/unified-signatures */
const path = __importStar(__webpack_require__(6928));
const ws = __importStar(__webpack_require__(7699));
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const events_1 = __webpack_require__(9495);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const stdio_service_1 = __webpack_require__(7724);
const tooling_daemon_services_1 = __webpack_require__(5845);
class DartToolingDaemon {
    promptToReloadExtension;
    disposables = [];
    logger;
    dtdProcess;
    connection;
    nextId = 1;
    completers = {};
    serviceHandlers = {};
    hasShownTerminatedError = false;
    isShuttingDown = false;
    connectedCompleter = new utils_1.PromiseCompleter();
    get connected() { return this.connectedCompleter.promise; }
    notificationsEmitters = {};
    constructor(logger, sdks, maxLogLineLength, getToolEnv, promptToReloadExtension) {
        this.promptToReloadExtension = promptToReloadExtension;
        this.logger = new logging_1.CategoryLogger(logger, enums_1.LogCategory.DartToolingDaemon);
        this.dtdProcess = new DartToolingDaemonProcess(this.logger, sdks, maxLogLineLength, getToolEnv);
        this.disposables.push(this.dtdProcess);
        void this.dtdProcess.dtdUri.then(() => this.connect());
        void this.dtdProcess.processExit.then(() => this.handleClose());
    }
    get dtdUri() {
        return this.dtdProcess.dtdUri;
    }
    async connect() {
        const dtdUri = await this.dtdProcess.dtdUri;
        if (!dtdUri)
            return;
        const dtdSecret = await this.dtdProcess.dtdSecret;
        this.logger.info(`Connecting to DTD at ${dtdUri}...`);
        const socket = new ws.WebSocket(dtdUri, { followRedirects: true });
        socket.on("open", () => this.handleOpen());
        socket.on("message", (data) => this.handleData(data.toString()));
        socket.on("close", () => this.handleClose());
        socket.on("error", (e) => this.handleError(e));
        this.connection = { socket, dtdUri, dtdSecret };
    }
    handleOpen() {
        this.logger.info(`Connected to DTD`);
        this.connectedCompleter.resolve(this.connection);
    }
    async sendWorkspaceFolders(workspaceFolderUris) {
        const connection = await this.connected;
        if (connection) {
            const secret = connection.dtdSecret;
            await this.callMethod(tooling_daemon_services_1.ServiceMethod.setIDEWorkspaceRoots, { secret, roots: workspaceFolderUris });
        }
    }
    async sendActiveLocation(activeLocation) {
        const connection = await this.connected;
        if (connection)
            this.sendEvent(tooling_daemon_services_1.Stream.Editor, activeLocation);
    }
    async handleData(data) {
        this.logTraffic(`<== ${data}\n`);
        const json = JSON.parse(data);
        const id = json.id;
        const method = json.method;
        if (method === "streamNotify") {
            const notification = json;
            this.notificationsEmitters[notification.params?.streamId]?.fire(notification.params.eventKind, notification.params.eventData);
        }
        else if (id !== undefined && method) {
            const request = json;
            // Handle service request.
            const serviceHandler = this.serviceHandlers[method];
            if (serviceHandler) {
                const result = await serviceHandler(request.params);
                await this.send({
                    id,
                    jsonrpc: "2.0",
                    result,
                });
            }
        }
        else if (id) {
            // Handle response.
            const completer = this.completers[id];
            const response = json;
            if (completer) {
                delete this.completers[id];
                if ("error" in response)
                    completer.reject(response.error);
                else
                    completer.resolve(response.result);
            }
        }
    }
    onNotification(stream, eventKind, listener, thisArgs) {
        if (!this.notificationsEmitters[stream])
            this.notificationsEmitters[stream] = new events_1.EventsEmitter();
        return this.notificationsEmitters[stream].listen(eventKind, listener, thisArgs);
    }
    onServiceRegistered(listener, thisArgs) {
        return this.onNotification("Service", "ServiceRegistered", (e) => listener(e), thisArgs);
    }
    onServiceUnregistered(listener, thisArgs) {
        return this.onNotification("Service", "ServiceUnregistered", (e) => listener(e), thisArgs);
    }
    async registerService(service, method, capabilities, f) {
        const serviceName = tooling_daemon_services_1.Service[service];
        const resp = await this.callMethod(tooling_daemon_services_1.ServiceMethod.registerService, { service: serviceName, method, capabilities });
        if (resp.type !== "Success") {
            throw new Error(`Failed to register service ${serviceName}.${method}: ${resp.type}`);
        }
        this.serviceHandlers[`${serviceName}.${method}`] = f;
    }
    async callMethod(method, params) {
        if (!this.connection)
            return Promise.reject("DTD connection is unavailable");
        const id = `${this.nextId++}`;
        const completer = new utils_1.PromiseCompleter();
        this.completers[id] = completer;
        await this.send({
            id,
            jsonrpc: "2.0",
            method,
            params,
        });
        return completer.promise;
    }
    async streamListen(streamId) {
        return this.callMethod(tooling_daemon_services_1.ServiceMethod.streamListen, { streamId });
    }
    async streamCancel(streamId) {
        return this.callMethod(tooling_daemon_services_1.ServiceMethod.streamCancel, { streamId });
    }
    sendEvent(stream, params) {
        if (!this.connection)
            throw Error("DTD connection is unavailable");
        void this.send({
            jsonrpc: "2.0",
            method: "postEvent",
            params: {
                eventData: { ...params, kind: undefined },
                eventKind: tooling_daemon_services_1.EventKind[params.kind],
                streamId: tooling_daemon_services_1.Stream[stream],
            },
        });
    }
    send(json) {
        if (!this.connection)
            return Promise.reject("DTD connection is unavailable");
        const str = JSON.stringify(json);
        this.logTraffic(`==> ${str}\n`);
        this.connection.socket.send(str);
    }
    handleClose() {
        this.logger.info(`DTD connection closed`);
        if (!this.isShuttingDown && !this.hasShownTerminatedError) {
            const which = this.dtdProcess.hasTerminated ? "process" : "connection";
            this.showTerminatedError(which, this.dtdProcess.hasReceivedConnectionInfo ? "has terminated" : "failed to start");
        }
        this.dispose();
    }
    handleError(e) {
        this.logger.error(`${e}`);
    }
    logTraffic(message) {
        this.logger.info(message);
    }
    lastShownTerminatedError;
    noRepeatTerminatedErrorThresholdMs = constants_1.tenMinutesInMs;
    showTerminatedError(which, message) {
        // Don't show this notification if we've shown it recently.
        if (this.lastShownTerminatedError && Date.now() - this.lastShownTerminatedError < this.noRepeatTerminatedErrorThresholdMs)
            return;
        this.lastShownTerminatedError = Date.now();
        // This flag is set here, but checked in handleUncleanExit because explicit calls
        // here can override hasShownTerminationError, for example to show the error when
        // something tries to interact with the API (`notifyRequestAfterExit`).
        this.hasShownTerminatedError = true;
        void this.promptToReloadExtension(`The Dart Tooling Daemon ${which} ${message}.`, undefined, true);
    }
    dispose() {
        this.isShuttingDown = true;
        try {
            this.connection?.socket?.close();
            this.connection = undefined;
        }
        catch { }
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartToolingDaemon = DartToolingDaemon;
class DartToolingDaemonProcess extends stdio_service_1.StdIOService {
    sdks;
    hasReceivedConnectionInfo = false;
    dtdUriCompleter = new utils_1.PromiseCompleter();
    dtdSecretCompleter = new utils_1.PromiseCompleter();
    processExitCompleter = new utils_1.PromiseCompleter();
    hasTerminated = false;
    get dtdUri() {
        return this.dtdUriCompleter.promise;
    }
    get dtdSecret() {
        return this.dtdSecretCompleter.promise;
    }
    get processExit() {
        return this.processExitCompleter.promise;
    }
    constructor(logger, sdks, maxLogLineLength, getToolEnv) {
        super(logger, maxLogLineLength, true, true);
        this.sdks = sdks;
        const executable = path.join(this.sdks.dart, constants_1.dartVMPath);
        const daemonArgs = [
            "tooling-daemon",
            "--machine",
        ];
        this.createProcess(undefined, executable, daemonArgs, { toolEnv: getToolEnv() });
    }
    handleExit(code, signal) {
        this.hasTerminated = true;
        super.handleExit(code, signal);
        this.processExitCompleter.resolve();
        this.dtdUriCompleter.resolve(undefined);
    }
    shouldHandleMessage(_message) {
        // DTD only emits one thing we care about but it's not in the same format
        // as our other things, so we treat every message as unhandled and extract
        // the info in processUnhandledMessage.
        return false;
    }
    async handleNotification(_evt) {
        // We never get here because shouldHandleMessage is always false.
    }
    async processUnhandledMessage(message) {
        message = message.trim();
        if (!this.hasReceivedConnectionInfo && message.startsWith("{") && message.endsWith("}")) {
            try {
                const json = JSON.parse(message);
                if (json?.tooling_daemon_details?.uri && json?.tooling_daemon_details?.trusted_client_secret) {
                    this.dtdUriCompleter.resolve(json?.tooling_daemon_details?.uri);
                    this.dtdSecretCompleter.resolve(json?.tooling_daemon_details?.trusted_client_secret);
                    this.hasReceivedConnectionInfo = true;
                }
            }
            catch { }
        }
    }
}


/***/ }),

/***/ 5845:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventKind = exports.ServiceMethod = exports.Stream = exports.Service = void 0;
var Service;
(function (Service) {
    Service[Service["Editor"] = 0] = "Editor";
})(Service || (exports.Service = Service = {}));
var Stream;
(function (Stream) {
    Stream[Stream["Editor"] = 0] = "Editor";
    Stream[Stream["Service"] = 1] = "Service";
    Stream[Stream["Lsp"] = 2] = "Lsp";
})(Stream || (exports.Stream = Stream = {}));
var ServiceMethod;
(function (ServiceMethod) {
    ServiceMethod["registerService"] = "registerService";
    ServiceMethod["setIDEWorkspaceRoots"] = "FileSystem.setIDEWorkspaceRoots";
    ServiceMethod["getIDEWorkspaceRoots"] = "FileSystem.getIDEWorkspaceRoots";
    ServiceMethod["readFileAsString"] = "FileSystem.readFileAsString";
    ServiceMethod["streamListen"] = "streamListen";
    ServiceMethod["streamCancel"] = "streamCancel";
})(ServiceMethod || (exports.ServiceMethod = ServiceMethod = {}));
var EventKind;
(function (EventKind) {
    EventKind[EventKind["activeLocationChanged"] = 0] = "activeLocationChanged";
    EventKind[EventKind["deviceAdded"] = 1] = "deviceAdded";
    EventKind[EventKind["deviceRemoved"] = 2] = "deviceRemoved";
    EventKind[EventKind["deviceChanged"] = 3] = "deviceChanged";
    EventKind[EventKind["deviceSelected"] = 4] = "deviceSelected";
    EventKind[EventKind["debugSessionStarted"] = 5] = "debugSessionStarted";
    EventKind[EventKind["debugSessionChanged"] = 6] = "debugSessionChanged";
    EventKind[EventKind["debugSessionStopped"] = 7] = "debugSessionStopped";
})(EventKind || (exports.EventKind = EventKind = {}));


/***/ }),

/***/ 2905:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internalApiSymbol = void 0;
// TODO: Can we make this work better when webpack'd?
exports.internalApiSymbol = "_privateApi"; // Symbol();


/***/ }),

/***/ 5879:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSessionCoordinator = void 0;
const vscode_uri_1 = __webpack_require__(8945);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const outline_lsp_1 = __webpack_require__(3248);
const test_1 = __webpack_require__(672);
const test_model_1 = __webpack_require__(5871);
/// Handles results from a test debug session and provides them to the test model.
class TestSessionCoordinator {
    logger;
    data;
    fileTracker;
    disposables = [];
    /// A link between a suite path and the debug session ID that owns it, so we can ensure
    /// it is correctly ended when the debug session ends, even if we don't get the correct
    /// end events.
    owningDebugSessions = {};
    /// For a given debug session, lookups by IDs to get back to the suite.
    debugSessionLookups = {};
    /// A link between a suite path and a visitor for visiting its latest outline data.
    /// This data is refreshed when a test suite starts running.
    suiteOutlineVisitors = {};
    /// For each debug session ID, stores a mapping of phantom (empty) groups and their parent IDs so we can
    /// jump over them.
    phantomGroupParents = {};
    constructor(logger, data, fileTracker) {
        this.logger = logger;
        this.data = data;
        this.fileTracker = fileTracker;
    }
    handleDebugSessionCustomEvent(debugSessionID, dartCodeDebugSessionID, event, body) {
        if (event === "dart.testNotification") {
            void this.handleNotification(debugSessionID, dartCodeDebugSessionID ?? `untagged-session-${debugSessionID}`, body).catch((e) => this.logger.error(e));
        }
    }
    handleDebugSessionEnd(debugSessionID, dartCodeDebugSessionID) {
        // Get the suite paths that have us as the owning debug session.
        const suitePaths = Object.keys(this.owningDebugSessions).filter((suitePath) => {
            const owningSessionID = this.owningDebugSessions[suitePath];
            return owningSessionID === debugSessionID;
        });
        // End them all and remove from the lookup.
        for (const suitePath of suitePaths) {
            this.handleSuiteEnd(dartCodeDebugSessionID, this.data.suites.getForPath(suitePath));
            this.owningDebugSessions[suitePath] = undefined;
            delete this.owningDebugSessions[suitePath];
        }
    }
    async handleNotification(debugSessionID, dartCodeDebugSessionID, evt) {
        switch (evt.type) {
            // We won't get notifications that aren't directly tied to Suites because
            // of how the DA works.
            // case "start":
            // 	this.handleStartNotification(evt as StartNotification);
            // 	break;
            // We won't get notifications that aren't directly tied to Suites because
            // of how the DA works.
            // case "allSuites":
            // 	this.handleAllSuitesNotification(evt as AllSuitesNotification);
            // 	break;
            case "suite":
                const event = evt;
                // HACK: Handle paths with wrong slashes.
                // https://github.com/Dart-Code/Dart-Code/issues/4441
                if (constants_1.isWin)
                    event.suite.path = (0, fs_1.normalizeSlashes)(event.suite.path);
                this.owningDebugSessions[event.suite.path] = debugSessionID;
                this.handleSuiteNotification(dartCodeDebugSessionID, event);
                break;
            case "testStart":
                this.handleTestStartNotification(dartCodeDebugSessionID, evt);
                break;
            case "testDone":
                this.handleTestDoneNotification(dartCodeDebugSessionID, evt);
                break;
            case "group":
                this.handleGroupNotification(dartCodeDebugSessionID, evt);
                break;
            // We won't get notifications that aren't directly tied to Suites because
            // of how the DA works.
            // case "done":
            // 	this.handleDoneNotification(suite, evt as DoneNotification);
            // 	break;
            case "print":
                this.handlePrintNotification(dartCodeDebugSessionID, evt);
                break;
            case "error":
                this.handleErrorNotification(dartCodeDebugSessionID, evt);
                break;
        }
    }
    handleSuiteNotification(dartCodeDebugSessionID, evt) {
        if (!this.debugSessionLookups[dartCodeDebugSessionID])
            this.debugSessionLookups[dartCodeDebugSessionID] = { suiteForID: {}, suiteForTestID: {} };
        const suiteData = this.data.suiteDiscovered(dartCodeDebugSessionID, evt.suite.path);
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.suite.id] = suiteData;
        // Also capture the test nodes from the outline so that we can look up the full range for a test (instead of online its line/col)
        // to provide to VS Code to better support "run test at cursor".
        this.captureTestOutlne(evt.suite.path);
    }
    captureTestOutlne(path) {
        const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, path);
        this.suiteOutlineVisitors[path] = visitor;
        const outline = this.fileTracker?.getOutlineFor(vscode_uri_1.URI.file(path));
        if (outline)
            visitor.visit(outline);
    }
    handleTestStartNotification(dartCodeDebugSessionID, evt) {
        // Skip loading tests.
        if (evt.test.name?.startsWith("loading ") && !evt.test.groupIDs?.length)
            return;
        const suite = this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.test.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.test.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForTestID[evt.test.id] = suite;
        /// We prefer the root location (the location inside the executed test suite) for normal tests, but for
        // setup/tearDown we want to consider them in their actual locations so that failures will be attributed
        // to them correctly.
        // https://github.com/Dart-Code/Dart-Code/issues/4681#issuecomment-1671191742
        const useRootLocation = !(0, test_1.isSetupOrTeardownTestName)(evt.test.name) && !!evt.test.root_url && !!evt.test.root_line && !!evt.test.root_column;
        const path = (0, utils_1.maybeUriToFilePath)(useRootLocation ? evt.test.root_url : evt.test.url);
        const line = useRootLocation ? evt.test.root_line : evt.test.line;
        const character = useRootLocation ? evt.test.root_column : evt.test.column;
        const range = this.getRangeForNode(suite, line, character);
        const groupID = evt.test.groupIDs?.length ? evt.test.groupIDs[evt.test.groupIDs.length - 1] : undefined;
        this.data.testDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.test.id, evt.test.name, this.getRealGroupId(dartCodeDebugSessionID, groupID), path, range, evt.time, true);
    }
    handleTestDoneNotification(dartCodeDebugSessionID, evt) {
        // If we don't have a test, it was likely a "loading foo.dart" test that we skipped over, so skip the result too.
        const suite = this.debugSessionLookups[dartCodeDebugSessionID]?.suiteForTestID[evt.testID];
        if (!suite) {
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        if (!test)
            return;
        const result = evt.skipped ? "skipped" : evt.result;
        this.data.testDone(dartCodeDebugSessionID, suite.path, evt.testID, result, evt.time);
    }
    handleGroupNotification(dartCodeDebugSessionID, evt) {
        // Skip phantom groups.
        if (!evt.group.name) {
            if (dartCodeDebugSessionID) {
                this.phantomGroupParents[dartCodeDebugSessionID] = this.phantomGroupParents[dartCodeDebugSessionID] || {};
                this.phantomGroupParents[dartCodeDebugSessionID][evt.group.id] = evt.group.parentID ?? null; // Null signifies top-level.
            }
            return;
        }
        const suite = this.debugSessionLookups[dartCodeDebugSessionID]?.suiteForID[evt.group.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.group.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const path = (evt.group.root_url || evt.group.url) ? (0, utils_1.uriToFilePath)(evt.group.root_url || evt.group.url) : undefined;
        const line = evt.group.root_line || evt.group.line;
        const character = evt.group.root_column || evt.group.column;
        const range = this.getRangeForNode(suite, line, character);
        this.data.groupDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.group.id, evt.group.name, this.getRealGroupId(dartCodeDebugSessionID, evt.group.parentID), path, range, true);
    }
    getRealGroupId(dartCodeDebugSessionID, groupID) {
        const mapping = dartCodeDebugSessionID ? this.phantomGroupParents[dartCodeDebugSessionID] : undefined;
        const mappedValue = mapping && groupID ? mapping[groupID] : undefined;
        // Null is a special value that means undefined top-level)
        return mappedValue === null
            ? undefined
            // Whereas a real undefined we just pass-through as it was.
            : mappedValue ?? groupID;
    }
    handleSuiteEnd(dartCodeDebugSessionID, suite) {
        this.data.suiteDone(dartCodeDebugSessionID, suite.path);
    }
    handlePrintNotification(dartCodeDebugSessionID, evt) {
        const suite = this.debugSessionLookups[dartCodeDebugSessionID]?.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        test.outputEvents.push(evt);
        this.data.testOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.message);
    }
    handleErrorNotification(dartCodeDebugSessionID, evt) {
        const suite = this.debugSessionLookups[dartCodeDebugSessionID]?.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        // Flutter emits an error when tests fail which when reported to the VS Code API will result in not-so-useful text
        // in the Test Error Peek window, so we suppress messages that match this pattern.
        const pattern = new RegExp(`
Test failed. See exception logs above.
The test description was: .*
`.trim());
        if (pattern.test(evt.error.trim()))
            return;
        test.outputEvents.push(evt);
        this.data.testErrorOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.isFailure, evt.error, evt.stackTrace);
    }
    getRangeForNode(suite, line, character) {
        if (!line || !character)
            return;
        // VS Code is zero-based, but package:test is 1-based.
        const zeroBasedLine = line - 1;
        const zeroBasedCharacter = character - 1;
        // In test notifications, we only get the start line/column but we need to give VS Code the full range for "Run Test at Cursor" to work.
        // The outline data was captured when the suite started, so we can assume it's reasonable accurate, so try to look up the node
        // there and use its range. Otherwise, just make a range that goes from the start position to the next line (assuming the rest
        // of the line is the test name, and we can at least support running it there).
        const testsOnLine = line ? this.suiteOutlineVisitors[suite.path]?.testsByLine[zeroBasedLine] : undefined;
        const test = testsOnLine ? testsOnLine.find((t) => t.range.start.character === zeroBasedCharacter) : undefined;
        const range = line && character
            ? test?.range ?? {
                end: { line: zeroBasedLine + 1, character: zeroBasedCharacter },
                start: { line: zeroBasedLine, character: zeroBasedCharacter },
            }
            : undefined;
        return range;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestSessionCoordinator = TestSessionCoordinator;


/***/ }),

/***/ 5871:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSource = exports.SuiteData = exports.TestModel = exports.TestNode = exports.GroupNode = exports.SuiteNode = exports.TreeNode = void 0;
const enums_1 = __webpack_require__(3962);
const events_1 = __webpack_require__(9495);
const utils_1 = __webpack_require__(949);
const document_cache_1 = __webpack_require__(2524);
const fs_1 = __webpack_require__(2587);
const test_1 = __webpack_require__(672);
class TreeNode {
    suiteData;
    _isStale = false;
    testSource = TestSource.Outline;
    isPotentiallyDeleted = false;
    duration;
    testCount = 0;
    testCountPass = 0;
    testCountSkip = 0;
    description;
    constructor(suiteData) {
        this.suiteData = suiteData;
    }
    children = [];
    getHighestChildStatus(includeSkipped) {
        const statuses = new Set();
        const addStatus = (node) => {
            if (node !== this && node instanceof TestNode)
                statuses.add(node.status);
            for (const child of node.children)
                addStatus(child);
        };
        addStatus(this);
        // Always include Skipped status for Suite nodes that have only that status, else they'll
        // show as unknown.
        if (!includeSkipped && this instanceof SuiteNode && statuses.size === 1 && statuses.has(enums_1.TestStatus.Skipped))
            includeSkipped = true;
        const validStatues = [...statuses].filter((s) => includeSkipped || s !== enums_1.TestStatus.Skipped);
        return validStatues.length
            ? Math.max(...validStatues)
            : enums_1.TestStatus.Unknown;
    }
    get label() {
        const name = this instanceof GroupNode
            ? this.name
            : this instanceof TestNode
                ? this.name
                : undefined;
        let parent = this.parent;
        while (name && parent) {
            const parentName = parent instanceof GroupNode
                ? parent.name
                : parent instanceof TestNode
                    ? parent.name
                    : undefined;
            if (parentName && name.startsWith(`${parentName} `))
                return name.substr(parentName.length + 1); // +1 because of the space (included above).
            // Otherwise try next parent up.
            parent = parent?.parent;
        }
        return name ?? "<unnamed>";
    }
    get isStale() {
        return this._isStale;
    }
    set isStale(value) {
        this._isStale = value;
    }
}
exports.TreeNode = TreeNode;
class SuiteNode extends TreeNode {
    constructor(suiteData) {
        super(suiteData);
    }
    get parent() { return undefined; }
    get path() {
        return this.suiteData.path;
    }
}
exports.SuiteNode = SuiteNode;
class GroupNode extends TreeNode {
    suiteData;
    parent;
    name;
    path;
    range;
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
    }
    get isSkipped() {
        return this.children.every((c) => {
            if (c instanceof GroupNode || c instanceof TestNode)
                return c.isSkipped;
            else
                return false;
        });
    }
}
exports.GroupNode = GroupNode;
class TestNode extends TreeNode {
    suiteData;
    parent;
    name;
    path;
    range;
    _status = enums_1.TestStatus.Unknown;
    outputEvents = [];
    testStartTime;
    // TODO: Flatten test into this class so we're not tied to the test protocol.
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
    }
    get status() {
        if (this.children.length)
            return super.getHighestChildStatus(true);
        return this._status;
    }
    set status(value) {
        this._status = value;
        if (this._status === enums_1.TestStatus.Failed
            || this._status === enums_1.TestStatus.Passed
            || this._status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
        }
    }
    get isSkipped() {
        if (this.children.length === 0)
            return this.status === enums_1.TestStatus.Skipped;
        else
            return this.children.every((c) => c.isSkipped);
    }
    get isStale() {
        if (this.children.length)
            return !!this.children.find((c) => c.isStale);
        return super.isStale;
    }
    set isStale(value) {
        super.isStale = value;
    }
}
exports.TestNode = TestNode;
class TestModel {
    config;
    isPathInsideFlutterProject;
    onDidChangeDataEmitter = new events_1.EventEmitter();
    onDidChangeTreeData = this.onDidChangeDataEmitter.event;
    testEventListeners = [];
    // TODO: Make private?
    suites = new document_cache_1.DocumentCache();
    constructor(config, isPathInsideFlutterProject) {
        this.config = config;
        this.isPathInsideFlutterProject = isPathInsideFlutterProject;
    }
    addTestEventListener(listener) {
        this.testEventListeners.push(listener);
    }
    flagSuiteStart(suite, isRunningWholeSuite) {
        // Mark all test for this suite as "stale" which will make them faded, so that results from
        // the "new" run are more obvious in the tree.
        suite.getAllGroups().forEach((g) => g.isStale = true);
        suite.getAllTests().forEach((t) => t.isStale = true);
        if (isRunningWholeSuite && suite) {
            this.markAllAsPotentiallyDeleted(suite, TestSource.Result);
        }
    }
    // When running the whole suite (or updating from Outline), we flag all tests as being
    // potentially deleted and then any tests that aren't run are removed from the tree. This
    // is to ensure if a test is renamed, we don't keep the old version of it in the test tree
    // forever since we don't have the necessary information to know the test was renamed.
    //
    // When updating from the outline, we'll skip children of dynamic nodes as we don't
    // know if they've been deleted or not, and don't want to cause their results to
    // immediately disappear.
    markAllAsPotentiallyDeleted(suite, source) {
        function doNode(node) {
            if (node.testSource === source)
                node.isPotentiallyDeleted = true;
            node.children.forEach(doNode);
        }
        doNode(suite.node);
    }
    // Marks a node and all of its parents as not-deleted so they will not be cleaned up.
    markAsNotDeleted(node) {
        while (node) {
            node.isPotentiallyDeleted = false;
            node = node.parent;
        }
    }
    removeAllPotentiallyDeletedNodes(suite) {
        // Delete nodes that were marked as potentially deleted and then never updated.
        // This means they weren't run in the last run, so probably were deleted (or
        // renamed and got new nodes, which still means the old ones should be removed).
        const toDelete = [
            ...suite.getAllGroups(),
            ...suite.getAllTests(),
        ].filter((t) => t.isPotentiallyDeleted);
        toDelete.forEach((node) => this.removeNode(node));
    }
    getOrCreateSuite(suitePath) {
        let suite = this.suites.getForPath(suitePath);
        if (!suite) {
            suite = new SuiteData(suitePath, this.isPathInsideFlutterProject(suitePath));
            this.suites.setForPath(suitePath, suite);
            return [suite, true];
        }
        return [suite, false];
    }
    clearSuiteOrDirectory(suiteOrDirectoryPath) {
        // We can't tell if it's a file or directory because it's already been deleted, so just
        // try both.
        let found = false;
        if (this.suites.hasForPath(suiteOrDirectoryPath)) {
            found = true;
            this.suites.deleteForPath(suiteOrDirectoryPath);
        }
        else {
            for (const suitePath of Object.keys(this.suites)) {
                if ((0, fs_1.isWithinPath)(suitePath, suiteOrDirectoryPath)) {
                    this.suites.deleteForPath(suitePath);
                    found = true;
                }
            }
        }
        if (found)
            this.updateNode();
    }
    handleConfigChange() {
        // When config changes, some things may change (for example
        // skipped tests may be hidden, so the test counts need
        // recomputing).
        for (const suite of this.suites.values()) {
            this.updateSuiteTestCountLabels(suite, true);
        }
    }
    updateNode(event) {
        this.onDidChangeDataEmitter.fire(event);
    }
    updateSuiteTestCountLabels(suite, forceUpdate) {
        this.updateTestCountLabels(suite.node, forceUpdate, "DOWN");
    }
    /// Recomputes the test counts and labels for a node and it's parent/children (based on `direction`).
    updateTestCountLabels(node, forceUpdate, direction) {
        if (direction === "DOWN") {
            for (const child of node.children)
                this.updateTestCountLabels(child, forceUpdate, direction);
        }
        // Update the cached counts on this node.
        if (node instanceof TestNode && !node.children.length) {
            node.testCount = 1;
            node.testCountPass = node.status === enums_1.TestStatus.Passed ? 1 : 0;
            node.testCountSkip = node.status === enums_1.TestStatus.Skipped ? 1 : 0;
        }
        else {
            node.testCount = node.children.map((c) => c.testCount).reduce((total, value) => total + value, 0);
            node.testCountPass = node.children.map((c) => c.testCountPass).reduce((total, value) => total + value, 0);
            node.testCountSkip = node.children.map((c) => c.testCountSkip).reduce((total, value) => total + value, 0);
        }
        const totalTests = this.config.showSkippedTests ? node.testCount : node.testCount - node.testCountSkip;
        // Update the label.
        const previousDescription = node.description;
        node.description = node.children.length && totalTests !== 0 ? `${node.testCountPass}/${totalTests} passed` : "";
        if (forceUpdate || node.description !== previousDescription)
            this.updateNode({ node });
        if (direction === "UP") {
            const parent = node.parent;
            if (parent instanceof SuiteNode || parent instanceof GroupNode || parent instanceof TestNode)
                this.updateTestCountLabels(parent, false, direction);
        }
    }
    suiteDiscoveredConditional(dartCodeDebugSessionID, suitePath) {
        return this.suites.getForPath(suitePath) ?? this.suiteDiscovered(dartCodeDebugSessionID, suitePath);
    }
    suiteDiscovered(dartCodeDebugSessionID, suitePath) {
        const [suite, didCreate] = this.getOrCreateSuite(suitePath);
        this.updateNode({ node: suite.node });
        this.testEventListeners.forEach((l) => l.suiteDiscovered(dartCodeDebugSessionID, suite.node));
        return suite;
    }
    groupDiscovered(dartCodeDebugSessionID, suitePath, source, groupID, groupName, parentID, groupPath, range, hasStarted = false) {
        groupPath ??= suitePath;
        const suite = this.suites.getForPath(suitePath);
        const existingGroup = suite.reuseMatchingGroup(groupName);
        const oldParent = existingGroup?.parent;
        let parent = parentID ? suite.getMyGroup(dartCodeDebugSessionID, parentID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (groupName && source === TestSource.Result)
            parent = this.findMatchingDynamicNode(parent, groupName) ?? parent;
        const groupNode = existingGroup || new GroupNode(suite, parent, groupName, groupPath, range);
        suite.storeGroup(dartCodeDebugSessionID, groupID, groupNode);
        if (existingGroup) {
            groupNode.parent = parent;
            groupNode.name = groupName;
            groupNode.path = groupPath;
            groupNode.range = range;
        }
        else {
            groupNode.testSource = source;
        }
        this.markAsNotDeleted(groupNode);
        // Remove from old parent if required
        const hasChangedParent = oldParent !== parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(groupNode), 1);
            this.updateNode({ node: oldParent });
        }
        // Push to new parent if required.
        if (!groupNode.parent.children.find((n) => n === groupNode))
            groupNode.parent.children.push(groupNode);
        this.updateNode({ node: groupNode });
        this.testEventListeners.forEach((l) => l.groupDiscovered(dartCodeDebugSessionID, groupNode));
        return groupNode;
    }
    testDiscovered(dartCodeDebugSessionID, suitePath, source, testID, testName, groupID, testPath, range, startTime, hasStarted = false) {
        testPath ??= suitePath;
        const suite = this.suites.getForPath(suitePath);
        const existingTest = suite.reuseMatchingTest(testName);
        const oldParent = existingTest?.parent;
        let parent = groupID ? suite.getMyGroup(dartCodeDebugSessionID, groupID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (testName && source === TestSource.Result)
            parent = this.findMatchingDynamicNode(parent, testName) ?? parent;
        const testNode = existingTest || new TestNode(suite, parent, testName, testPath, range);
        suite.storeTest(dartCodeDebugSessionID, testID, testNode);
        if (existingTest) {
            testNode.parent = parent;
            testNode.name = testName;
            testNode.path = testPath;
            const originalRange = testNode.range;
            testNode.range = range;
            // If we're an Outline node being updated, and we have Results children that
            // had the same range as us, they should be updated too, so Results nodes do not
            // drift away from the location over time.
            if (testNode.testSource === TestSource.Outline) {
                const children = testNode.children
                    .filter((c) => c.testSource === TestSource.Result)
                    .filter((c) => !c.range || (originalRange && this.rangeEquals(c.range, originalRange)));
                for (const child of children)
                    child.range = range;
            }
        }
        else {
            testNode.testSource = source;
        }
        this.markAsNotDeleted(testNode);
        testNode.testStartTime = startTime;
        // Remove from old parent if required.
        const hasChangedParent = oldParent && oldParent !== testNode.parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(testNode), 1);
            this.updateNode({ node: oldParent });
        }
        // Push to new parent if required.
        if (!testNode.parent.children.find((n) => n === testNode))
            testNode.parent.children.push(testNode);
        if (hasStarted) {
            // Clear any test output from previous runs.
            testNode.outputEvents.length = 0;
            testNode.status = enums_1.TestStatus.Running;
        }
        this.updateNode({ node: testNode });
        if (hasStarted && dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testStarted(dartCodeDebugSessionID, testNode));
        return testNode;
    }
    /// Find a matching node in 'parent' that might be a node for a dynamic test/group that name is
    /// an instance of.
    findMatchingDynamicNode(parent, name) {
        // If the parent has any children exactly named us, they should be used regardless.
        if (parent.children.find((c) => c.name === name))
            return;
        for (const child of parent.children) {
            if (!child.name || typeof child !== typeof parent)
                continue;
            const regex = new RegExp((0, test_1.makeRegexForTests)([{ name: child.name, isGroup: child instanceof GroupNode, position: undefined }]));
            if (regex.test(name))
                return child;
        }
    }
    testDone(dartCodeDebugSessionID, suitePath, testID, result, endTime) {
        const suite = this.suites.getForPath(suitePath);
        const testNode = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (result === "skipped") {
            testNode.status = enums_1.TestStatus.Skipped;
        }
        else if (result === "success") {
            testNode.status = enums_1.TestStatus.Passed;
        }
        else if (result === "failure") {
            testNode.status = enums_1.TestStatus.Failed;
        }
        else if (result === "error")
            testNode.status = enums_1.TestStatus.Failed;
        else {
            testNode.status = enums_1.TestStatus.Unknown;
        }
        if (endTime && testNode.testStartTime) {
            testNode.duration = endTime - testNode.testStartTime;
            testNode.description = ``;
            // Don't clear this, as concurrent runs will overwrite each
            // other and then we'll get no time at the end.
            // testNode.testStartTime = undefined;
        }
        this.updateTestCountLabels(testNode, true, "UP");
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testDone(dartCodeDebugSessionID, testNode, result));
    }
    suiteDone(dartCodeDebugSessionID, suitePath) {
        const suite = this.suites.getForPath(suitePath);
        if (!suite)
            return;
        // TODO: Some notification that things are complete?
        // TODO: Maybe a progress bar during the run?
        this.removeAllPotentiallyDeletedNodes(suite);
        // Anything marked as running should be set back to Unknown
        suite.getAllTests().filter((t) => t.status === enums_1.TestStatus.Running).forEach((t) => {
            t.status = enums_1.TestStatus.Unknown;
            this.updateNode({ node: t });
        });
        this.updateSuiteTestCountLabels(suite, false);
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.suiteDone(dartCodeDebugSessionID, suite.node));
    }
    testOutput(dartCodeDebugSessionID, suitePath, testID, message) {
        const suite = this.suites.getForPath(suitePath);
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testOutput(dartCodeDebugSessionID, test, message));
    }
    testErrorOutput(dartCodeDebugSessionID, suitePath, testID, isFailure, message, stack) {
        const suite = this.suites.getForPath(suitePath);
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testErrorOutput(dartCodeDebugSessionID, test, message, isFailure, stack));
    }
    removeNode(node) {
        const parent = node.parent;
        const index = parent.children.indexOf(node);
        if (index > -1)
            parent.children.splice(index, 1);
        this.updateNode({ node, nodeWasRemoved: true });
    }
    rangeEquals(r1, r2) {
        return this.positionEquals(r1.start, r2.start) && this.positionEquals(r1.end, r2.end);
    }
    positionEquals(p1, p2) {
        return p1.line === p2.line && p1.character === p2.character;
    }
}
exports.TestModel = TestModel;
class SuiteData {
    path;
    isFlutterSuite;
    node;
    groupsById = new Map();
    groupsByName = new Map();
    testsById = new Map();
    testsByName = new Map();
    constructor(path, isFlutterSuite) {
        this.path = path;
        this.isFlutterSuite = isFlutterSuite;
        this.node = new SuiteNode(this);
    }
    static unnamedItemMarker = "<!!!###unnamed-test-item###!!!>";
    getAllGroups() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.groupsById.values()]);
    }
    getAllTests() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.testsById.values()]);
    }
    getCurrentTest(sessionID, id) {
        return this.testsById.get(`${sessionID}_${id}`);
    }
    getMyGroup(sessionID, id) {
        return this.groupsById.get(`${sessionID}_${id}`);
    }
    getMyTest(sessionID, id) {
        return this.testsById.get(`${sessionID}_${id}`);
    }
    storeGroup(sessionID, groupID, node) {
        this.groupsByName.set(node.name ?? SuiteData.unnamedItemMarker, node);
        return this.groupsById.set(`${sessionID}_${groupID}`, node);
    }
    storeTest(sessionID, testID, node) {
        this.testsByName.set(node.name ?? SuiteData.unnamedItemMarker, node);
        return this.testsById.set(`${sessionID}_${testID}`, node);
    }
    reuseMatchingGroup(groupName) {
        return this.groupsByName.get(groupName ?? SuiteData.unnamedItemMarker);
    }
    reuseMatchingTest(testName) {
        return this.testsByName.get(testName ?? SuiteData.unnamedItemMarker);
    }
}
exports.SuiteData = SuiteData;
var TestSource;
(function (TestSource) {
    TestSource[TestSource["Outline"] = 0] = "Outline";
    TestSource[TestSource["Result"] = 1] = "Result";
})(TestSource || (exports.TestSource = TestSource = {}));


/***/ }),

/***/ 7149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackageTestCapabilities = getPackageTestCapabilities;
const path = __importStar(__webpack_require__(6928));
const semver = __importStar(__webpack_require__(9589));
const dart_test_1 = __webpack_require__(3877);
const constants_1 = __webpack_require__(6709);
const processes_1 = __webpack_require__(4917);
const cachedTestCapabilities = {};
async function getPackageTestCapabilities(logger, workspaceContext, folder) {
    // Don't ever run the command below in places like the SDK.
    if (workspaceContext.config.supportsDartRunTest === false)
        return dart_test_1.DartTestCapabilities.empty;
    const sdks = workspaceContext.sdks;
    if (!cachedTestCapabilities[folder]) {
        const binPath = path.join(sdks.dart, constants_1.dartVMPath);
        const proc = await (0, processes_1.runProcess)(logger, binPath, ["run", "test:test", "--version"], folder, {}, processes_1.safeSpawn);
        const capabilities = dart_test_1.DartTestCapabilities.empty;
        if (proc.exitCode === 0) {
            if (semver.valid(proc.stdout.trim()))
                capabilities.version = proc.stdout.trim();
        }
        cachedTestCapabilities[folder] = capabilities;
    }
    return cachedTestCapabilities[folder];
}


/***/ }),

/***/ 949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferedLogger = exports.PromiseCompleter = void 0;
exports.uniq = uniq;
exports.flatMap = flatMap;
exports.flatMapAsync = flatMapAsync;
exports.filenameSafe = filenameSafe;
exports.escapeRegExp = escapeRegExp;
exports.findFileInAncestor = findFileInAncestor;
exports.maybeUriToFilePath = maybeUriToFilePath;
exports.uriToFilePath = uriToFilePath;
exports.isDartSdkFromFlutter = isDartSdkFromFlutter;
exports.versionIsAtLeast = versionIsAtLeast;
exports.pubVersionIsAtLeast = pubVersionIsAtLeast;
exports.isStableSdk = isStableSdk;
exports.usingCustomScript = usingCustomScript;
exports.errorString = errorString;
exports.nullToUndefined = nullToUndefined;
exports.notUndefined = notUndefined;
exports.notNull = notNull;
exports.notNullOrUndefined = notNullOrUndefined;
exports.asHexColor = asHexColor;
exports.asHex = asHex;
exports.clamp = clamp;
exports.generateTestNameFromFileName = generateTestNameFromFileName;
exports.escapeDartString = escapeDartString;
exports.isWebDevice = isWebDevice;
exports.disposeAll = disposeAll;
exports.withTimeout = withTimeout;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const semver = __importStar(__webpack_require__(9589));
const constants_1 = __webpack_require__(6709);
function uniq(array) {
    return array.filter((value, index) => array.indexOf(value) === index);
}
function flatMap(input, f) {
    return input.reduce((acc, x) => acc.concat(f(x)), []);
}
async function flatMapAsync(input, f) {
    let res = [];
    for (const x of input)
        res = res.concat(await f(x));
    return res;
}
function filenameSafe(input) {
    return input.replace(/[^a-z0-9]+/gi, "_").replace(/_{2,}/g, "_").replace(/_$/g, "").toLowerCase();
}
function escapeRegExp(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
class PromiseCompleter {
    promise;
    resolve;
    reject;
    constructor() {
        this.promise = new Promise((res, rej) => {
            this.resolve = res;
            this.reject = rej;
        });
    }
}
exports.PromiseCompleter = PromiseCompleter;
function findFileInAncestor(files, startLocation) {
    let lastParent;
    let parent = startLocation;
    while (parent && parent.length > 1 && parent !== lastParent) {
        for (const file of files) {
            const child = path.join(parent, file);
            if (fs.existsSync(child))
                return child;
        }
        lastParent = parent;
        parent = path.dirname(parent);
    }
    return undefined;
}
/// Converts a file URI to file path without a dependency on vs.Uri.
function maybeUriToFilePath(uri, returnWindowsPath = constants_1.isWin) {
    return uri === undefined ? uri : uriToFilePath(uri);
}
/// Converts a file URI to file path without a dependency on vs.Uri.
function uriToFilePath(uri, returnWindowsPath = constants_1.isWin) {
    let filePath = uri;
    if (uri.startsWith("file://"))
        filePath = decodeURI(uri.substring(7));
    else if (uri.startsWith("file:"))
        filePath = decodeURI(uri.substring(5)); // TODO: Does this case ever get hit? Will it be over-decoded?
    // Windows fixup.
    if (returnWindowsPath) {
        filePath = filePath.replace(/\//g, "\\");
        if (filePath.startsWith("\\"))
            filePath = filePath.substring(1);
    }
    else {
        if (!filePath.startsWith("/"))
            filePath = `/${filePath}`;
    }
    return filePath;
}
function isDartSdkFromFlutter(dartSdkPath) {
    const possibleFlutterSdkPath = path.join(path.dirname(path.dirname(path.dirname(dartSdkPath))), "bin");
    return fs.existsSync(path.join(possibleFlutterSdkPath, constants_1.executableNames.flutter));
}
function versionIsAtLeast(inputVersion, requiredVersion) {
    return semver.gte(inputVersion, requiredVersion);
}
function pubVersionIsAtLeast(inputVersion, requiredVersion) {
    // Standard semver gt/lt
    if (semver.gt(inputVersion, requiredVersion))
        return true;
    else if (semver.lt(inputVersion, requiredVersion))
        return false;
    // If the versions are equal, we need to handle build metadata like pub does.
    // https://github.com/dart-lang/pub_semver/
    // If only one of them has build metadata, it's newest.
    if (inputVersion.includes("+") && !requiredVersion.includes("+"))
        return true;
    if (!inputVersion.includes("+") && requiredVersion.includes("+"))
        return false;
    // Otherwise, since they're both otherwise equal and both have build
    // metadata we can treat the build metadata like pre-release by converting
    // it to pre-release (with -) or appending it to existing pre-release.
    inputVersion = inputVersion.replace("+", !inputVersion.includes("-") ? "-" : ".");
    requiredVersion = requiredVersion.replace("+", !requiredVersion.includes("-") ? "-" : ".");
    return versionIsAtLeast(inputVersion, requiredVersion);
}
function isStableSdk(sdkVersion) {
    // We'll consider empty versions as dev; stable versions will likely always
    // be shipped with valid version files.
    return !!(sdkVersion && !semver.prerelease(sdkVersion));
}
function usingCustomScript(binPath, binArgs, customScript) {
    if (customScript?.script) {
        binPath = customScript.script;
        if (customScript.replacesArgs)
            binArgs = binArgs.slice(customScript.replacesArgs);
    }
    return { executable: binPath, args: binArgs };
}
function errorString(error) {
    if (!error)
        return "<empty error>";
    else if (error instanceof Error)
        return error.message + (error.stack ? `\n${error.stack}` : "");
    else if (error.message)
        return error.message;
    else if (typeof error === "string")
        return error;
    else
        return `${error}`;
}
class BufferedLogger {
    buffer = [];
    info(message, category) {
        this.buffer.push({ type: "info", message, category });
    }
    warn(message, category) {
        this.buffer.push({ type: "warn", message, category });
    }
    error(error, category) {
        this.buffer.push({ type: "error", message: error, category });
    }
    flushTo(logger) {
        if (!this.buffer.length)
            return;
        logger.info("Flushing log messages...");
        for (const log of this.buffer) {
            switch (log.type) {
                case "info":
                    logger.info(log.message, log.category);
                    break;
                case "warn":
                    logger.warn(log.message, log.category);
                    break;
                case "error":
                    logger.error(log.message, log.category);
                    break;
            }
        }
        logger.info("Done flushing log messages...");
    }
}
exports.BufferedLogger = BufferedLogger;
function nullToUndefined(value) {
    return (value === null ? undefined : value);
}
function notUndefined(x) {
    return x !== undefined;
}
function notNull(x) {
    return x !== null;
}
function notNullOrUndefined(x) {
    return notUndefined(x) && notNull(x);
}
function asHexColor({ r, g, b, a }) {
    r = clamp(r, 0, 255);
    g = clamp(g, 0, 255);
    b = clamp(b, 0, 255);
    a = clamp(a, 0, 255);
    return `${asHex(a)}${asHex(r)}${asHex(g)}${asHex(b)}`.toLowerCase();
}
function asHex(v) {
    return Math.round(v).toString(16).padStart(2, "0");
}
function clamp(v, min, max) {
    return Math.min(Math.max(min, v), max);
}
function generateTestNameFromFileName(input) {
    return path.basename(input).replace("_test.dart", "").replace(/_/g, " ");
}
function escapeDartString(input) {
    return input.replace(/(['"\\])/g, "\\$1");
}
function isWebDevice(deviceId) {
    return !!(deviceId?.startsWith("web") || deviceId === "chrome" || deviceId === "edge");
}
function disposeAll(disposables) {
    const toDispose = disposables.slice();
    disposables.length = 0;
    for (const d of toDispose) {
        try {
            void d.dispose();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
async function withTimeout(promise, message, seconds = 360) {
    return new Promise((resolve, reject) => {
        // Set a timeout to reject the promise after the timeout period.
        const timeoutTimer = setTimeout(() => {
            const msg = typeof message === "string" ? message : message();
            reject(new Error(`${msg} within ${seconds}s`));
        }, seconds * 1000);
        // When the main promise completes (or rejects), cancel the timeout and return its result.
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        promise.then((result) => {
            clearTimeout(timeoutTimer);
            resolve(result);
        }, (e) => {
            clearTimeout(timeoutTimer);
            reject(e);
        });
    });
}


/***/ }),

/***/ 3043:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sortBy = sortBy;
exports.not = not;
exports.unique = unique;
exports.arraysEqual = arraysEqual;
exports.arrayStartsWith = arrayStartsWith;
exports.arrayContainsArray = arrayContainsArray;
function sortBy(items, f) {
    return items.sort((item1, item2) => {
        const r1 = f(item1);
        const r2 = f(item2);
        if (r1 < r2)
            return -1;
        if (r1 > r2)
            return 1;
        return 0;
    });
}
function not(f) {
    return (x) => !f(x);
}
function unique(items) {
    return Array.from(new Set(items));
}
function arraysEqual(items1, items2) {
    return items1.length === items2.length && items1.every((val, i) => val === items2[i]);
}
function arrayStartsWith(items1, items2) {
    return items1.length >= items2.length && arraysEqual(items1.slice(0, items2.length), items2);
}
function arrayContainsArray(haystack, needle) {
    // Loop over valid starting points for the subarray
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        // Check if the relevant length sublist equals the other array.
        if (arraysEqual(haystack.slice(i, i + needle.length), needle))
            return true;
    }
    return false;
}


/***/ }),

/***/ 5224:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleTimeBasedCache = void 0;
/// Simple time-base cache.
class SimpleTimeBasedCache {
    data = new Map();
    get(key) {
        const item = this.data.get(key);
        if (item && item.expiryTime < new Date().getTime()) {
            this.data.delete(key);
            return undefined;
        }
        return item?.data;
    }
    add(key, item, millisecondsToCache) {
        this.data.set(key, {
            data: item,
            expiryTime: new Date().getTime() + millisecondsToCache,
        });
    }
}
exports.SimpleTimeBasedCache = SimpleTimeBasedCache;


/***/ }),

/***/ 8450:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanDartdoc = cleanDartdoc;
exports.stripMarkdown = stripMarkdown;
const utils_1 = __webpack_require__(949);
const materialIconRegex = new RegExp((0, utils_1.escapeRegExp)('<i class="material-icons')
    + "(?:-([\\w]+))?"
    + (0, utils_1.escapeRegExp)(' md-36">')
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const cupertinoIconRegex = new RegExp((0, utils_1.escapeRegExp)(`<i class='cupertino-icons md-36'>`)
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const dartDocDirectives = new RegExp(`(\\n\\s*{@.*?}$)|(^{@.*?}\\s*\\n)|(^{@.*?}$)`, "gim");
const dartDocCodeBlockSections = new RegExp(`(\`\`\`\\w+) +\\w+`, "gi");
function cleanDartdoc(doc, iconPathFormat) {
    if (!doc)
        return "";
    // Clean up some dart.core dartdoc.
    const index = doc.indexOf("## Other resources");
    if (index !== -1)
        doc = doc.substring(0, index);
    // Remove colons from old-style references like [:foo:].
    doc = doc.replace(/\[:\S+:\]/g, (match) => `[${match.substring(2, match.length - 2)}]`);
    // Replace material icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(materialIconRegex, (_fullMatch, variant, icon) => {
        if (variant) {
            variant = fixVariant(variant);
            icon = `${icon}_${variant}`;
        }
        icon = fixIcon(icon);
        const iconPath = iconPathFormat.replace("$1", `material/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Replace cupertino icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(cupertinoIconRegex, (_fullMatch, icon) => {
        const iconPath = iconPathFormat.replace("$1", `cupertino/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Remove any directives like {@template xxx}
    doc = doc.replace(dartDocDirectives, "");
    // Remove any code block section names like ```dart preamble
    doc = doc.replace(dartDocCodeBlockSections, "$1");
    return doc;
}
/// Strips markdown to make nicer plain text.
function stripMarkdown(doc) {
    if (!doc)
        return "";
    // Remove links like [foo](bar).
    doc = doc.replace(/\[(.+?)\]\(.+?\)/g, "$1");
    // Remove references like [foo].
    doc = doc.replace(/\[(.+?)\]/g, "$1");
    return doc;
}
function fixVariant(variant) {
    // Class names don't always match the filenames.
    return variant === "round" ? "rounded" : variant;
}
const identifierPrefixRewritePattern = new RegExp(`^(?:3d|\\d+)`);
const identifierPrefixRewrites = {
    // See identifierPrefixRewrites in
    // https://github.com/flutter/flutter/blob/master/dev/tools/update_icons.dart
    "1": "one_",
    "10": "ten_",
    "11": "eleven_",
    "12": "twelve_",
    "123": "onetwothree",
    "13": "thirteen_",
    "14": "fourteen_",
    "15": "fifteen_",
    "16": "sixteen_",
    "17": "seventeen_",
    "18": "eighteen_",
    "19": "nineteen_",
    "2": "two_",
    "20": "twenty_",
    "21": "twenty_one_",
    "22": "twenty_two_",
    "23": "twenty_three_",
    "24": "twenty_four_",
    "2d": "twod",
    "3": "three_",
    "30": "thirty_",
    "360": "threesixty",
    "3d": "threed",
    "4": "four_",
    "5": "five_",
    "6": "six_",
    "60": "sixty_",
    "7": "seven_",
    "8": "eight_",
    "9": "nine_",
};
const identifierExactRewrites = {
    // See identifierExactRewrites in
    // https://github.com/flutter/flutter/blob/master/dev/tools/update_icons.dart
    class: "class_",
    // eslint-disable-next-line camelcase
    door_back: "door_back_door",
    // eslint-disable-next-line camelcase
    door_front: "door_front_door",
    new: "new_",
    switch: "switch_",
    try: "try_sms_star",
};
function fixIcon(icon) {
    // Things starting with numbers are textual in their names too.
    const prefixMatch = identifierPrefixRewritePattern.exec(icon);
    if (prefixMatch) {
        const prefix = prefixMatch[0];
        const newPrefix = identifierPrefixRewrites[prefix];
        if (newPrefix)
            return `${newPrefix}${icon.slice(prefix.length)}`;
    }
    // Also try exact rewrites.
    const newIdentifier = identifierExactRewrites[icon];
    if (newIdentifier)
        return newIdentifier;
    return icon;
}


/***/ }),

/***/ 2125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDebugAdapterName = getDebugAdapterName;
exports.getDebugAdapterPort = getDebugAdapterPort;
const enums_1 = __webpack_require__(3962);
function getDebugAdapterName(debugType) {
    let debuggerName;
    switch (debugType) {
        case enums_1.DebuggerType.Flutter:
            debuggerName = "flutter";
            break;
        case enums_1.DebuggerType.FlutterTest:
            debuggerName = "flutter_test";
            break;
        case enums_1.DebuggerType.Web:
            debuggerName = "web";
            break;
        case enums_1.DebuggerType.WebTest:
            debuggerName = "web_test";
            break;
        case enums_1.DebuggerType.Dart:
            debuggerName = "dart";
            break;
        case enums_1.DebuggerType.DartTest:
            debuggerName = "dart_test";
            break;
        default:
            throw new Error(`Unknown debugger type: ${debugType}`);
    }
    return debuggerName;
}
function getDebugAdapterPort(debuggerName) {
    const debugAdapterNames = [
        "flutter",
        "flutter_test",
        "web",
        "web_test",
        "dart",
        "dart_test",
    ];
    const index = debugAdapterNames.indexOf(debuggerName);
    if (index === -1)
        throw new Error(`Unknown debugger type: ${debuggerName}`);
    return 4711 + index;
}


/***/ }),

/***/ 2524:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentCache = void 0;
const vscode_uri_1 = __webpack_require__(8945);
const fs_1 = __webpack_require__(2587);
class DocumentCache {
    data = new Map();
    get(uri) {
        return this.data.get(this.key(uri));
    }
    getForPath(filePath) {
        return this.get(vscode_uri_1.URI.file(filePath));
    }
    set(uri, value) {
        this.data.set(this.key(uri), value);
    }
    setForPath(filePath, value) {
        this.set(vscode_uri_1.URI.file(filePath), value);
    }
    has(uri) {
        return this.data.has(this.key(uri));
    }
    hasForPath(filePath) {
        return this.has(vscode_uri_1.URI.file(filePath));
    }
    delete(uri) {
        this.data.delete(this.key(uri));
    }
    deleteForPath(filePath) {
        this.delete(vscode_uri_1.URI.file(filePath));
    }
    clear() {
        this.data.clear();
    }
    get size() {
        return this.data.size;
    }
    values() {
        return this.data.values();
    }
    key(uri) {
        return (0, fs_1.uriComparisonString)(uri);
    }
}
exports.DocumentCache = DocumentCache;


/***/ }),

/***/ 6297:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineVisitorLsp = exports.FlutterOutlineVisitor = void 0;
class FlutterOutlineVisitor {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitor = FlutterOutlineVisitor;
class FlutterOutlineVisitorLsp {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitorLsp = FlutterOutlineVisitorLsp;


/***/ }),

/***/ 2587:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fsPath = fsPath;
exports.forceWindowsDriveLetterToUppercase = forceWindowsDriveLetterToUppercase;
exports.forceWindowsDriveLetterToUppercaseInUriString = forceWindowsDriveLetterToUppercaseInUriString;
exports.uriComparisonString = uriComparisonString;
exports.homeRelativePath = homeRelativePath;
exports.isWithinPath = isWithinPath;
exports.isWithinPathOrEqual = isWithinPathOrEqual;
exports.findCommonAncestorFolder = findCommonAncestorFolder;
exports.getChildFolders = getChildFolders;
exports.readDirAsync = readDirAsync;
exports.hasPackageMapFile = hasPackageMapFile;
exports.hasPubspec = hasPubspec;
exports.hasPubspecAsync = hasPubspecAsync;
exports.hasCreateTriggerFileAsync = hasCreateTriggerFileAsync;
exports.isFlutterRepoAsync = isFlutterRepoAsync;
exports.isFlutterProjectFolder = isFlutterProjectFolder;
exports.projectReferencesFlutter = projectReferencesFlutter;
exports.pubspecContentReferencesFlutter = pubspecContentReferencesFlutter;
exports.tryGetPackageName = tryGetPackageName;
exports.referencesBuildRunner = referencesBuildRunner;
exports.extractFlutterSdkPathFromPackagesFile = extractFlutterSdkPathFromPackagesFile;
exports.resolveTildePaths = resolveTildePaths;
exports.findProjectFolders = findProjectFolders;
exports.getSdkVersion = getSdkVersion;
exports.getPubGeneratorVersion = getPubGeneratorVersion;
exports.tryDeleteFile = tryDeleteFile;
exports.getRandomInt = getRandomInt;
exports.mkDirRecursive = mkDirRecursive;
exports.createFolderForFile = createFolderForFile;
exports.areSameFolder = areSameFolder;
exports.normalizeSlashes = normalizeSlashes;
exports.nextAvailableFilename = nextAvailableFilename;
const fs = __importStar(__webpack_require__(9896));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const semver = __importStar(__webpack_require__(9589));
const YAML = __importStar(__webpack_require__(1198));
const constants_1 = __webpack_require__(6709);
const logging_1 = __webpack_require__(5045);
const package_map_1 = __webpack_require__(1721);
const utils_1 = __webpack_require__(949);
const array_1 = __webpack_require__(3043);
function fsPath(uri, { useRealCasing = false } = {}) {
    // tslint:disable-next-line:disallow-fspath
    let newPath = typeof uri === "string" ? uri : uri.fsPath;
    if (useRealCasing) {
        const realPath = fs.existsSync(newPath) && fs.realpathSync.native(newPath);
        // Since realpathSync.native will resolve symlinks, only do anything if the paths differ
        // _only_ by case.
        // when there was no symlink (eg. the lowercase version of both paths match).
        if (realPath && realPath.toLowerCase() === newPath.toLowerCase() && realPath !== newPath) {
            console.warn(`Rewriting path:\n  ${newPath}\nto:\n  ${realPath} because the casing appears incorrect`);
            newPath = realPath;
        }
    }
    newPath = forceWindowsDriveLetterToUppercase(newPath);
    return newPath;
}
function forceWindowsDriveLetterToUppercase(p) {
    if (typeof p !== "string")
        return undefined;
    if (p && constants_1.isWin && path.isAbsolute(p) && p.startsWith(p.charAt(0).toLowerCase()))
        return p.substr(0, 1).toUpperCase() + p.substr(1);
    return p;
}
function forceWindowsDriveLetterToUppercaseInUriString(uriString) {
    if (typeof uriString !== "string")
        return undefined;
    return uriString.replace(/^([\w+-.]+):(\/\/\w*)?\/(\w)(:|%3A)\//, (match, scheme, authority, driveLetter, colon) => `${scheme}:${authority ?? ""}/${driveLetter.toUpperCase()}${colon}/`);
}
/**
 * Returns a string for comparing URIs. For file (and dart-macro+file) URIs this will
 * be `fsPath()` (including for fake paths for generated files) with a `file:` or `dart-macro+file`
 * prefix (this will NOT be a valid URI). On Windows, the string will be lowercased.
 * For other URIs, it is the toString().
 *
 * This string is ONLY for comparising URIs to see if they are "the same document".
 */
function uriComparisonString(uri) {
    if (uri.scheme === "file" || uri.scheme.endsWith("+file")) {
        const uriString = `${uri.scheme}:${fsPath(uri.with({ scheme: "file" }))}`;
        // VS Code treats Windows as case-insensitive and not others (regardless
        // of the actual file system settings).
        return constants_1.isWin ? uriString.toLowerCase() : uriString;
    }
    else {
        return uri.toString();
    }
}
/// Shortens a path to use ~ if it's inside the home directory and always
// uses forward slashes in that case.
function homeRelativePath(p) {
    if (!p)
        return undefined;
    const homedir = os.homedir();
    if (isWithinPath(p, homedir)) {
        if (constants_1.isWin)
            return path.join("~", path.relative(homedir, p)).replace(/\\/g, "/");
        else
            return path.join("~", path.relative(homedir, p));
    }
    return p;
}
function isWithinPath(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return !!relative && !relative.startsWith("..") && !path.isAbsolute(relative);
}
function isWithinPathOrEqual(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return relative === "" || (!!relative && !relative.startsWith("..") && !path.isAbsolute(relative));
}
function findCommonAncestorFolder(folderPaths) {
    if (!folderPaths.length)
        return undefined;
    const commonAncestorSegments = folderPaths[0].split(path.sep);
    for (const folderPath of folderPaths.slice(1)) {
        const pathSegments = folderPath.split(path.sep);
        for (let i = 0; i < Math.min(commonAncestorSegments.length, pathSegments.length); i++) {
            if (commonAncestorSegments[i] !== pathSegments[i]) {
                commonAncestorSegments.splice(i);
                break;
            }
        }
        if (commonAncestorSegments.length > pathSegments.length) {
            commonAncestorSegments.splice(pathSegments.length);
        }
    }
    // If we got up to the root, consider that not a match.
    if (commonAncestorSegments.length <= 1)
        return undefined;
    return commonAncestorSegments.join(path.sep);
}
async function getChildFolders(logger, parent, options) {
    if (!fs.existsSync(parent))
        return [];
    const files = await readDirAsync(logger, parent);
    return files.filter((f) => f.isDirectory())
        .filter((f) => f.name !== "bin" || (options && options.allowBin)) // Don't look in bin folders
        .filter((f) => f.name !== "cache" || (options && options.allowCache)) // Don't look in cache folders
        .map((item) => path.join(parent, item.name));
}
function readDirAsync(logger, folder) {
    return new Promise((resolve) => fs.readdir(folder, { withFileTypes: true }, (err, files) => {
        // We will generate errors if we don't have access to this folder
        // so just skip over it.
        if (err) {
            logger.warn(`Skipping folder ${folder} due to error: ${err}`);
            resolve([]);
        }
        else {
            resolve(files);
        }
    }));
}
function hasPackageMapFile(folder) {
    return fs.existsSync(path.join(folder, ".dart_tool", "package_config.json")) || fs.existsSync(path.join(folder, ".packages"));
}
function hasPubspec(folder) {
    return fs.existsSync(path.join(folder, "pubspec.yaml"));
}
async function hasPubspecAsync(folder) {
    return await fileExists(path.join(folder, "pubspec.yaml"));
}
async function hasCreateTriggerFileAsync(folder) {
    return await fileExists(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
}
async function isFlutterRepoAsync(folder) {
    return await fileExists(path.join(folder, "bin/flutter")) && await fileExists(path.join(folder, "bin/cache/dart-sdk"));
}
function isFlutterProjectFolder(folder) {
    return projectReferencesFlutter(folder);
}
function projectReferencesFlutter(folder) {
    if (folder && hasPubspec(folder)) {
        const pubspecPath = path.join(folder, "pubspec.yaml");
        try {
            const pubspecContent = fs.readFileSync(pubspecPath);
            return pubspecContentReferencesFlutter(pubspecContent.toString());
        }
        catch (e) {
            if (e?.code !== "ENOENT") // Don't warn for missing files.
                console.warn(`Failed to read ${pubspecPath}: ${e}`);
        }
    }
    return false;
}
function pubspecContentReferencesFlutter(content) {
    try {
        const yaml = YAML.parse(content.toString());
        return !!(yaml?.dependencies?.flutter
            || yaml?.dev_dependencies?.flutter
            || yaml?.dependencies?.sky_engine
            || yaml?.dev_dependencies?.sky_engine
            || yaml?.dependencies?.flutter_test
            || yaml?.dev_dependencies?.flutter_test
            || yaml?.dependencies?.flutter_goldens
            || yaml?.dev_dependencies?.flutter_goldens);
    }
    catch {
        return false;
    }
}
function tryGetPackageName(packageDirectory) {
    try {
        const yaml = YAML.parse(fs.readFileSync(path.join(packageDirectory, "pubspec.yaml")).toString());
        return yaml?.name ? yaml?.name : undefined;
    }
    catch {
        return undefined;
    }
}
function referencesBuildRunner(folder) {
    if (folder && hasPubspec(folder)) {
        const regex = new RegExp("build_runner\\s*:", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
function extractFlutterSdkPathFromPackagesFile(projectFolder) {
    if (!fs.existsSync(projectFolder))
        return undefined;
    let packagePath = package_map_1.PackageMap.loadForProject(logging_1.nullLogger, projectFolder).getPackagePath("flutter");
    if (!packagePath)
        return undefined;
    // Set windows slashes to / while manipulating.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\\/g, "/");
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Trim suffix we don't need.
    const pathSuffix = "/packages/flutter/lib/";
    if (packagePath.endsWith(pathSuffix)) {
        packagePath = packagePath.substr(0, packagePath.length - pathSuffix.length);
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Append bin if required.
    if (!packagePath.endsWith("/bin/")) {
        packagePath = packagePath + "bin/";
    }
    // Set windows paths back.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\//g, "\\");
        if (packagePath.startsWith("\\"))
            packagePath = packagePath.substring(1);
    }
    return packagePath;
}
async function fileExists(p) {
    try {
        await fs.promises.access(p);
        return true;
    }
    catch {
        return false;
    }
}
function resolveTildePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    return p;
}
// Walks a few levels down and returns all folders that look like project
// folders, such as:
// - have a pubspec.yaml
// - have a project create trigger file
// - are the Flutter repo root
async function findProjectFolders(logger, roots, excludedFolders, options, token) {
    const dartToolFolderName = `${path.sep}.dart_tool${path.sep}`;
    let previousLevelFolders = roots.slice();
    let allPossibleFolders = previousLevelFolders.slice();
    // Start at 1, as we already added the roots.
    const searchDepth = options.onlyWorkspaceRoots ? 1 : options.searchDepth;
    for (let i = 1; i < searchDepth; i++) {
        let nextLevelFolders = [];
        for (const folder of previousLevelFolders) {
            if (token.isCancellationRequested)
                break;
            nextLevelFolders = nextLevelFolders.concat(await getChildFolders(logger, folder));
        }
        allPossibleFolders = allPossibleFolders.concat(nextLevelFolders);
        previousLevelFolders = nextLevelFolders;
    }
    allPossibleFolders = allPossibleFolders
        .filter((f) => !f.includes(dartToolFolderName) && excludedFolders.every((ef) => !isWithinPathOrEqual(f, ef)));
    const projectFolderPromises = allPossibleFolders.map(async (folder) => ({
        exists: options && options.requirePubspec
            ? await hasPubspecAsync(folder)
            : options.onlyWorkspaceRoots || await hasPubspecAsync(folder) || await hasCreateTriggerFileAsync(folder) || await isFlutterRepoAsync(folder),
        folder,
    }));
    const projectFoldersChecks = await Promise.all(projectFolderPromises);
    const projectFolders = projectFoldersChecks
        .filter((res) => res.exists)
        .map((res) => res.folder);
    return options && options.sort
        ? (0, array_1.sortBy)(projectFolders, (p) => p.toLowerCase())
        : projectFolders;
}
function getSdkVersion(logger, { sdkRoot }) {
    if (!sdkRoot)
        return undefined;
    // Try to read the new JSON file for Flutter. Don't use exist checks as it races,
    // just try to read and see if we get contents.
    const jsonVersionFile = path.join(sdkRoot, "bin", "cache", "flutter.version.json");
    let jsonVersionFileContent;
    try {
        jsonVersionFileContent = fs.readFileSync(jsonVersionFile, "utf8").trim();
    }
    catch (e) {
    }
    if (jsonVersionFileContent) {
        let versionData;
        try {
            versionData = JSON.parse(jsonVersionFileContent);
        }
        catch (e) {
            logger.error(`${jsonVersionFile} existed, but could not be parsed as JSON (${e}): ${jsonVersionFileContent}, falling back to legacy file`);
        }
        if (versionData) {
            const flutterVersion = versionData.flutterVersion;
            if (typeof flutterVersion === "string") {
                const validVersion = (0, utils_1.nullToUndefined)(semver.valid(flutterVersion));
                if (validVersion) {
                    return validVersion;
                }
                else {
                    logger.error(`${jsonVersionFile} did not contain a valid "flutterVersion": ${jsonVersionFileContent}, falling back to legacy file`);
                }
            }
            else {
                logger.error(`${jsonVersionFile} did not contain a "flutterVersion": ${jsonVersionFileContent}, falling back to legacy file`);
            }
        }
    }
    const versionFile = path.join(sdkRoot, "version");
    if (!fs.existsSync(versionFile))
        return undefined;
    try {
        return (0, utils_1.nullToUndefined)(semver.valid(fs
            .readFileSync(versionFile, "utf8")
            .trim()
            .split("\n")
            .filter((l) => l)
            .filter((l) => l.trim().substr(0, 1) !== "#")
            .join("\n")
            .trim()));
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
function getPubGeneratorVersion(logger, packageMapPath, existsSync, readFileSync) {
    if (!existsSync(packageMapPath))
        return undefined;
    try {
        const content = readFileSync(packageMapPath);
        const data = JSON.parse(content);
        const version = data.generatorVersion;
        return (0, utils_1.nullToUndefined)(semver.valid(version));
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
function tryDeleteFile(filePath) {
    if (fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
        }
        catch {
            console.warn(`Failed to delete file ${path}.`);
        }
    }
}
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
function mkDirRecursive(folder) {
    const parent = path.dirname(folder);
    if (!fs.existsSync(parent))
        mkDirRecursive(parent);
    if (!fs.existsSync(folder))
        fs.mkdirSync(folder);
}
function createFolderForFile(file) {
    try {
        if (!file || !path.isAbsolute(file))
            return undefined;
        // Skip creation of paths with variables, we'll rely on them
        // being created after resolving.
        if (file?.includes("${")) {
            return file;
        }
        const folder = path.dirname(file);
        if (!fs.existsSync(folder))
            mkDirRecursive(folder);
        return file;
    }
    catch {
        console.warn(`Ignoring invalid file path ${file}`);
        return undefined;
    }
}
function areSameFolder(folder1, folder2) {
    // Trim any trailing path separators of either direction.
    folder1 = folder1.replace(/[\\/]+$/, "");
    folder2 = folder2.replace(/[\\/]+$/, "");
    return folder1 === folder2;
}
function normalizeSlashes(p) {
    return p.replace(/[\\/]/g, path.sep);
}
/**
 * Gets a unique path or filename for the specified {folderUri} location, appending a numerical value
 * between {prefix} and suffix, as required.
 *
 * A directory/file location will be generated from {prefix} with a trailing number (eg. `mydir1`) and
 * its existence will be checked; if it already exists, the number will be incremented and checked again.
 *
 * This will continue until a non-existent directory/file is available, or until the maxiumum search
 * limit (of 128) is reached.
 *
 * @param folder directory to check for existing directories or files.
 * @param prefix prefix of the directory/file
 * @param suffix suffix of the directory/file
 */
function nextAvailableFilename(folder, prefix, suffix = "") {
    // Set an upper bound on how many attempts we should make in getting a non-existent name.
    const maxSearchLimit = 128;
    for (let index = 1; index <= maxSearchLimit; index++) {
        const name = `${prefix}${index}${suffix}`;
        const fullPath = path.join(folder, name);
        if (!fs.existsSync(fullPath)) {
            // Name doesn't appear to exist on-disk and thus can be used - return it.
            return name;
        }
    }
    // We hit the search limit, so return {prefix}{index} (eg. mydir1) and allow the extension to
    // handle the already-exists condition if user doesn't change it manually.
    return `${prefix}1${suffix}`;
}


/***/ }),

/***/ 2959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassOutlineVisitor = exports.TestOutlineVisitor = exports.OutlineVisitor = void 0;
const test_1 = __webpack_require__(672);
class OutlineVisitor {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline?.element?.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "EXTENSION":
                this.visitExtension(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${outline?.element?.kind} (${outline?.element?.name})`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitExtension(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.OutlineVisitor = OutlineVisitor;
class TestOutlineVisitor extends OutlineVisitor {
    tests = [];
    names = [];
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.location)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        this.tests.push({
            file: outline.element.location.file,
            fullName,
            isGroup,
            length: outline.codeLength || outline.element.location.length,
            offset: outline.codeOffset || outline.element.location.offset,
        });
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.TestOutlineVisitor = TestOutlineVisitor;
class ClassOutlineVisitor extends OutlineVisitor {
    classes = [];
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.location || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeLength: outline.codeLength,
            codeOffset: outline.codeOffset,
            elementKind: outline.element.kind,
            length: outline.length,
            offset: outline.offset,
        });
    }
}
exports.ClassOutlineVisitor = ClassOutlineVisitor;


/***/ }),

/***/ 3248:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClassOutlineVisitor = exports.LspTestOutlineVisitor = exports.LspOutlineVisitor = void 0;
const test_1 = __webpack_require__(672);
class LspOutlineVisitor {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visitNode(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.element && outline.element.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "EXTENSION":
                this.visitExtension(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${outline && outline.element && outline.element.kind}`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitExtension(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.LspOutlineVisitor = LspOutlineVisitor;
class LspTestOutlineVisitor extends LspOutlineVisitor {
    file;
    constructor(logger, file) {
        super(logger);
        this.file = file;
    }
    tests = [];
    testsByLine = {};
    names = [];
    visit(outline) {
        this.tests.length = 0;
        for (const line of Object.keys(this.testsByLine)) {
            delete this.testsByLine[parseInt(line)];
        }
        super.visit(outline);
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const info = {
            file: this.file,
            fullName,
            isGroup,
            range,
        };
        this.tests.push(info);
        if (range) {
            if (!this.testsByLine[range.start.line])
                this.testsByLine[range.start.line] = [];
            this.testsByLine[range.start.line].push(info);
        }
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.LspTestOutlineVisitor = LspTestOutlineVisitor;
class LspClassOutlineVisitor extends LspOutlineVisitor {
    classes = [];
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.range || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeRange: outline.codeRange,
            elementKind: outline.element.kind,
            range: outline.range,
        });
    }
}
exports.LspClassOutlineVisitor = LspClassOutlineVisitor;


/***/ }),

/***/ 8146:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeDartSdkSettingIntoProject = writeDartSdkSettingIntoProject;
exports.writeFlutterTriggerFile = writeFlutterTriggerFile;
exports.writeFlutterSdkSettingIntoProject = writeFlutterSdkSettingIntoProject;
exports.writeSettingIntoProject = writeSettingIntoProject;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
function writeDartSdkSettingIntoProject(dartSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.sdkPath": dartSdkPath });
}
function writeFlutterTriggerFile(folderPath, triggerData) {
    const jsonString = triggerData ? JSON.stringify(triggerData) : "";
    fs.writeFileSync(path.join(folderPath, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE), jsonString);
}
function writeFlutterSdkSettingIntoProject(flutterSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.flutterSdkPath": flutterSdkPath });
}
function writeSettingIntoProject(projectFolder, settings) {
    const vsCodeFolder = path.join(projectFolder, ".vscode");
    const settingsFile = path.join(vsCodeFolder, "settings.json");
    if (!fs.existsSync(vsCodeFolder))
        fs.mkdirSync(vsCodeFolder);
    // The file should never exist, because the user has to select a new folder
    // to create projects. If it exists, something is wrong. We can't just load
    // the file, because VS Code settings file are not standard JSON (they can
    // have comments) so we don't want to try and deal with parsing them.
    if (fs.existsSync(settingsFile))
        return;
    fs.writeFileSync(settingsFile, JSON.stringify(settings, undefined, 4));
}


/***/ }),

/***/ 1902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvedPromise = void 0;
exports.waitFor = waitFor;
exports.resolvedPromise = Promise.resolve(true);
async function waitFor(action, checkEveryMilliseconds = 100, tryForMilliseconds = 10000, token) {
    let timeRemaining = tryForMilliseconds;
    while (timeRemaining > 0 && !(token && token.isCancellationRequested)) {
        const res = await action();
        if (res)
            return res;
        await new Promise((resolve) => setTimeout(resolve, checkEveryMilliseconds));
        timeRemaining -= checkEveryMilliseconds;
    }
}


/***/ }),

/***/ 672:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultTestFileContents = exports.createTestFileAction = void 0;
exports.getLaunchConfig = getLaunchConfig;
exports.makeRegexForTests = makeRegexForTests;
exports.getTestExecutionInfo = getTestExecutionInfo;
exports.getProgramString = getProgramString;
exports.getProgramPath = getProgramPath;
exports.getTestSelectionForNodes = getTestSelectionForNodes;
exports.getTestSelectionForNode = getTestSelectionForNode;
exports.getTestSelectionForOutline = getTestSelectionForOutline;
exports.defaultFlutterTestFileContents = defaultFlutterTestFileContents;
exports.defaultDartTestFileContents = defaultDartTestFileContents;
exports.extractTestNameFromOutline = extractTestNameFromOutline;
exports.isSetupOrTeardownTestName = isSetupOrTeardownTestName;
const path = __importStar(__webpack_require__(6928));
const vscode_uri_1 = __webpack_require__(8945);
const utils_1 = __webpack_require__(949);
const test_model_1 = __webpack_require__(5871);
const fs_1 = __webpack_require__(2587);
function getLaunchConfig(noDebug, path, testSelection, shouldRunTestByLine, runSkippedTests, template) {
    let programString = path;
    let toolArgs = [];
    if (template?.toolArgs)
        toolArgs = toolArgs.concat(template?.toolArgs);
    if (testSelection) {
        const execInfo = getTestExecutionInfo(programString, testSelection, shouldRunTestByLine);
        programString = getProgramString(execInfo.programUri);
        toolArgs.push(...execInfo.args);
    }
    if (runSkippedTests)
        toolArgs.push("--run-skipped");
    return Object.assign({
        // Trailing space is a workaround for https://github.com/microsoft/vscode/issues/100115
        name: "Tests ",
        noDebug,
        request: "launch",
        type: "dart",
    }, template, {
        args: template?.args,
        expectSingleTest: testSelection?.length === 1 && !testSelection[0].name.includes("$") && !testSelection[0].isGroup,
        program: programString,
        toolArgs,
    });
}
const regexEscapedInterpolationExpressionPattern = /\\\$(?:(?:\w+)|(?:\\\{.*\\\}))/g;
function makeRegexForTests(names) {
    const regexSegments = [];
    for (const name of names) {
        const prefix = "^";
        // We can't anchor to the end for groups, as we want them to run all children.
        const suffix = name.isGroup ? "" : "( \\(variant: .*\\))?$";
        let escapedName = (0, utils_1.escapeRegExp)(name.name);
        // Replace any literal newlines with \n because literals can cause
        // issues in the shell.
        // https://github.com/Dart-Code/Dart-Code/issues/4007
        escapedName = escapedName
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r");
        // If a test name contains interpolated expressions, passing the exact
        // name won't match. So we just replace them out with wildcards. We'll need
        // to do this after escaping for regex, to ensure the original expression
        // is escaped but our wildcard is not.
        const substitutedName = escapedName.replace(regexEscapedInterpolationExpressionPattern, ".*");
        regexSegments.push(`${prefix}${substitutedName}${suffix}`);
    }
    return regexSegments.join("|");
}
function getTestExecutionInfo(programPath, tests, shouldRunTestByLine) {
    if (shouldRunTestByLine && tests.length && tests.every((test) => test.position)) {
        return {
            // VS Code lines are 0-based, but Dart is 1-based.
            args: tests.slice(1).map(((test) => `${programPath}?line=${test.position.line + 1}`)),
            programUri: vscode_uri_1.URI.file(programPath).with({ query: `?line=${tests[0].position.line + 1}` }),
        };
    }
    return {
        args: ["--name", makeRegexForTests(tests)],
        programUri: vscode_uri_1.URI.file(programPath),
    };
}
function getProgramString(programUri) {
    return programUri.query ? `${(0, fs_1.fsPath)(programUri)}${programUri.query}` : (0, fs_1.fsPath)(programUri);
}
function getProgramPath(program) {
    return program.split("?")[0];
}
function getTestSelectionForNodes(nodes) {
    if (nodes.find((node) => node instanceof test_model_1.SuiteNode))
        return undefined;
    return nodes.map((node) => getTestSelectionForNode(node));
}
function getTestSelectionForNode(treeNode) {
    return { name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode, position: treeNode.range?.start };
}
function getTestSelectionForOutline(test) {
    // We only support running by lines for LSP because we don't have the position for DAS
    // without an async opening of the document (to map offset -> position).
    const position = "range" in test
        ? test.range.start
        : undefined;
    return { name: test.fullName, isGroup: test.isGroup, position };
}
const createTestFileAction = (file) => `Create ${path.basename(file)}`;
exports.createTestFileAction = createTestFileAction;
const defaultTestFileContents = (isFlutterProject, dartEscapedTestName) => isFlutterProject ? defaultFlutterTestFileContents(dartEscapedTestName) : defaultDartTestFileContents(dartEscapedTestName);
exports.defaultTestFileContents = defaultTestFileContents;
const defaultTestFileSelectionPlaceholder = "// TODO: Implement test";
function defaultFlutterTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('${dartEscapedTestName} ...', (tester) async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
function defaultDartTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:test/test.dart';

void main() {
  test('${dartEscapedTestName} ...', () async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
function extractTestNameFromOutline(elementName) {
    if (!elementName)
        return;
    // Strip off the function name/parent like test( or testWidget(
    const openParen = elementName.indexOf("(");
    const closeParen = elementName.lastIndexOf(")");
    if (openParen === -1 || closeParen === -1 || openParen >= closeParen)
        return;
    elementName = elementName.substring(openParen + 2, closeParen - 1);
    // For tests with variables, we often end up with additional quotes wrapped
    // around them...
    if ((elementName.startsWith("'") || elementName.startsWith('"')) && (elementName.endsWith("'") || elementName.endsWith('"')))
        elementName = elementName.substring(1, elementName.length - 1);
    return elementName;
}
function isSetupOrTeardownTestName(testName) {
    return !!((testName?.startsWith("(setUp") || testName?.startsWith("(tearDown")) && testName?.endsWith(")"));
}


/***/ }),

/***/ 5851:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processDartSdkRepository = processDartSdkRepository;
exports.processFuchsiaWorkspace = processFuchsiaWorkspace;
exports.processBazelWorkspace = processBazelWorkspace;
exports.tryProcessBazelFlutterConfig = tryProcessBazelFlutterConfig;
exports.simplifyVersion = simplifyVersion;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const constants_1 = __webpack_require__(6709);
function processDartSdkRepository(logger, config, dartSdkRoot, extensionConfig) {
    config.disableAutomaticPub = true;
    // The Dart SDKs tests cannot run using pkg:test, so force them to use the VM.
    config.supportsPackageTest = extensionConfig.experimentalTestRunnerInSdk;
    config.supportsDartRunTest = false;
}
function processFuchsiaWorkspace(logger, config, fuchsiaRoot, extensionConfig) {
    config.disableAutomaticPub = true;
    config.disableSdkUpdateChecks = true;
    config.disableDartToolingDaemon = true;
}
function processBazelWorkspace(logger, config, bazelWorkspaceRoot, extensionConfig) {
    config.disableAutomaticPub = true;
    config.disableSdkUpdateChecks = true;
    config.disableDartToolingDaemon = true;
    tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot);
}
function tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot) {
    // flutter.json does not support windows.
    if (constants_1.isWin)
        return;
    try {
        const flutterConfigPath = path.join(bazelWorkspaceRoot, "dart/config/ide/flutter.json");
        if (!fs.existsSync(flutterConfigPath))
            return;
        logger.info(`Loading Bazel Flutter config from ${flutterConfigPath}`);
        const flutterConfigJson = fs.readFileSync(flutterConfigPath, "utf8");
        const flutterConfig = JSON.parse(flutterConfigJson);
        function makeFullPath(relOrAbsolute) {
            if (!relOrAbsolute)
                return relOrAbsolute;
            if (path.isAbsolute(relOrAbsolute))
                return relOrAbsolute;
            return path.join(bazelWorkspaceRoot, relOrAbsolute);
        }
        function makeScript(relOrAbsolute, replacesArgs = 1) {
            if (relOrAbsolute) {
                return {
                    replacesArgs,
                    script: makeFullPath(relOrAbsolute),
                };
            }
        }
        config.forceFlutterWorkspace = true;
        config.forceFlutterDebug = true;
        config.skipFlutterInitialization = true;
        config.omitTargetFlag = true;
        config.startDevToolsServerEagerly = true;
        config.flutterVersion = constants_1.MAX_VERSION;
        config.flutterDevToolsScript = makeScript(flutterConfig.devToolsScript);
        config.flutterDaemonScript = makeScript(flutterConfig.daemonScript);
        config.flutterDoctorScript = makeScript(flutterConfig.doctorScript);
        config.flutterRunScript = makeScript(flutterConfig.runScript);
        config.flutterSdkHome = makeFullPath(flutterConfig.sdkHome);
        config.flutterTestScript = makeScript(flutterConfig.testScript);
        // TODO (helin24): This is a generic script that can be used with some of the Flutter commands, e.g. `debug_adapter`, `doctor`, and `daemon`.
        // We should eventually change over the other scripts to use this one to reduce the number of scripts needed.
        config.flutterToolsScript = makeScript(flutterConfig.toolsScript, 0);
        config.defaultDartSdk = makeFullPath(flutterConfig.defaultDartSdk);
        config.restartMacDaemonMessage = flutterConfig.restartMacDaemonMessage;
        config.localDeviceCommandAdviceMessage = flutterConfig.localDeviceCommandAdviceMessage;
        config.localMacWarningMessage = flutterConfig.localMacWarningMessage;
        config.supportsPackageTest = true;
        // It's not valid to run "dart run test:test --version" here. This means
        // that we won't ever enable any "new" package:test functionality
        // (see `DartTestCapabilities`). If in future we'd like to support that,
        // we could store a packageTestVersion here (like `flutterVersion` above)
        // or if the capabilities need to be enabled individually, hang a whole
        // `DartTestCapabilities` override here.
        config.supportsDartRunTest = false;
    }
    catch (e) {
        logger.error(e);
    }
}
// Cleans a version in the form x.y.z-foo.a.b.c into just
// x.y-foo to reduce the number of unique versions being recorded.
//
// To avoid trailing zeros being trimmed (eg. "3.10" being treated as the number
// 3.1), the version will actually be reported like "3.10.x" where x is literally "x"
// for all versions.
function simplifyVersion(rawVersion) {
    if (typeof rawVersion !== "string")
        return;
    const parts = rawVersion.split("-");
    const versionNumber = parts[0];
    const versions = versionNumber.split(".");
    const prereleasePart = parts.length > 1 ? parts[1] : undefined;
    let prereleaseTag;
    for (const knownName of ["beta", "alpha", "dev", "edge"]) {
        if (prereleasePart?.includes(knownName))
            prereleaseTag = knownName;
    }
    const cleanParts = [];
    if (versions[0].length)
        cleanParts.push(versions[0]);
    else
        cleanParts.push("0");
    if (versions.length > 1)
        cleanParts.push(`.${versions[1]}`);
    else
        cleanParts.push(`.x`);
    cleanParts.push(`.x`); // 0.0.x
    if (prereleaseTag)
        cleanParts.push(`-${prereleaseTag}`);
    else if (prereleasePart)
        cleanParts.push(`-pre`);
    return cleanParts.join("");
}


/***/ }),

/***/ 5706:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTML_MODE = exports.ANALYSIS_FILTERS = exports.ANALYSIS_OPTIONS_FILTER = exports.PUBSPEC_FILTER = exports.DART_MODE = exports.DART_LANGUAGE = void 0;
exports.DART_LANGUAGE = "dart";
exports.DART_MODE = [
    { language: exports.DART_LANGUAGE, scheme: "file" },
    { language: exports.DART_LANGUAGE, scheme: "dart-macro+file" },
];
exports.PUBSPEC_FILTER = { pattern: "**/pubspec.yaml", scheme: "file" };
exports.ANALYSIS_OPTIONS_FILTER = { pattern: "**/analysis_options.yaml", scheme: "file" };
exports.ANALYSIS_FILTERS = [
    ...exports.DART_MODE,
    exports.PUBSPEC_FILTER,
    exports.ANALYSIS_OPTIONS_FILTER,
];
exports.HTML_MODE = { language: "html", scheme: "file" };


/***/ }),

/***/ 136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTextDocumentContentProviderFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageclient_1 = __webpack_require__(99);
const events_1 = __webpack_require__(9495);
const utils_1 = __webpack_require__(949);
class DartTextDocumentContentProviderFeature {
    logger;
    client;
    dartCapabilities;
    disposables = [];
    constructor(logger, client, dartCapabilities) {
        this.logger = logger;
        this.client = client;
        this.dartCapabilities = dartCapabilities;
    }
    get feature() {
        const client = this.client;
        const dartCapabilities = this.dartCapabilities;
        const disposables = this.disposables;
        return {
            dispose() {
                (0, utils_1.disposeAll)(disposables);
            },
            fillClientCapabilities(capabilities) {
                capabilities.experimental ??= {};
                capabilities.experimental.supportsDartTextDocumentContentProvider = true;
                // TODO(dantup): Remove this legacy flag sometime after April 2024 as it was
                //  just for during dev in case the API needed to change (it did not).
                capabilities.experimental.supportsDartTextDocumentContentProviderEXP1 = true;
            },
            getState() {
                return { kind: "static" };
            },
            initialize(serverCapabilities) {
                const provider = serverCapabilities.experimental?.dartTextDocumentContentProvider;
                // Just because we're enabled does not mean the server necessarily supports it.
                if (provider?.schemes) {
                    const didChangeEmitter = new events_1.EventEmitter();
                    disposables.push(client.onNotification(DartTextDocumentContentDidChangeNotification.type, (n) => {
                        const uri = client.protocol2CodeConverter.asUri(n.uri);
                        didChangeEmitter.fire(uri);
                    }));
                    for (const scheme of provider?.schemes) {
                        const didChangeSchemeEmitter = new events_1.EventEmitter();
                        disposables.push(didChangeEmitter.listen((uri) => {
                            if (uri.scheme.toLowerCase() === scheme.toLowerCase()) {
                                didChangeSchemeEmitter.fire(uri);
                            }
                        }));
                        disposables.push(vscode_1.workspace.registerTextDocumentContentProvider(scheme, {
                            async provideTextDocumentContent(uri, token) {
                                const result = await client.sendRequest(DartTextDocumentContentProviderRequest.type, { uri: client.code2ProtocolConverter.asUri(uri) }, token);
                                return result?.content;
                            },
                            onDidChange: didChangeSchemeEmitter.event,
                        }));
                    }
                }
            },
        };
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartTextDocumentContentProviderFeature = DartTextDocumentContentProviderFeature;
class DartTextDocumentContentProviderRequest {
    static type = new vscode_languageclient_1.RequestType("dart/textDocumentContent");
}
class DartTextDocumentContentDidChangeNotification {
    static type = new vscode_languageclient_1.NotificationType("dart/textDocumentContentDidChange");
}


/***/ }),

/***/ 7976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLaunchConfigDefaultTemplate = getLaunchConfigDefaultTemplate;
exports.getTemplatedLaunchConfigs = getTemplatedLaunchConfigs;
exports.isTemplateOfType = isTemplateOfType;
const minimatch_1 = __webpack_require__(8722);
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
const debugTypeTokenRegex = new RegExp((0, utils_1.escapeRegExp)("${debugType}"), "gi");
/// Allows overriding the launch config used by Code Lens "Run"/"Debug", test runner, editor launch buttons, explorer context menu.
///
/// Tries to get the most specific config first (eg. using an explicit `noDebug` flag) and otherwise falls back to
/// a generic (no `noDebug` specified) one, injecting the value of `debug` inverted as `noDebug`.
function getLaunchConfigDefaultTemplate(documentUri, debug) {
    const runConfigs = vscode_1.workspace.getConfiguration("launch", documentUri).get("configurations") || [];
    const filePath = (0, fs_1.fsPath)(documentUri);
    const workspaceUri = vscode_1.workspace.getWorkspaceFolder(documentUri)?.uri;
    const workspacePath = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
    const validConfigs = runConfigs.filter((c) => c.type === "dart"
        && c.templateFor !== undefined && c.templateFor !== null
        && workspacePath ? (0, fs_1.isWithinPathOrEqual)(filePath, path.join(workspacePath, c.templateFor)) : false);
    const requiredNoDebugValue = !debug;
    const bestConfig = 
    // Try specific config first.
    validConfigs.find((c) => c.noDebug === requiredNoDebugValue)
        // Otherwise, look for one that doesn't specify noDebug.
        ?? validConfigs.find((c) => c.noDebug === undefined);
    return bestConfig ? { ...bestConfig, noDebug: requiredNoDebugValue } : undefined;
}
function getTemplatedLaunchConfigs(documentUri, fileType) {
    const runConfigs = vscode_1.workspace.getConfiguration("launch", documentUri).get("configurations") || [];
    const wantedTemplateTypes = [`run-${fileType}`, `debug-${fileType}`];
    const filePath = (0, fs_1.fsPath)(documentUri);
    const workspaceUri = vscode_1.workspace.getWorkspaceFolder(documentUri)?.uri;
    const workspacePath = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
    // Loop through each launch config and add the relevant templates. Configs may be
    // added multiple times if they have multiple template types.
    const runFileTemplates = [];
    for (const templateType of wantedTemplateTypes) {
        const relevantLaunchConfigs = runConfigs
            .filter((c) => c.type === "dart" && isTemplateOfType(c, templateType))
            .filter((c) => codeLensIsValidForFile(c.codeLens, workspacePath, filePath));
        for (const launchConfig of relevantLaunchConfigs) {
            runFileTemplates.push({
                ...launchConfig,
                name: (launchConfig.codeLens?.title || launchConfig.name || "${debugType}").replace(debugTypeTokenRegex, templateType.startsWith("run-") ? "Run" : "Debug"),
                noDebug: templateType.startsWith("run-"),
            });
        }
    }
    // If we didn't find any, try the defaults.
    if (!runFileTemplates.length) {
        const defaultRunTemplate = getLaunchConfigDefaultTemplate(documentUri, false);
        const defaultDebugTemplate = getLaunchConfigDefaultTemplate(documentUri, true);
        if (defaultRunTemplate)
            runFileTemplates.push({ ...defaultRunTemplate, name: "Run" });
        if (defaultDebugTemplate)
            runFileTemplates.push({ ...defaultDebugTemplate, name: "Debug" });
    }
    return runFileTemplates;
}
function codeLensIsValidForFile(codeLens, workspacePath, filePath) {
    if (!codeLens?.path)
        return true;
    // Handle globs.
    if (codeLens.path.startsWith("**/"))
        return (0, minimatch_1.minimatch)(filePath, codeLens.path, { dot: true });
    // Otherwise, withinPathOrEqual, which requires a workspacePath.
    return workspacePath ? (0, fs_1.isWithinPathOrEqual)(filePath, path.join(workspacePath, codeLens?.path)) : false;
}
function isTemplateOfType(config, templateType) {
    const template = config.codeLens?.for;
    return !!template && ((typeof template === "string" && template === templateType)
        || (Array.isArray(template) && template.includes(templateType)));
}


/***/ }),

/***/ 1105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDeviceManager = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
const utils_2 = __webpack_require__(1894);
const constants_1 = __webpack_require__(6709);
const enums_1 = __webpack_require__(3962);
const logging_1 = __webpack_require__(5045);
const processes_1 = __webpack_require__(4917);
const array_1 = __webpack_require__(3043);
const fs_1 = __webpack_require__(2587);
const utils_3 = __webpack_require__(1894);
class FlutterDeviceManager {
    logger;
    daemon;
    config;
    workspaceContext;
    extContext;
    daemonPortOverride;
    unresponsiveTimeoutPeriodSeconds = 5;
    subscriptions = [];
    statusBarItem;
    currentDevice;
    devices = [];
    emulators = [];
    knownEmulatorNames = {};
    onCurrentDeviceChangedEmitter = new vs.EventEmitter();
    onCurrentDeviceChanged = this.onCurrentDeviceChangedEmitter.event;
    onDevicesChangedEmitter = new vs.EventEmitter();
    onDevicesChanged = this.onDevicesChangedEmitter.event;
    onDeviceAddedEmitter = new vs.EventEmitter();
    onDeviceAdded = this.onDeviceAddedEmitter.event;
    onDeviceRemovedEmitter = new vs.EventEmitter();
    onDeviceRemoved = this.onDeviceRemovedEmitter.event;
    onDeviceChangedEmitter = new vs.EventEmitter();
    onDeviceChanged = this.onDeviceChangedEmitter.event;
    constructor(logger, daemon, config, workspaceContext, extContext, runIfNoDevices, daemonPortOverride) {
        this.logger = logger;
        this.daemon = daemon;
        this.config = config;
        this.workspaceContext = workspaceContext;
        this.extContext = extContext;
        this.daemonPortOverride = daemonPortOverride;
        this.statusBarItem = vs.window.createStatusBarItem("dartStatusFlutterDevice", vs.StatusBarAlignment.Right, 1);
        this.statusBarItem.name = "Flutter Device";
        this.statusBarItem.tooltip = "Flutter";
        this.statusBarItem.command = "flutter.selectDevice";
        this.statusBarItem.show();
        void this.updateStatusBar();
        // Force a request for emulators to stash their names, so we can display
        // the better name if the automatically-selected device happens to be an
        // emulator.
        this.getEmulators().then(() => this.updateStatusBar()).catch((e) => console.error(e));
        this.subscriptions.push(this.statusBarItem);
        daemon.registerForDeviceAdded(this.deviceAdded.bind(this));
        daemon.registerForDeviceRemoved(this.deviceRemoved.bind(this));
        if (runIfNoDevices) {
            setTimeout(() => {
                if (this.devices.length === 0) {
                    runIfNoDevices();
                }
            }, 10000);
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.subscriptions);
    }
    isSupported(types, device) {
        // types being `undefined` means we shouldn't filter, but being empty means we legit
        // don't support any types.
        return device && (!types || !device.platformType || types.includes(device.platformType));
    }
    isDevicePreferred(device) {
        const isPreferred = this.config.flutterRememberSelectedDevice
            && !!device
            && this.extContext.workspaceLastFlutterDeviceId === device.id;
        return isPreferred;
    }
    async deviceAdded(device) {
        device = { ...device, type: "device" };
        this.devices.push(device);
        // undefined is treated as true for backwards compatibility.
        let canAutoSelectDevice = device.ephemeral !== false || this.isDevicePreferred(device);
        const currentDeviceIsPreferred = this.isDevicePreferred(this.currentDevice);
        if (canAutoSelectDevice && this.rememberNextAddedDevice)
            this.rememberDevice(device);
        else if (canAutoSelectDevice && currentDeviceIsPreferred) {
            this.logger.info(`Will not auto-select ${device.name} because current device is preferred`);
            // Don't allow auto-selection if we have the remembered device selected.
            canAutoSelectDevice = false;
        }
        // In a remote workspace, allow selecting web-server over a non-ephemeral device so
        // that we don't seem to default to Linux on a remote we probably can't see.
        if (!utils_3.isRunningLocally && this.currentDevice?.ephemeral === false && device.id === "web-server")
            canAutoSelectDevice = true;
        const maySelectThisDevice = () => !this.currentDevice
            || (this.config.flutterSelectDeviceWhenConnected && canAutoSelectDevice)
            // HACK: If the Chrome device becomes available and the selected device is
            // web-server, allow switching because most users would prefer the Chrome device.
            // We can revert this in future if Flutter changes the order these devices show up
            // or has some other way of deciding priority.
            || (this.currentDevice?.id === "web-server" && device.id === "chrome" && !currentDeviceIsPreferred);
        if (maySelectThisDevice()) {
            // Finally, check if it's valid for the workspace. We don't want to
            // auto-select to a mobile if you have a web-only project open.
            const supportedPlatforms = await this.getSupportedPlatformsForWorkspace();
            // We need to re-check maySelectThisDevice() as the answer may have changed if
            // another device was selected while we were awaiting (which would prevent us
            // selecting a non-ephemeral device here).
            if (maySelectThisDevice() && this.isSupported(supportedPlatforms, device)) {
                this.setCurrentDevice(device);
            }
        }
        void this.updateStatusBar();
        this.onDeviceAddedEmitter.fire(device);
        this.onDevicesChangedEmitter.fire();
    }
    setCurrentDevice(device) {
        this.currentDevice = device;
        this.onCurrentDeviceChangedEmitter.fire(device);
        void this.updateStatusBar();
    }
    async deviceRemoved(dev) {
        this.devices = this.devices.filter((d) => d.id !== dev.id);
        if (this.currentDevice && this.currentDevice.id === dev.id) {
            let nextDevice;
            // Try to select the next-best device
            if (this.devices.length) {
                const supportedPlatforms = await this.getSupportedPlatformsForWorkspace();
                const supportedDevices = this.devices.filter((d) => this.isSupported(supportedPlatforms, d));
                if (supportedDevices && supportedDevices.length)
                    nextDevice = supportedDevices[0];
            }
            this.setCurrentDevice(nextDevice);
        }
        void this.updateStatusBar();
        this.onDeviceRemovedEmitter.fire(dev.id);
        this.onDevicesChangedEmitter.fire();
    }
    async showDevicePicker(supportedTypes) {
        // If we weren't passed any supported types, we should try to get them for
        // the whole workspace.
        if (!supportedTypes && this.daemon.capabilities.providesPlatformTypes) {
            supportedTypes = await this.getSupportedPlatformsForWorkspace();
        }
        const quickPick = vs.window.createQuickPick();
        quickPick.placeholder = "Select a device to use";
        quickPick.busy = true;
        quickPick.ignoreFocusOut = true;
        let quickPickIsValid = true;
        let emulatorDevices;
        const updatePickableDeviceList = () => {
            if (!quickPickIsValid)
                return;
            quickPick.items = this.getPickableDevices(supportedTypes, emulatorDevices);
        };
        // Kick off a request to get emulators only once.
        this.getPickableEmulators(true, supportedTypes)
            .then((emulators) => emulatorDevices = emulators)
            .finally(() => quickPick.busy = false)
            .finally(() => updatePickableDeviceList())
            .catch((e) => console.error(e));
        // If new devices are attached while the list is open, add them to the end.
        const deviceAddedSubscription = this.daemon.registerForDeviceAdded((d) => updatePickableDeviceList());
        const deviceRemovedSubscription = this.daemon.registerForDeviceRemoved((d) => updatePickableDeviceList());
        // Build the initial list.
        updatePickableDeviceList();
        const selection = await new Promise((resolve) => {
            quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0] /* Seperators can't be selected */));
            quickPick.onDidHide(() => resolve(undefined));
            quickPick.show();
        });
        quickPickIsValid = false;
        quickPick.dispose();
        await deviceAddedSubscription.dispose();
        await deviceRemovedSubscription.dispose();
        if (selection && await this.selectDevice(selection))
            return this.currentDevice;
        return undefined;
    }
    async selectDeviceById(id) {
        if (!id) {
            this.setCurrentDevice(undefined);
            return true;
        }
        const device = this.getDevice(id);
        if (device) {
            await this.selectDevice({
                device,
                label: this.labelForDevice(device, { withIcon: true }),
            });
            return true;
        }
        return false;
    }
    async selectDevice(selection) {
        const emulatorTypeLabel = this.emulatorLabel(selection.device.platformType);
        switch (selection.device.type) {
            case "emulator-creator":
                // Clear the current device so we can wait for the new one
                // to connect.
                this.setCurrentDevice(undefined);
                this.statusBarItem.text = `Creating ${emulatorTypeLabel}...`;
                this.rememberNextAddedDevice = true;
                await this.createEmulator();
                void this.updateStatusBar();
                break;
            case "emulator":
                // Clear the current device so we can wait for the new one
                // to connect.
                this.setCurrentDevice(undefined);
                this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                this.rememberNextAddedDevice = true;
                const coldBoot = selection.coldBoot ?? false;
                await this.launchEmulator(selection.device, coldBoot);
                void this.updateStatusBar();
                break;
            case "custom-emulator":
                // Clear the current device so we can wait for the new one
                // to connect.
                this.setCurrentDevice(undefined);
                this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                this.rememberNextAddedDevice = true;
                await this.launchCustomEmulator(selection.device);
                void this.updateStatusBar();
                break;
            case "platform-enabler":
                const platformType = selection.device.platformType;
                if (!await this.enablePlatformType(platformType))
                    return false;
                break;
            case "device":
                this.rememberDevice(selection.device);
                this.setCurrentDevice(selection.device);
                break;
        }
        return true;
    }
    async enablePlatformType(platformType) {
        const platformNeedsGloballyEnabling = await this.daemon.checkIfPlatformGloballyDisabled(platformType);
        const action = await vs.window.showInformationMessage((0, constants_1.runFlutterCreatePrompt)(platformType, platformNeedsGloballyEnabling), constants_1.yesAction, constants_1.cancelAction);
        if (action !== constants_1.yesAction)
            return false;
        if (platformNeedsGloballyEnabling)
            await this.daemon.enablePlatformGlobally(platformType);
        const createArgs = { platform: platformType };
        await vs.commands.executeCommand("_flutter.create", createArgs);
        if (platformNeedsGloballyEnabling) {
            const restartAction = "Reload";
            const chosenAction = await vs.window.showInformationMessage("You must reload after enabling a new platform", restartAction, constants_1.skipAction);
            if (chosenAction === restartAction) {
                void vs.commands.executeCommand("_dart.reloadExtension");
                return true;
            }
        }
        // Clear the cache before we fire the event, because otherwise we might
        // send a cached set of devices that don't take the newly-enabled platform
        // into account.
        this.shortCacheForSupportedPlatforms = undefined;
        for (const device of this.devices) {
            if (device.platformType === platformType)
                this.onDeviceChangedEmitter.fire(device);
        }
        this.onDevicesChangedEmitter.fire();
        return true;
    }
    /// Whether to remember the next added device as if it was explicitly selected.
    ///
    /// This is set after the user picks a non-device (like launch emulator) so it's treated as an explicitly selection.
    rememberNextAddedDevice = false;
    rememberDevice(device) {
        this.rememberNextAddedDevice = false;
        const deviceIdToRemember = this.config.flutterRememberSelectedDevice
            ? device.id
            : undefined;
        this.logger.info(`Saving ${deviceIdToRemember} as preferred device`);
        this.extContext.workspaceLastFlutterDeviceId = deviceIdToRemember;
    }
    shortCacheForSupportedPlatforms;
    getDevice(id) {
        return this.devices.find((d) => d.id === id);
    }
    getDevicesSortedByName() {
        return this.devices.sort(this.deviceSortComparer.bind(this));
    }
    getDevicesSortedByCurrentAndName() {
        return this.devices.sort(this.deviceCurrentSortComparer.bind(this));
    }
    async getValidDevicesForProject(projectFolder) {
        const sortedDevices = this.getDevicesSortedByCurrentAndName();
        const supportedPlatforms = this.daemon.capabilities.providesPlatformTypes
            ? (await this.tryGetSupportedPlatforms(projectFolder))?.platforms
            : undefined;
        return sortedDevices.filter((d) => this.isSupported(supportedPlatforms, d));
    }
    /// Calls the daemon's getSupportedPlatforms, but returns undefined if any error occurs (such as the process
    /// having exited) or there is no response within 5 seconds.
    async tryGetSupportedPlatforms(projectRoot) {
        return (0, utils_1.withTimeout)(this.daemon.daemonStarted.then(() => this.daemon.getSupportedPlatforms(projectRoot)), "The daemon did not respond to getSupportedPlatforms", this.unresponsiveTimeoutPeriodSeconds).then((result) => result, () => undefined);
    }
    getPickableDevices(supportedTypes, emulatorDevices) {
        const sortedDevices = this.getDevicesSortedByCurrentAndName();
        let pickableItems = [];
        const supportedDevices = sortedDevices.filter((d) => this.isSupported(supportedTypes, d));
        if (supportedDevices.length) {
            pickableItems = pickableItems.concat([
                {
                    kind: vs.QuickPickItemKind.Separator,
                    label: "Available Devices",
                },
                ...supportedDevices.map((d) => ({
                    description: `${d.id} - ${d.category || d.platform || ""}`,
                    detail: d === this.currentDevice ? "Current Device" : undefined,
                    device: d,
                    label: this.labelForDevice(d, { withIcon: true }),
                })),
            ]);
        }
        // If we've got emulators, add them to the list.
        if (emulatorDevices && emulatorDevices.length) {
            // Fliter out any emulators we know are running.
            const emulatorIdsAlreadyRunning = this.devices.map((d) => d.emulatorId).filter((id) => id);
            const emulatorDevicesNotRunning = emulatorDevices.filter((e) => !emulatorIdsAlreadyRunning.includes(e.device.id));
            if (emulatorDevicesNotRunning.length) {
                pickableItems = pickableItems.concat([
                    {
                        kind: vs.QuickPickItemKind.Separator,
                        label: "Offline Emulators",
                    },
                    ...emulatorDevicesNotRunning,
                ]);
            }
        }
        // Add any unsupported platforms that we have devices/emulators for (eg. things that could be
        // enabled) to the bottom.
        const potentialPlatformTypes = (0, utils_1.uniq)([
            ...sortedDevices.map((d) => d),
            ...this.emulators.map((e) => e),
        ]
            .filter((d) => !this.isSupported(supportedTypes, d))
            .map((d) => d.platformType)
            .filter(utils_1.notNullOrUndefined));
        if (potentialPlatformTypes.length) {
            pickableItems = pickableItems.concat([
                {
                    kind: vs.QuickPickItemKind.Separator,
                    label: "Other Available Platforms",
                },
                ...potentialPlatformTypes.map((p) => ({
                    device: { type: "platform-enabler", platformType: p },
                    label: `Enable ${p} for this project`,
                })),
            ]);
        }
        return pickableItems;
    }
    async getSupportedPlatformsForWorkspace() {
        // To avoid triggering this lots of times at startup when lots of devices "connect" at
        // the same time, we cache the results for 10 seconds. Every time we set the cache, we
        // set a timer to expire it in 10 seconds.
        if (this.shortCacheForSupportedPlatforms) {
            this.logger.info(`Returning cached promise for getSupportedPlatforms()`);
            return this.shortCacheForSupportedPlatforms;
        }
        this.shortCacheForSupportedPlatforms = new Promise(async (resolve) => {
            // An internal workspace that we assume to be Flutter will not generate project folders, but the daemon will respond to an empty path.
            const projectFolders = this.workspaceContext.config.forceFlutterWorkspace ? [""] : await (0, utils_2.getAllProjectFolders)(this.logger, undefined, { requirePubspec: true, searchDepth: this.config.projectSearchDepth });
            this.logger.info(`Checking ${projectFolders.length} projects for supported platforms`);
            const tryGet = (folder) => this.tryGetSupportedPlatforms(folder);
            const getPlatformPromises = projectFolders.map(async (folder) => {
                try {
                    const platforms = await tryGet(folder);
                    return platforms?.platforms ?? [];
                }
                catch (e) {
                    this.logger.error(e);
                    return [];
                }
            });
            const resps = await Promise.all(getPlatformPromises);
            const supportedTypes = (0, array_1.unique)((0, utils_1.flatMap)(resps, (r) => r));
            this.logger.info(`Supported platforms for the workspace are ${supportedTypes.join(", ")}`);
            resolve(supportedTypes);
            setTimeout(() => this.shortCacheForSupportedPlatforms = undefined, 10000);
        });
        return this.shortCacheForSupportedPlatforms;
    }
    labelForDevice(device, { withIcon = false } = {}) {
        let icon;
        switch (device.category) {
            case "mobile":
                icon = "$(device-mobile) ";
                break;
            case "web":
                icon = "$(browser) ";
                break;
            case "desktop":
                icon = "$(device-desktop) ";
        }
        const name = this.friendlyNameForDevice(device);
        return withIcon ? `${icon ?? ""}${name}` : name;
    }
    friendlyNameForDevice(device) {
        return device.emulatorId && this.knownEmulatorNames[device.emulatorId] && device.platformType === "android"
            ? this.knownEmulatorNames[device.emulatorId]
            : device.name;
    }
    deviceCurrentSortComparer(d1, d2) {
        // Always consider current device to be first.
        if (d1 === this.currentDevice)
            return -1;
        if (d2 === this.currentDevice)
            return 1;
        // Otherwise, sort by name.
        return d1.name.localeCompare(d2.name);
    }
    deviceSortComparer(d1, d2) {
        return d1.name.localeCompare(d2.name);
    }
    async updateStatusBar() {
        if (this.currentDevice) {
            const emulatorLabel = this.currentDevice.emulator ? this.emulatorLabel(this.currentDevice.platformType) : "";
            const platformLabel = `${this.currentDevice.platform} ${emulatorLabel}`.trim();
            this.statusBarItem.text = `${this.labelForDevice(this.currentDevice)} (${platformLabel})`.trim();
        }
        else {
            this.statusBarItem.text = "No Device";
        }
        const supportedPlatforms = await this.getSupportedPlatformsForWorkspace();
        const supportedDevices = this.devices.filter((d) => this.isSupported(supportedPlatforms, d));
        const suffix = supportedDevices.length === this.devices.length
            ? ""
            : supportedDevices.length === 1
                ? " (1 supported for workspace)"
                : ` (${supportedDevices.length} supported for workspace)`;
        if (this.devices.length > 1) {
            this.statusBarItem.tooltip = `${this.devices.length} Devices Connected${suffix}`;
        }
        else if (this.devices.length === 1) {
            this.statusBarItem.tooltip = `1 Device Connected${suffix}`;
        }
        else {
            this.statusBarItem.tooltip = undefined;
        }
    }
    async getEmulators() {
        try {
            await this.daemon.daemonStarted;
            const emus = await this.daemon.getEmulators();
            const allEmulatorsByID = {};
            loop1: for (const e of emus) {
                // Exclude any bogus-looking emulators until a Flutter fix ships.
                for (const field of [e.name, e.id]) {
                    const mayBeBogusEmulator = field?.includes("|")
                        && (field?.startsWith("INFO") || field?.startsWith("WARN") || field?.startsWith("ERR"));
                    if (mayBeBogusEmulator)
                        continue loop1;
                }
                allEmulatorsByID[e.id] = {
                    category: e.category,
                    id: e.id,
                    name: e.name || e.id,
                    platformType: e.platformType,
                    type: "emulator",
                };
            }
            // Add/update any custom emulators.
            for (const e of this.config.flutterCustomEmulators) {
                const existing = allEmulatorsByID[e.id];
                allEmulatorsByID[e.id] = {
                    category: "custom",
                    ...existing,
                    ...e,
                    type: "custom-emulator",
                };
            }
            const emulators = Object.values(allEmulatorsByID);
            this.emulators = emulators;
            // Whenever we see emulators, record all their names.
            for (const e of emulators)
                this.knownEmulatorNames[e.id] = e.name;
            return emulators;
        }
        catch (e) {
            this.logger.error({ message: e });
            return [];
        }
    }
    async promptForAndLaunchEmulator(allowAutomaticSelection = false) {
        const emulators = await this.getPickableEmulators(false);
        // Because the above call is async, it's possible a device was connected while we were calling. If so,
        // just use that instead of showing the prompt.
        if (allowAutomaticSelection && this.currentDevice)
            return true;
        if (emulators.length === 0) {
            return false;
        }
        const cancellationTokenSource = new vs.CancellationTokenSource();
        const waitingForRealDeviceSubscription = this.daemon.registerForDeviceAdded(() => {
            cancellationTokenSource.cancel();
            void waitingForRealDeviceSubscription.dispose();
        });
        const selectedEmulator = await vs.window.showQuickPick(emulators, {
            matchOnDescription: true,
            placeHolder: "Connect a device or select an emulator to launch",
        }, cancellationTokenSource.token);
        void waitingForRealDeviceSubscription.dispose();
        if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator-creator") {
            return this.createEmulator();
        }
        else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator") {
            const coldBoot = selectedEmulator.coldBoot ?? false;
            return this.launchEmulator(selectedEmulator.device, coldBoot);
        }
        else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "custom-emulator") {
            return this.launchCustomEmulator(selectedEmulator.device);
        }
        else {
            return !!(this.currentDevice);
        }
    }
    async createEmulator() {
        // TODO: Allow user to create names when we let them customise the emulator type.
        // const name = await vs.window.showInputBox({
        // 	prompt: "Enter a name for your new Android Emulator",
        // 	validateInput: this.validateEmulatorName,
        // });
        // if (!name) bail() // Pressing ENTER doesn't work, but escape does, so if
        // no name, user probably wanted to cancel
        const name = undefined;
        const create = this.daemon.createEmulator(name);
        void vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title: `${`Creating emulator ${name ? name : ""}`.trim()}...`,
        }, () => create);
        const res = await create;
        if (res.success) {
            return this.launchEmulator({
                id: res.emulatorName,
                name: res.emulatorName,
            }, false);
        }
        else {
            void vs.window.showErrorMessage(res.error);
            return false;
        }
    }
    emulatorLabel(platformType) {
        return platformType && (platformType === "ios" || platformType === "macos")
            ? "simulator"
            : "emulator";
    }
    async getPickableEmulators(showAsEmulators, supportedTypes) {
        if (this.config.flutterShowEmulators === "never")
            return [];
        if (this.config.flutterShowEmulators === "local" && !utils_3.isRunningLocally)
            return [];
        const pickableEmulators = [];
        const supportedEmulators = (await this.getEmulators()).filter((e) => this.isSupported(supportedTypes, e));
        for (const e of supportedEmulators) {
            const pickableEmulator = {
                alwaysShow: false,
                coldBoot: false,
                description: showAsEmulators ? `${e.category || "mobile"} ${this.emulatorLabel(e.platformType)}` : e.platformType || undefined,
                device: e,
                label: showAsEmulators ? "$(play) " + `Start ${e.name}` : e.name,
            };
            pickableEmulators.push(pickableEmulator);
            // Add a cold boot option for each android based emulator
            if (pickableEmulator.device.platformType && pickableEmulator.device.platformType === "android" && this.daemon.capabilities.supportsAvdColdBootLaunch) {
                pickableEmulators.push({
                    alwaysShow: pickableEmulator.alwaysShow,
                    coldBoot: true,
                    description: `${pickableEmulator.description} (cold boot)`,
                    device: pickableEmulator.device,
                    label: pickableEmulator.label,
                });
            }
        }
        // Add an option to create a new emulator if the daemon supports it.
        if (this.daemon.capabilities.canCreateEmulators && this.isSupported(supportedTypes, { platformType: "android" })) {
            pickableEmulators.push({
                alwaysShow: true,
                device: { type: "emulator-creator", platformType: "android", name: "Create Android emulator" },
                label: "$(plus) " + "Create Android emulator",
            });
        }
        return pickableEmulators;
    }
    async launchEmulator(emulator, coldBoot) {
        try {
            await vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
            }, async (progress) => {
                progress.report({ message: `Launching ${emulator.name}...` });
                await this.daemon.launchEmulator(emulator.id, coldBoot);
                progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                // Wait up to 60 seconds for emulator to launch.
                for (let i = 0; i < 120; i++) {
                    await new Promise((resolve) => setTimeout(resolve, 500));
                    if (this.currentDevice)
                        return;
                }
                throw new Error("Emulator didn't connect within 60 seconds");
            });
        }
        catch (e) {
            void vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
            return false;
        }
        // Wait an additional second to try and void some possible races.
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return true;
    }
    async launchCustomEmulator(emulator) {
        try {
            await vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
            }, async (progress) => {
                progress.report({ message: `Launching ${emulator.name}...` });
                const binPath = (0, fs_1.resolveTildePaths)(emulator.executable);
                const args = emulator.args || [];
                const env = emulator.env;
                const customEmulatorProc = (0, processes_1.safeSpawn)(undefined, binPath, args, env);
                this.logger.info(`(PROC ${customEmulatorProc.pid}) Spawned ${binPath} ${args.join(" ")}`, enums_1.LogCategory.CommandProcesses);
                (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, customEmulatorProc);
                progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                // Wait up to 60 seconds for emulator to launch.
                for (let i = 0; i < 120; i++) {
                    await new Promise((resolve) => setTimeout(resolve, 500));
                    if (this.currentDevice)
                        return;
                    if (customEmulatorProc.exitCode !== null && customEmulatorProc.exitCode !== 0) {
                        throw Error(`Exit code ${customEmulatorProc.exitCode}`);
                    }
                }
                throw new Error("Emulator didn't connect within 60 seconds");
            });
        }
        catch (e) {
            void vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
            return false;
        }
        // Wait an additional second to try and void some possible races.
        await new Promise((resolve) => setTimeout(resolve, 1000));
        return true;
    }
}
exports.FlutterDeviceManager = FlutterDeviceManager;


/***/ }),

/***/ 6305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findVisibleEditor = findVisibleEditor;
const vscode_1 = __webpack_require__(1398);
const fs_1 = __webpack_require__(2587);
function findVisibleEditor(uri) {
    const uriKey = (0, fs_1.uriComparisonString)(uri);
    return vscode_1.window.visibleTextEditors.find((e) => (0, fs_1.uriComparisonString)(e.document.uri) === uriKey);
}


/***/ }),

/***/ 6584:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.docsIconPathFormat = exports.hasFlutterExtension = exports.isDevExtension = exports.isPreReleaseExtension = exports.vsCodeVersionConstraint = exports.extensionVersion = exports.extensionPath = void 0;
exports.readJson = readJson;
exports.getExtensionVersionForReleaseNotes = getExtensionVersionForReleaseNotes;
exports.checkHasFlutterExtension = checkHasFlutterExtension;
exports.cleanDartdoc = cleanDartdoc;
exports.createMarkdownString = createMarkdownString;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const dartdoc = __importStar(__webpack_require__(8450));
exports.extensionPath = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier).extensionPath;
exports.extensionVersion = getExtensionVersion();
exports.vsCodeVersionConstraint = getVsCodeVersionConstraint();
exports.isPreReleaseExtension = checkIsPreReleaseExtension();
exports.isDevExtension = checkIsDevExtension();
exports.hasFlutterExtension = checkHasFlutterExtension();
exports.docsIconPathFormat = vscode_1.Uri.file(path.join(exports.extensionPath, "media/doc-icons/")).toString() + "$1%402x.png";
function readJson(file) {
    return JSON.parse(fs.readFileSync(file).toString());
}
function getExtensionVersion() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.version;
}
function getVsCodeVersionConstraint() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.engines.vscode;
}
function checkIsDevExtension() {
    return exports.extensionVersion.endsWith("-dev");
}
function checkIsPreReleaseExtension() {
    const segments = exports.extensionVersion.split(".");
    const minSegment = parseInt(segments[1]);
    return minSegment % 2 === 1;
}
function getExtensionVersionForReleaseNotes() {
    if (!exports.isPreReleaseExtension)
        return exports.extensionVersion;
    const segments = exports.extensionVersion.split(".");
    return `${segments[0]}.${parseInt(segments[1], 10) - 1}.0`;
}
function checkHasFlutterExtension() {
    return vscode_1.extensions.getExtension(constants_1.flutterExtensionIdentifier) !== undefined;
}
function cleanDartdoc(doc) {
    return dartdoc.cleanDartdoc(doc, exports.docsIconPathFormat);
}
function createMarkdownString(doc) {
    const md = new vscode_1.MarkdownString(doc);
    md.supportHtml = true;
    return md;
}


/***/ }),

/***/ 5913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFlutterSampleInTempFolder = createFlutterSampleInTempFolder;
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const vs = __importStar(__webpack_require__(1398));
const constants_1 = __webpack_require__(6709);
const fs_1 = __webpack_require__(2587);
const projects_1 = __webpack_require__(8146);
function createFlutterSampleInTempFolder(flutterCapabilities, sampleID, flutterSdkOverride) {
    // Ensure we're on at least Flutter v1 so we know creating samples works.
    if (!flutterCapabilities.supportsCreatingSamples) {
        void vs.window.showErrorMessage("Opening sample projects requires Flutter v1.0 or later");
        return;
    }
    // Create a temp folder for the sample.
    const tempSamplePath = path.join(os.tmpdir(), constants_1.dartCodeExtensionIdentifier, "flutter", "sample", sampleID, (0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16));
    // Create the empty folder so we can open it.
    (0, fs_1.mkDirRecursive)(tempSamplePath);
    const triggerData = { sample: sampleID };
    (0, projects_1.writeFlutterTriggerFile)(tempSamplePath, triggerData);
    // If we're using a custom SDK, we need to apply it to the new project too.
    if (flutterSdkOverride)
        (0, projects_1.writeFlutterSdkSettingIntoProject)(flutterSdkOverride, tempSamplePath);
    const folderUri = vs.Uri.file(tempSamplePath);
    void vs.commands.executeCommand("vscode.openFolder", folderUri);
    return folderUri;
}


/***/ }),

/***/ 7034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IconRangeComputerLsp = exports.IconRangeComputer = void 0;
const flutter_outline_1 = __webpack_require__(6297);
const utils_1 = __webpack_require__(1894);
class IconRangeComputer {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    compute(document, outline) {
        const iconVisitor = new FlutterOutlineIconVisitor(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.toRange)(document, icon.offset, icon.length));
        });
        return decs;
    }
}
exports.IconRangeComputer = IconRangeComputer;
class FlutterOutlineIconVisitor extends flutter_outline_1.FlutterOutlineVisitor {
    icons = [];
    materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
    cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueLocation) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "material", length: attribute.valueLocation.length });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "cupertino", length: attribute.valueLocation.length });
        }
    }
}
class IconRangeComputerLsp {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    compute(outline) {
        const iconVisitor = new FlutterOutlineIconVisitorLsp(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.lspToRange)(icon.range));
        });
        return decs;
    }
}
exports.IconRangeComputerLsp = IconRangeComputerLsp;
class FlutterOutlineIconVisitorLsp extends flutter_outline_1.FlutterOutlineVisitorLsp {
    icons = [];
    materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
    cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueRange) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "material" });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "cupertino" });
        }
    }
}


/***/ }),

/***/ 2679:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SupportedParameterKind = exports.InteractiveRefactors = void 0;
const vscode_1 = __webpack_require__(1398);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(949);
const fs_1 = __webpack_require__(2587);
class InteractiveRefactors {
    logger;
    dartCapabilities;
    static commandName = "_dart.interactiveRefactor";
    disposables = [];
    constructor(logger, dartCapabilities) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.disposables.push(vscode_1.commands.registerCommand(InteractiveRefactors.commandName, this.handleRefactor, this));
    }
    get feature() {
        const dartCapabilities = this.dartCapabilities;
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                capabilities.experimental ??= {};
                capabilities.experimental.dartCodeAction ??= {};
                // Originally server expected a `bool` for `commandParameterSupport` so we can only send
                // this object to new versions.
                if (dartCapabilities.supportsCommandParameterSupportedKinds) {
                    capabilities.experimental.dartCodeAction.commandParameterSupport = {
                        supportedKinds: Object.values(SupportedParameterKind),
                    };
                }
            },
            getState() {
                return { kind: "static" };
            },
            initialize() { },
        };
    }
    /// Rewrites any commands in `actions` that are interactive refactors to go through
    /// our own local command that can prompt the user before calling the server.
    rewriteCommands(actions) {
        for (const action of actions) {
            if (!("kind" in action))
                continue;
            const command = action.command;
            if (!command || !("command" in command))
                continue;
            if (!action.kind || !vscode_1.CodeActionKind.Refactor.contains(action.kind))
                continue;
            const originalCommandName = command.command;
            const argObject = this.getCommandArgumentObject(command.arguments);
            if (!argObject)
                continue;
            const parameters = this.getCommandParameters(action, argObject);
            if (!parameters)
                continue;
            command.command = InteractiveRefactors.commandName;
            command.arguments = [originalCommandName, parameters, argObject];
        }
    }
    /// Gets the parameters from the 'data' field of the CodeAction.
    getCommandParameters(action, argObject) {
        // 'data' is an LSP concept and not exposed in the VS Code type.
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const data = action.data;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const parameters = data?.parameters;
        // Check the parameters look sensible - a list with a length that matches the original
        // argument set.
        if (Array.isArray(parameters) && parameters.length === argObject.arguments.length)
            return parameters;
        return undefined;
    }
    /// Extract the single arguments object from the command arguments.
    ///
    /// For new refactors, command arguments are always a single object in the list
    /// which has named values (like 'file' and 'offset') as well as a well-known
    /// 'arguments' list which is updated by the interactive parameters.
    getCommandArgumentObject(args) {
        if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0].arguments)) {
            return args[0];
        }
    }
    async handleRefactor(command, parameters, originalArguments) {
        // Enumerate through each parameter and prompt the user.
        const paramValues = originalArguments.arguments.slice();
        for (let i = 0; i < parameters.length; i++) {
            let newValue = await this.promptUser(parameters[i]);
            // If no value, user cancelled so we should abort.
            if (!newValue)
                return;
            // Normalize to uppercase drive letters.
            if (constants_1.isWin && typeof newValue === "string" && (newValue.startsWith("file:///") || newValue.includes("+file:///"))) {
                newValue = (0, fs_1.forceWindowsDriveLetterToUppercaseInUriString)(newValue);
            }
            paramValues[i] = newValue;
        }
        // Do nothing yet.
        return vscode_1.commands.executeCommand(command, { ...originalArguments, arguments: paramValues });
    }
    /// Prompts the user for a value for `parameter`.
    ///
    /// If the user cancels, returns `undefined`.
    ///
    /// If the type of `parameter` is not supported, its default value.
    async promptUser(parameter) {
        if (SaveUriParameter.is(parameter)) {
            return (await this.promptUserSaveUri(parameter))?.toString();
        }
        else {
            this.logger.warn(`Unknown parameter kind ${parameter.kind}. Using default value (${parameter.defaultValue})`);
            return parameter.defaultValue;
        }
    }
    async promptUserSaveUri(parameter) {
        const uri = await vscode_1.window.showSaveDialog({
            defaultUri: parameter.defaultValue ? vscode_1.Uri.parse(parameter.defaultValue) : undefined,
            filters: parameter.filters,
            saveLabel: parameter.actionLabel,
            title: parameter.parameterTitle,
        });
        return uri;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.InteractiveRefactors = InteractiveRefactors;
var SupportedParameterKind;
(function (SupportedParameterKind) {
    SupportedParameterKind["saveUri"] = "saveUri";
})(SupportedParameterKind || (exports.SupportedParameterKind = SupportedParameterKind = {}));
var SaveUriParameter;
(function (SaveUriParameter) {
    function is(parameter) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
        return parameter.kind === SupportedParameterKind.saveUri;
    }
    SaveUriParameter.is = is;
})(SaveUriParameter || (SaveUriParameter = {}));


/***/ }),

/***/ 8683:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonCapabilitiesFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const constants_contexts_1 = __webpack_require__(4471);
class CommonCapabilitiesFeature {
    get feature() {
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                capabilities.experimental = capabilities.experimental ?? {};
                // Set an explicit flag to let the server know we support the window/showMessage request
                // because there's no existing capability for this (yet) and some client do not support it.
                // https://github.com/microsoft/language-server-protocol/issues/1635
                capabilities.experimental.supportsWindowShowMessageRequest = true;
                capabilities.experimental.commands = [
                    "dart.goToLocation",
                ];
            },
            getState() {
                return { kind: "static" };
            },
            initialize(capabilities) {
                // Track known commands (that we might care about) so we can
                // clear the contexts when we re-initialize so if you switch to an
                // older SDK we handle it correctly.
                const knownCommands = [
                    "dart.edit.sortMembers",
                    "dart.edit.organizeImports",
                    "dart.edit.fixAll",
                    "dart.edit.fixAllInWorkspace.preview",
                    "dart.edit.fixAllInWorkspace",
                    "dart.edit.sendWorkspaceEdit",
                ];
                const supportedCommands = capabilities.executeCommandProvider?.commands;
                if (supportedCommands) {
                    const supportedCommandsSet = new Set(supportedCommands);
                    for (const command of knownCommands) {
                        void vscode_1.commands.executeCommand("setContext", `${constants_contexts_1.LSP_COMMAND_CONTEXT_PREFIX}${command}`, supportedCommandsSet.has(command));
                    }
                }
                // Track known requests.
                const textDocumentRequests = capabilities.experimental?.textDocument;
                if (textDocumentRequests) {
                    // TODO(dantup): These might not be unset if you downgrade to an old SDK and we silent-restart.
                    for (const requestName of Object.keys(textDocumentRequests)) {
                        void vscode_1.commands.executeCommand("setContext", `${constants_contexts_1.LSP_REQUEST_CONTEXT_PREFIX}dart.textDocument.${requestName}`, true);
                    }
                }
            },
        };
    }
}
exports.CommonCapabilitiesFeature = CommonCapabilitiesFeature;


/***/ }),

/***/ 4601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspUriConverters = void 0;
const vs = __importStar(__webpack_require__(1398));
const fs_1 = __webpack_require__(2587);
class LspUriConverters {
    normalizeFileCasing;
    constructor(normalizeFileCasing) {
        this.normalizeFileCasing = normalizeFileCasing;
    }
    code2Protocol(uri) {
        // VS Code lowercases drive letters in Uris (even if they're not file scheme!) so we need to replace in the outbound URI too until the
        // server is case-insensitive for drive letters.
        if (uri.scheme === "file")
            uri = vs.Uri.file((0, fs_1.fsPath)(uri, { useRealCasing: this.normalizeFileCasing }));
        const uriString = uri.toString();
        return uriString.replace(/^([\w+-.]+):(\/\/\w*)?\/(\w)(:|%3A)\//, (match, scheme, authority, driveLetter, colon) => `${scheme}:${authority ?? ""}/${driveLetter.toUpperCase()}${colon}/`);
    }
    protocol2Code(file) {
        return vs.Uri.parse(file);
    }
}
exports.LspUriConverters = LspUriConverters;


/***/ }),

/***/ 5372:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIconForSymbolKind = getIconForSymbolKind;
const vs = __importStar(__webpack_require__(1398));
const iconsForKind = {
    [vs.SymbolKind.Array]: "indexer",
    [vs.SymbolKind.Boolean]: "boolean",
    [vs.SymbolKind.Class]: "class",
    [vs.SymbolKind.Constant]: "constant",
    [vs.SymbolKind.Constructor]: "method",
    [vs.SymbolKind.Enum]: "enumerator",
    [vs.SymbolKind.EnumMember]: "enumerator-item",
    [vs.SymbolKind.Event]: "event",
    [vs.SymbolKind.Field]: "field",
    [vs.SymbolKind.File]: "file",
    [vs.SymbolKind.Function]: "method",
    [vs.SymbolKind.Interface]: "interface",
    [vs.SymbolKind.Key]: "string",
    [vs.SymbolKind.Method]: "method",
    [vs.SymbolKind.Module]: "namespace",
    [vs.SymbolKind.Namespace]: "namespace",
    [vs.SymbolKind.Null]: "boolean", // 🤷‍♂️ https://github.com/microsoft/vscode/blob/a6ee65e647e6eeb1b6926d4100276e7afff14510/src/vs/editor/contrib/documentSymbols/media/symbol-icons.css#L107
    [vs.SymbolKind.Number]: "numeric",
    [vs.SymbolKind.Object]: "namespace",
    [vs.SymbolKind.Operator]: "operator",
    [vs.SymbolKind.Package]: "namespace",
    [vs.SymbolKind.Property]: "property",
    [vs.SymbolKind.String]: "string",
    [vs.SymbolKind.Struct]: "structure",
    [vs.SymbolKind.TypeParameter]: "type-parameter",
    [vs.SymbolKind.Variable]: "variable",
};
function getIconForSymbolKind(kind) {
    return iconsForKind[kind] || "field";
}


/***/ }),

/***/ 8296:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPubWorkspaceStatus = getPubWorkspaceStatus;
exports.isValidPubGetTarget = isValidPubGetTarget;
exports.promptToRunPubGet = promptToRunPubGet;
exports.runPubGet = runPubGet;
exports.promptToRunPubUpgrade = promptToRunPubUpgrade;
exports.runPubUpgrade = runPubUpgrade;
const fs = __importStar(__webpack_require__(9896));
const path = __importStar(__webpack_require__(6928));
const semver = __importStar(__webpack_require__(9589));
const vscode_1 = __webpack_require__(1398);
const YAML = __importStar(__webpack_require__(1198));
const package_map_1 = __webpack_require__(1721);
const fs_1 = __webpack_require__(2587);
const pubspecHasDependenciesRegex = new RegExp("^(dev_)?dependencies\\s*:", "im");
const pubspecIsWorkspaceProjectRegex = new RegExp("^resolution\\s*:\\s*workspace", "im");
const pubspecIsWorkspaceRootRegex = new RegExp("^workspace\\s*:", "im");
function getPubWorkspaceStatus(sdks, logger, folderUris, includeDates = true, existsSync = fs.existsSync, readFileSync = (p) => fs.readFileSync(p, "utf8").toString(), mtimeSync = (p) => fs.statSync(p).mtime) {
    // Compute the statuses for the requested packages.
    const statuses = folderUris.map((folderUri) => getPubPackageStatus(sdks, logger, folderUri, includeDates, existsSync, readFileSync, mtimeSync));
    // For any workspace projects, we need to also check their roots if they were not already in the initial set.
    const workspaceProjects = statuses.filter((s) => s.workspace === "PROJECT");
    if (workspaceProjects.length) {
        logger.info(`Found ${workspaceProjects.length} Pub workspace projects with roots that are not already in the set`);
        const includedWorkspaceRootPaths = new Set();
        statuses.filter((s) => s.workspace === "ROOT").forEach((p) => includedWorkspaceRootPaths.add((0, fs_1.fsPath)(p.folderUri)));
        projectLoop: for (const project of workspaceProjects) {
            const folderPath = (0, fs_1.fsPath)(project.folderUri);
            let currentFolder = path.dirname(folderPath);
            while (true) {
                // First check if the current folder is already a root we know about.
                if (includedWorkspaceRootPaths.has(currentFolder)) {
                    continue projectLoop;
                }
                // Otherwise, see if it is actually the root.
                let isRoot = false;
                try {
                    isRoot = pubspecIsWorkspaceRootRegex.test(readFileSync(path.join(currentFolder, "pubspec.yaml")));
                }
                catch {
                    // File may not exist, but using exists first is a race, so just try to read and ignore failure.
                }
                if (isRoot) {
                    logger.info(`Found new Pub workspace root at ${currentFolder}`);
                    // We found the root, add the result and to our set so we don't repeat this work.
                    statuses.push(getPubPackageStatus(sdks, logger, vscode_1.Uri.file(currentFolder), includeDates, existsSync, readFileSync, mtimeSync));
                    includedWorkspaceRootPaths.add(currentFolder);
                    continue projectLoop;
                }
                // Otherwise, try the next folder up.
                const parent = path.dirname(currentFolder);
                if (parent === currentFolder) {
                    logger.warn(`Failed to find a Pub workspace root for project at ${folderPath} before getting to root folder`);
                    continue projectLoop;
                }
                currentFolder = parent;
            }
        }
    }
    return statuses;
}
function getWorkspaceFolderPaths(logger, folder, pubspecContent) {
    try {
        const yaml = YAML.parse(pubspecContent);
        const workspaceList = yaml.workspace;
        if (Array.isArray(workspaceList) && workspaceList.every((s) => typeof s === "string")) {
            return workspaceList.map((s) => path.join(folder, s));
        }
        else {
            logger.error(`Failed to parse pubspec workspaces, items are not all strings`);
            return [];
        }
    }
    catch (e) {
        logger.error(`Failed to parse pubspec workspaces`);
        return [];
    }
}
function isValidPubGetTarget(folderUri) {
    const folderPath = (0, fs_1.fsPath)(folderUri);
    // If a folder starts with '__' or '{' then it's probably a template of some
    // sort and we shouldn't run.
    if (folderPath.includes("__") || folderPath.includes("{"))
        return { valid: false, reason: "Folder includes __ or { and looks like a template folder" };
    return { valid: true };
}
function getPubPackageStatus(sdks, logger, folderUri, includeDatesAndFullPaths = true, existsSync = fs.existsSync, readFileSync = (p) => fs.readFileSync(p, "utf8").toString(), mtimeSync = (p) => fs.statSync(p).mtime) {
    const folder = (0, fs_1.fsPath)(folderUri);
    const pubspecPath = path.join(folder, "pubspec.yaml");
    const pubspecLockPath = path.join(folder, "pubspec.lock");
    const packageMapPath = path.join(folder, ".dart_tool", "package_config.json");
    if (!folder || !existsSync(pubspecPath))
        return { folderUri, pubRequired: false, reason: "Folder or pubspec do not exist", workspace: "NONE" };
    const isValid = isValidPubGetTarget(folderUri);
    if (!isValid.valid)
        return { folderUri, pubRequired: false, reason: isValid.reason, workspace: "NONE" };
    const pubspecContent = readFileSync(pubspecPath);
    const hasDependencies = pubspecHasDependenciesRegex.test(pubspecContent);
    const isWorkspaceProject = pubspecIsWorkspaceProjectRegex.test(pubspecContent);
    const isWorkspaceRoot = pubspecIsWorkspaceRootRegex.test(pubspecContent);
    const result = { folderUri, workspace: isWorkspaceRoot ? "ROOT" : isWorkspaceProject ? "PROJECT" : "NONE" };
    // If we don't appear to have deps listed in pubspec, then no point prompting.
    if (!isWorkspaceRoot && !hasDependencies)
        return { ...result, pubRequired: false, reason: "Pubspec does not contain any dependencies" };
    // If we are part of a pub workspace, we don't do anything, it's handled by the root.
    if (isWorkspaceProject)
        return { ...result, pubRequired: false, reason: "The project is part of a Pub workspace" };
    // If we don't have package_config, we probably need running.
    if (!existsSync(packageMapPath))
        return { ...result, pubRequired: "GET", reason: "The .dart_tool/package_config.json file is missing" };
    // If the Dart SDK version has upgraded by more than just a patch, we should
    // prefer upgrade.
    const lastUsedSdkVersion = (0, fs_1.getPubGeneratorVersion)(logger, packageMapPath, existsSync, readFileSync);
    const currentSdkVersion = sdks.dartVersion;
    if (lastUsedSdkVersion && currentSdkVersion) {
        const lastUsedSdkMajorMinor = `${semver.major(lastUsedSdkVersion)}.${semver.minor(lastUsedSdkVersion)}.0`;
        const currentSdkMajorMinor = `${semver.major(currentSdkVersion)}.${semver.minor(currentSdkVersion)}.0`;
        logger.info(`Version last used for Pub is ${lastUsedSdkVersion} (${lastUsedSdkMajorMinor}), current is ${currentSdkVersion} (${currentSdkMajorMinor})`);
        // For an SDK upgrade, we want to encourage upgrading.
        if (semver.gt(currentSdkMajorMinor, lastUsedSdkMajorMinor))
            return { ...result, pubRequired: "UPGRADE", reason: `The current SDK version (${currentSdkVersion}) is newer than the one last used to run "pub get" (${lastUsedSdkVersion})` };
        // For a downgrade, Pub Get is enough to fix.
        else if (semver.lt(currentSdkMajorMinor, lastUsedSdkMajorMinor))
            return { ...result, pubRequired: "GET", reason: `The current SDK version (${currentSdkVersion}) is older than the one last used to run "pub get" (${lastUsedSdkVersion})` };
    }
    // Helpers for Date/Paths so that output is complete for production, but simplified for tests.
    const tryMtimeSync = (f) => { try {
        return mtimeSync(f);
    }
    catch {
        return undefined;
    } };
    const maybeDate = includeDatesAndFullPaths
        ? (d) => ` (${d})`
        : (_) => "";
    const displayPath = includeDatesAndFullPaths
        ? (p) => p
        : (p) => path.basename(p) === "package_config.json" ? `${path.basename(path.dirname(path.dirname(p)))}/${path.basename(path.dirname(p))}/${path.basename(p)}` : `${path.basename(path.dirname(p))}/${path.basename(p)}`;
    const pubspecLockModified = tryMtimeSync(pubspecLockPath);
    const packageMapModified = tryMtimeSync(packageMapPath);
    if (pubspecLockModified && packageMapModified && pubspecLockModified > packageMapModified) {
        return { ...result, pubRequired: "GET", reason: `The ${displayPath(pubspecLockPath)} file was modified${maybeDate(pubspecLockModified)} more recently than the ${displayPath(packageMapPath)} file${maybeDate(packageMapModified)}` };
    }
    const relevantProjectFolders = isWorkspaceRoot ? [folder, ...getWorkspaceFolderPaths(logger, folder, pubspecContent)] : [folder];
    for (const relevantProjectFolder of relevantProjectFolders) {
        const relevantPubspecYamlPath = path.join(relevantProjectFolder, "pubspec.yaml");
        const pubspecModified = tryMtimeSync(relevantPubspecYamlPath);
        if (!pubspecModified)
            continue;
        if (packageMapModified && pubspecModified > packageMapModified) {
            return { ...result, pubRequired: "GET", reason: `The ${displayPath(relevantPubspecYamlPath)} file was modified${maybeDate(pubspecModified)} more recently than the ${displayPath(packageMapPath)} file${maybeDate(packageMapModified)}` };
        }
        else if (pubspecLockModified && pubspecModified > pubspecLockModified) {
            return { ...result, pubRequired: "GET", reason: `The ${displayPath(relevantPubspecYamlPath)} file was modified${maybeDate(pubspecModified)} more recently than the ${displayPath(pubspecLockPath)} file${maybeDate(pubspecLockModified)}` };
        }
    }
    // If we're a Flutter project and our SDK doesn't match the one used
    // in the package file, we also need running.
    if (sdks.flutter) {
        const packageMap = package_map_1.PackageMap.loadForProject(logger, folder);
        const flutterPackagePath = packageMap.getPackagePath("flutter");
        if (flutterPackagePath && !(0, fs_1.isWithinPath)(flutterPackagePath, sdks.flutter)) {
            return { ...result, pubRequired: "GET", reason: `The referenced Flutter package (${flutterPackagePath}) does not match the current SDK in use (${sdks.flutter})` };
        }
    }
    return { ...result, pubRequired: false, reason: "Up-to-date" };
}
async function promptToRunPubGet(folders) {
    const label = "Run 'pub get'";
    const clickedButton = await vscode_1.window.showInformationMessage("Some packages are missing or out of date, would you like to get them now?", label);
    if (clickedButton === label)
        await runPubGet(folders);
}
function runPubGet(folders) {
    return vscode_1.commands.executeCommand("dart.getPackages", folders);
}
async function promptToRunPubUpgrade(folders) {
    const label = "Run 'pub upgrade'";
    const clickedButton = await vscode_1.window.showInformationMessage("Your SDK has been updated since you last fetched packages, would you like to fetch updated packages?", label);
    if (clickedButton === label)
        await runPubUpgrade(folders);
}
function runPubUpgrade(folders) {
    return vscode_1.commands.executeCommand("dart.upgradePackages", folders);
}


/***/ }),

/***/ 719:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLanguageStatusItem = getLanguageStatusItem;
const vs = __importStar(__webpack_require__(1398));
const statusBars = {};
function getLanguageStatusItem(id, selector) {
    return statusBars[id] ?? (statusBars[id] = vs.languages.createLanguageStatusItem(id, selector));
}


/***/ }),

/***/ 494:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findPackageUriLinks = findPackageUriLinks;
exports.findFileUriLinks = findFileUriLinks;
exports.formatLineColFragment = formatLineColFragment;
const vs = __importStar(__webpack_require__(1398));
const fileUriPattern = new RegExp("(?<uri>file:\\/{3}\\S+[\\/]\\S+\\.dart)(?:(?:[: ]| line )(?<line>\\d+)(?::(?<col>\\d+))?)?", "mg");
const packageUriPattern = new RegExp("(?<uri>package:\\S+[\\/]\\S+\\.dart)(?:(?:[: ]| line )(?<line>\\d+)(?::(?<col>\\d+))?)?", "mg");
async function findPackageUriLinks(content, isKnownPackage) {
    const results = [];
    packageUriPattern.lastIndex = -1;
    let result;
    // tslint:disable-next-line: no-conditional-assignment
    while ((result = packageUriPattern.exec(content)) && result.groups) {
        let uri;
        try {
            uri = vs.Uri.parse(result.groups.uri, true);
        }
        catch (e) {
            continue;
        }
        if (!uri)
            continue;
        const packageName = uri.path.split("/")[0];
        if (!isKnownPackage(packageName))
            continue;
        const line = result.groups.line ? parseInt(result.groups.line) : undefined;
        const col = result.groups.col ? parseInt(result.groups.col) : undefined;
        const startIndex = result.index;
        const length = result[0].length;
        results.push({
            col,
            length,
            line,
            packageName,
            startIndex,
            tooltip: "Open file in editor",
            uri: result.groups.uri,
        });
    }
    return results;
}
async function findFileUriLinks(line) {
    const results = [];
    fileUriPattern.lastIndex = -1;
    let result;
    // tslint:disable-next-line: no-conditional-assignment
    while ((result = fileUriPattern.exec(line)) && result.groups) {
        let uri;
        try {
            uri = vs.Uri.parse(result.groups.uri, true);
        }
        catch (e) {
            continue;
        }
        if (!uri)
            continue;
        const line = result.groups.line ? parseInt(result.groups.line) : undefined;
        const col = result.groups.col ? parseInt(result.groups.col) : undefined;
        const startIndex = result.index;
        const length = result[0].length;
        results.push({
            col,
            length,
            line,
            startIndex,
            tooltip: "Open file in editor",
            uri,
        });
    }
    return results;
}
function formatLineColFragment(link) {
    if (link.line !== undefined && link.col !== undefined)
        return `${link.line},${link.col}`;
    else if (!link.line !== undefined)
        return `${link.line}`;
    else
        return "";
}


/***/ }),

/***/ 2834:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOffsetTracker = exports.DocumentPositionTracker = void 0;
const vs = __importStar(__webpack_require__(1398));
const utils_1 = __webpack_require__(949);
class DocumentPositionTracker {
    disposables = [];
    tracker = new DocumentOffsetTracker();
    positionMap = new Map();
    onPositionsChangedEmitter = new vs.EventEmitter();
    onPositionsChanged = this.onPositionsChangedEmitter.event;
    constructor() {
        this.disposables.push(this.tracker);
        this.tracker.onOffsetsChanged(([doc, offsets]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newPositions = new Map();
            for (const position of this.positionMap.keys()) {
                const currentOffset = this.positionMap.get(position);
                const newOffset = offsets.get(currentOffset);
                if (newOffset)
                    newPositions.set(position, doc.positionAt(newOffset));
                else
                    newPositions.delete(position);
            }
            this.onPositionsChangedEmitter.fire([doc, newPositions]);
        });
    }
    clear() {
        this.positionMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, positions) {
        // Stash all positions as offsets.
        this.positionMap.clear();
        for (const position of positions)
            this.positionMap.set(position, document.offsetAt(position));
        // Track via the offset tracker.
        this.tracker.trackDoc(document, [...this.positionMap.values()]);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentPositionTracker = DocumentPositionTracker;
class DocumentOffsetTracker {
    disposables = [];
    document;
    offsetMap = new Map();
    onOffsetsChangedEmitter = new vs.EventEmitter();
    onOffsetsChanged = this.onOffsetsChangedEmitter.event;
    constructor() {
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.handleUpdate(e)));
    }
    trackDoc(document, offsets) {
        this.document = document;
        // Set all offsets to just point to themeselves.
        this.offsetMap.clear();
        for (const offset of offsets)
            this.offsetMap.set(offset, offset);
    }
    clear() {
        this.document = undefined;
        this.offsetMap.clear();
    }
    handleUpdate(e) {
        if (e.document !== this.document)
            return;
        for (const offset of [...this.offsetMap.keys()]) {
            // The key (offset) is the original offset, which we must use in the
            // map to track the current offset.
            // updateOffset takes the *value*, since we need to map the "current" (not
            // original) value, and then updates the value in the map.
            const currentOffset = this.offsetMap.get(offset);
            const newOffset = this.updateOffset(currentOffset, e);
            if (newOffset)
                this.offsetMap.set(offset, newOffset);
            else
                this.offsetMap.delete(offset);
        }
        this.onOffsetsChangedEmitter.fire([e.document, this.offsetMap]);
    }
    updateOffset(offset, change) {
        // If any edit spans us, consider us deleted.
        if (change.contentChanges.find((edit) => edit.rangeOffset < offset && edit.rangeOffset + edit.rangeLength > offset)) {
            return undefined;
        }
        // Otherwise, shift us along to account for any edits before us.
        const totalDiff = change.contentChanges
            // Edits that end before us.
            .filter((edit) => edit.rangeOffset + edit.rangeLength <= offset)
            // Get the difference in lengths to know if we inserted or removed.
            .map((edit) => edit.text.length - edit.rangeLength)
            .reduce((total, n) => total + n, 0);
        return offset + totalDiff;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentOffsetTracker = DocumentOffsetTracker;


/***/ }),

/***/ 1670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSampleUriHandler = void 0;
const vs = __importStar(__webpack_require__(1398));
const flutter_samples_1 = __webpack_require__(5913);
class FlutterSampleUriHandler {
    flutterCapabilities;
    constructor(flutterCapabilities) {
        this.flutterCapabilities = flutterCapabilities;
    }
    handle(sampleID) {
        if (!this.isValidSampleName(sampleID)) {
            void vs.window.showErrorMessage(`${sampleID} is not a valid Flutter sample identifier`);
            return;
        }
        (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, sampleID);
    }
    validSampleIdentifierPattern = new RegExp("^[\\w\\.]+$");
    isValidSampleName(name) {
        return this.validSampleIdentifierPattern.test(name);
    }
}
exports.FlutterSampleUriHandler = FlutterSampleUriHandler;


/***/ }),

/***/ 9499:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartUriHandler = void 0;
const vs = __importStar(__webpack_require__(1398));
const flutter_sample_handler_1 = __webpack_require__(1670);
class DartUriHandler {
    handlers;
    constructor(flutterCapabilities) {
        this.handlers = {
            "/flutter/sample/": new flutter_sample_handler_1.FlutterSampleUriHandler(flutterCapabilities),
        };
    }
    async handleUri(uri) {
        const handlerPrefix = Object.keys(this.handlers).find((key) => uri.path.startsWith(key));
        if (handlerPrefix) {
            await this.handlers[handlerPrefix].handle(uri.path.substr(handlerPrefix.length));
        }
        else {
            void vs.window.showErrorMessage(`No handler for '${uri.path}'. Check you have the latest version of the Dart plugin and try again.`);
        }
    }
}
exports.DartUriHandler = DartUriHandler;


/***/ }),

/***/ 7020:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showFlutterSurveyNotificationIfAppropriate = showFlutterSurveyNotificationIfAppropriate;
exports.showDevToolsNotificationIfAppropriate = showDevToolsNotificationIfAppropriate;
exports.showSdkDeprecationNoticeIfAppropriate = showSdkDeprecationNoticeIfAppropriate;
const vs = __importStar(__webpack_require__(1398));
const dart_1 = __webpack_require__(6854);
const vscode_1 = __webpack_require__(2461);
const constants_1 = __webpack_require__(6709);
const utils_1 = __webpack_require__(1894);
/// Shows Survey notification if appropriate. Returns whether a notification was shown
/// (not whether it was clicked/opened).
async function showFlutterSurveyNotificationIfAppropriate(context, webClient, analytics, openInBrowser, now, logger) {
    let surveyData;
    try {
        const rawSurveyJson = await webClient.fetch(constants_1.flutterSurveyDataUrl);
        const rawSurveyData = JSON.parse(rawSurveyJson);
        surveyData = {
            ...rawSurveyData,
            endDate: new Date(rawSurveyData.endDate).getTime(),
            startDate: new Date(rawSurveyData.startDate).getTime(),
        };
        if (!surveyData.uniqueId || !surveyData.title || !surveyData.url)
            throw new Error(`Survey data did not include ID, Title or URL:\n${rawSurveyJson}`);
    }
    catch (e) {
        logger.error(e);
        return false;
    }
    if (now <= surveyData.startDate || now >= surveyData.endDate)
        return false;
    const lastShown = context.getFlutterSurveyNotificationLastShown(surveyData.uniqueId);
    const doNotShow = context.getFlutterSurveyNotificationDoNotShow(surveyData.uniqueId);
    // Don't show this notification if user previously said not to.
    if (doNotShow)
        return false;
    // Don't show this notification if we've shown it in the last 40 hours.
    if (lastShown && now - lastShown < constants_1.longRepeatPromptThreshold)
        return false;
    const firstQsSep = surveyData.url.includes("?") ? "&" : "?";
    const surveyUrl = `${surveyData.url}${firstQsSep}Source=VSCode`;
    // Mark the last time we've shown it (now) so we can avoid showing again for
    // 40 hours.
    context.setFlutterSurveyNotificationLastShown(surveyData.uniqueId, Date.now());
    // Prompt to show and handle response.
    analytics.logFlutterSurveyShown();
    void vs.window.showInformationMessage(surveyData.title, constants_1.takeSurveyAction, constants_1.skipThisSurveyAction).then(async (choice) => {
        if (choice === constants_1.skipThisSurveyAction) {
            context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
            analytics.logFlutterSurveyDismissed();
        }
        else if (choice === constants_1.takeSurveyAction) {
            // Mark as do-not-show-again if they answer it, since it seems silly
            // to show them again if they already completed it.
            context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
            await openInBrowser(surveyUrl);
            analytics.logFlutterSurveyClicked();
        }
    });
    // Return true because we showed the notification and don't want to cause more
    // than one notification per activation.
    return true;
}
async function showDevToolsNotificationIfAppropriate(context) {
    if (!vscode_1.vsCodeVersion.supportsDevTools)
        return { didOpen: false };
    // Don't show in remote workspaces because currently DevTools fails to load if SSE doesn't work (which
    // is the case for some cloud IDE proxies).
    if (!utils_1.isRunningLocally)
        return { didOpen: false };
    const lastShown = context.devToolsNotificationLastShown;
    const doNotShow = context.devToolsNotificationDoNotShow;
    // Don't show this notification more than 10 times or if user said not to.
    if (doNotShow)
        return { didOpen: false };
    // Don't show this notification if we've shown it in the last 20 hours.
    if (lastShown && Date.now() - lastShown < constants_1.noRepeatPromptThreshold)
        return { didOpen: false };
    context.devToolsNotificationLastShown = Date.now();
    const choice = await vs.window.showInformationMessage(constants_1.wantToTryDevToolsPrompt, constants_1.openAction, constants_1.alwaysOpenAction, constants_1.notTodayAction, constants_1.doNotAskAgainAction);
    if (choice === constants_1.doNotAskAgainAction) {
        context.devToolsNotificationDoNotShow = true;
        return { didOpen: false };
    }
    else if (choice === constants_1.alwaysOpenAction) {
        void vs.commands.executeCommand("dart.openDevTools", { commandSource: constants_1.CommandSource.onDebugPrompt });
        return { didOpen: true, shouldAlwaysOpen: true };
    }
    else if (choice === constants_1.openAction) {
        void vs.commands.executeCommand("dart.openDevTools", { commandSource: constants_1.CommandSource.onDebugPrompt });
        return { didOpen: true };
    }
    else {
        // No thanks.
        return { didOpen: false };
    }
}
async function showSdkDeprecationNoticeIfAppropriate(logger, context, workspaceContext, dartCapabilities) {
    if (dartCapabilities.version === dart_1.DartCapabilities.empty.version)
        return false;
    if (!dartCapabilities.isUnsupportedNow && !dartCapabilities.isUnsupportedSoon)
        return false;
    const sdkKind = workspaceContext.sdks.dartSdkIsFromFlutter ? "Flutter" : "Dart";
    let userShownSdkVersion = workspaceContext.sdks.dartSdkIsFromFlutter ? workspaceContext.sdks.flutterVersion : workspaceContext.sdks.dartVersion;
    let dartSdkVersion = workspaceContext.sdks.dartVersion;
    if (!userShownSdkVersion || !dartSdkVersion)
        return false;
    try {
        // Trim to major+minor.
        userShownSdkVersion = userShownSdkVersion.split(".").slice(0, 2).join(".");
        dartSdkVersion = dartSdkVersion.split(".").slice(0, 2).join(".");
        const message = dartCapabilities.isUnsupportedNow
            ? `v${userShownSdkVersion} of the ${sdkKind} SDK is not supported by this version of the Dart extension. Update to a more recent ${sdkKind} SDK or switch to an older version of the extension.`
            : `Support for v${userShownSdkVersion} of the ${sdkKind} SDK will be removed in an upcoming release of the Dart extension. Consider updating to a more recent ${sdkKind} SDK.`;
        const actions = dartCapabilities.isUnsupportedNow
            ? [constants_1.moreInfoAction]
            : [constants_1.moreInfoAction, constants_1.iUnderstandAction];
        if (dartCapabilities.isUnsupportedNow || !context.getSdkDeprecationNoticeDoNotShow(dartSdkVersion)) {
            const action = await vs.window.showWarningMessage(message, ...actions);
            if (action === constants_1.moreInfoAction) {
                await utils_1.envUtils.openInBrowser(constants_1.sdkDeprecationInformationUrl);
            }
            context.setSdkDeprecationNoticeDoNotShow(dartSdkVersion, true);
            return true;
        }
    }
    catch (e) {
        logger.error(e);
    }
    return false;
}


/***/ }),

/***/ 1894:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.envUtils = exports.ProjectFinder = exports.isRunningLocally = exports.hostKind = exports.SourceSortMembersCodeActionKind = void 0;
exports.resolvePaths = resolvePaths;
exports.getDartWorkspaceFolders = getDartWorkspaceFolders;
exports.getAllProjectFolders = getAllProjectFolders;
exports.getAllProjectFoldersAndExclusions = getAllProjectFoldersAndExclusions;
exports.isDartWorkspaceFolder = isDartWorkspaceFolder;
exports.toRange = toRange;
exports.lspToRange = lspToRange;
exports.toPosition = toPosition;
exports.lspToPosition = lspToPosition;
exports.toRangeOnLine = toRangeOnLine;
exports.showCode = showCode;
exports.trimTrailingSlashes = trimTrailingSlashes;
exports.warnIfPathCaseMismatch = warnIfPathCaseMismatch;
exports.treeLabel = treeLabel;
exports.firstNonEditorColumn = firstNonEditorColumn;
exports.firstEditorColumn = firstEditorColumn;
exports.createWatcher = createWatcher;
exports.buildHostKind = buildHostKind;
const fs = __importStar(__webpack_require__(9896));
const os = __importStar(__webpack_require__(857));
const path = __importStar(__webpack_require__(6928));
const url_1 = __webpack_require__(7016);
const vs = __importStar(__webpack_require__(1398));
const vscode_1 = __webpack_require__(1398);
const YAML = __importStar(__webpack_require__(1198));
const constants_1 = __webpack_require__(6709);
const logging_1 = __webpack_require__(5045);
const utils_1 = __webpack_require__(949);
const cache_1 = __webpack_require__(5224);
const fs_1 = __webpack_require__(2587);
const utils_cloud_1 = __webpack_require__(2056);
exports.SourceSortMembersCodeActionKind = vscode_1.CodeActionKind.Source.append("sortMembers");
const dartExtension = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier);
exports.hostKind = getHostKind();
;
const projectFolderCache = new cache_1.SimpleTimeBasedCache();
let inProgressProjectFolderSearch;
// The extension kind is declared as Workspace, but VS Code will return UI in the
// case that there is no remote extension host.
exports.isRunningLocally = 
// Some cloud IDEs mis-report the extension kind, so if we _know_ something is a cloud IDE,
// override that.
!(0, utils_cloud_1.isKnownCloudIde)(vs.env.appName)
    && (!dartExtension || dartExtension.extensionKind === vscode_1.ExtensionKind.UI);
function resolvePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    if (!path.isAbsolute(p)) {
        const relativePathBase = vscode_1.workspace.workspaceFile?.scheme === "file"
            ? path.dirname((0, fs_1.fsPath)(vscode_1.workspace.workspaceFile))
            : vscode_1.workspace.workspaceFolders?.length
                ? (0, fs_1.fsPath)(vscode_1.workspace.workspaceFolders[0].uri)
                : undefined;
        if (relativePathBase)
            return path.join(relativePathBase, p);
    }
    return p;
}
function getDartWorkspaceFolders() {
    if (!vscode_1.workspace.workspaceFolders)
        return [];
    return vscode_1.workspace.workspaceFolders.filter(isDartWorkspaceFolder);
}
function getAnalysisOptionsExcludedFolders(logger, projectFolders) {
    const results = [];
    for (const projectFolder of projectFolders) {
        const analysisOptionsPath = path.join(projectFolder, "analysis_options.yaml");
        try {
            const analysisOptionsContent = fs.readFileSync(analysisOptionsPath);
            const yaml = YAML.parse(analysisOptionsContent.toString());
            const excluded = yaml?.analyzer?.exclude;
            if (excluded && Array.isArray(excluded)) {
                for (let exclude of excluded) {
                    // Only exclude an entire folder if the /** is at the end. If it's
                    // something like foo/**/*.generated.* then it does not exclude
                    // everything in foo.
                    if (exclude.endsWith("/**"))
                        exclude = exclude.substring(0, exclude.length - 3);
                    // Handle relative paths.
                    if (!exclude.startsWith("/"))
                        exclude = path.join(projectFolder, exclude);
                    // Now, if no wildcards remain in the path, we can use it as an exclusion.
                    if (!exclude.includes("*"))
                        results.push(exclude);
                }
            }
        }
        catch (e) {
            if (e?.code !== "ENOENT") // Don't warn for missing files.
                logger.error(`Failed to read ${analysisOptionsPath}: ${e}`);
        }
    }
    return results;
}
class ProjectFinder {
    logger;
    constructor(logger) {
        this.logger = logger;
    }
    async findAllProjectFolders(getExcludedFolders, options) {
        return getAllProjectFolders(this.logger, getExcludedFolders, options);
    }
}
exports.ProjectFinder = ProjectFinder;
async function getAllProjectFolders(logger, getExcludedFolders, options) {
    const results = await getAllProjectFoldersAndExclusions(logger, getExcludedFolders, options);
    return results.projectFolders;
}
async function getAllProjectFoldersAndExclusions(logger, getExcludedFolders, options) {
    const workspaceFolders = options.workspaceFolders ?? getDartWorkspaceFolders();
    // If an existing search is in progress, wait because it might populate the cache with the results
    // we want.
    if (inProgressProjectFolderSearch) {
        await inProgressProjectFolderSearch;
    }
    const cacheKey = `folders_${workspaceFolders.map((f) => f.uri.toString()).join(path.sep)}_${!!options.sort}_${!!options.onlyWorkspaceRoots}`;
    const cachedFolders = projectFolderCache.get(cacheKey);
    if (cachedFolders) {
        logger.info(`Returning cached results for project search`);
        return cachedFolders;
    }
    // Track this search so other searches can wait on it.
    const completer = new utils_1.PromiseCompleter();
    inProgressProjectFolderSearch = completer.promise;
    try {
        let startTimeMs = new Date().getTime();
        const tokenSource = new vs.CancellationTokenSource();
        let isComplete = false;
        const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
        let allExcludedFolders = getExcludedFolders ? (0, utils_1.flatMap)(workspaceFolders, getExcludedFolders) : [];
        const resultsPromise = (0, fs_1.findProjectFolders)(logger, topLevelFolders, allExcludedFolders, options, tokenSource.token);
        // After some time, if we still have not completed, show a progress notification that can be cancelled
        // to stop the search, which automatically hides when `resultsPromise` resolves.
        setTimeout(() => {
            if (!isComplete) {
                void vs.window.withProgress({
                    cancellable: true,
                    location: vs.ProgressLocation.Notification,
                    title: constants_1.projectSearchProgressText,
                }, (progress, token) => {
                    token.onCancellationRequested(() => {
                        tokenSource.cancel();
                        logger.info(`Project search was cancelled after ${new Date().getTime() - startTimeMs}ms (was searching ${options.searchDepth} levels)`);
                    });
                    return resultsPromise;
                });
            }
        }, constants_1.projectSearchProgressNotificationDelayInMs);
        let projectFolders = await resultsPromise;
        isComplete = true;
        logger.info(`Took ${new Date().getTime() - startTimeMs}ms to search for projects (${options.searchDepth} levels)`);
        startTimeMs = new Date().getTime();
        // Filter out any folders excluded by analysis_options.
        try {
            const excludedFolders = getAnalysisOptionsExcludedFolders(logger, projectFolders);
            projectFolders = projectFolders.filter((p) => !excludedFolders.find((ex) => (0, fs_1.isWithinPathOrEqual)(p, ex)));
            logger.info(`Took ${new Date().getTime() - startTimeMs}ms to filter out excluded projects (${excludedFolders.length} exclusion rules)`);
            allExcludedFolders = allExcludedFolders.concat(excludedFolders);
        }
        catch (e) {
            logger.error(`Failed to filter out analysis_options exclusions: ${e}`);
        }
        const result = { projectFolders, excludedFolders: new Set(allExcludedFolders) };
        // Cache the results.
        projectFolderCache.add(cacheKey, result, constants_1.projectSearchCacheTimeInMs);
        return result;
    }
    finally {
        // Clear the promise if it's still ours.
        completer.resolve();
        if (inProgressProjectFolderSearch === completer.promise)
            inProgressProjectFolderSearch = undefined;
    }
}
function isDartWorkspaceFolder(folder) {
    if (!folder || folder.uri.scheme !== "file")
        return false;
    // Currently we don't have good logic to know what's a Dart folder.
    // We could require a pubspec, but it's valid to just write scripts without them.
    // For now, nothing calls this that will do bad things if the folder isn't a Dart
    // project so we can review amend this in future if required.
    return true;
}
function toRange(document, offset, length) {
    return new vscode_1.Range(document.positionAt(offset), document.positionAt(offset + length));
}
function lspToRange(range) {
    return new vscode_1.Range(lspToPosition(range.start), lspToPosition(range.end));
}
function toPosition(location) {
    return new vscode_1.Position(location.startLine - 1, location.startColumn - 1);
}
function lspToPosition(position) {
    return new vscode_1.Position(position.line, position.character);
}
// Translates an offset/length to a Range.
// NOTE: Does not wrap lines because it does not have access to a TextDocument to know
// where the line ends.
function toRangeOnLine(location) {
    const startPos = toPosition(location);
    return new vscode_1.Range(startPos, startPos.translate(0, location.length));
}
function showCode(editor, displayRange, highlightRange, selectionRange) {
    if (selectionRange)
        editor.selection = new vscode_1.Selection(selectionRange.start, selectionRange.end);
    // Ensure the code is visible on screen.
    editor.revealRange(displayRange, vscode_1.TextEditorRevealType.InCenterIfOutsideViewport);
    // TODO: Implement highlighting
    // See https://github.com/Microsoft/vscode/issues/45059
}
function trimTrailingSlashes(s) {
    return s.replace(/[\/\\]+$/, "");
}
function warnIfPathCaseMismatch(logger, p, pathDescription, helpText) {
    const userPath = trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(p));
    const realPath = fs.existsSync(userPath) && trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(fs.realpathSync.native(userPath)));
    // Since realpathSync.native will resolve symlinks, we'll only show these warnings
    // when there was no symlink (eg. the lowercase version of both paths match).
    if (userPath && realPath && userPath.toLowerCase() === realPath.toLowerCase() && userPath !== realPath) {
        const message = `The casing of ${pathDescription} does not match the casing on disk; please ${helpText}. `
            + `Expected ${realPath} but got ${userPath}`;
        logger.warn(message);
        void vs.window.showWarningMessage(message);
        return true;
    }
    return false;
}
class EnvUtils {
    async openInBrowser(url, logger = logging_1.nullLogger) {
        logger.info(`Opening external URL: ${url}`);
        return vscode_1.env.openExternal(vscode_1.Uri.parse(url));
    }
    async exposeUrl(urlString, logger = logging_1.nullLogger) {
        const uri = vs.Uri.parse(urlString, true);
        logger.info(`Exposing URL: ${uri.toString()}`);
        const isWebSocket = uri.scheme === "ws" || uri.scheme === "wss";
        const isSecure = uri.scheme === "wss" || uri.scheme === "https";
        // TODO: Remove this scheme mapping when https://github.com/microsoft/vscode/issues/84819
        // is resolved.
        let fakeScheme = uri.scheme;
        if (isWebSocket)
            fakeScheme = isSecure ? "https" : "http";
        const url = new url_1.URL(urlString);
        // Ensure the URL always has a port, as some cloud providers fail to expose URLs correctly
        // that don't have explicit port numbers.
        //
        // Additionally, on some cloud providers we get an IPv6 loopback which fails to connect
        // correctly. Assume that if we get this, it's safe to use the "localhost" hostname.
        const fakeHostname = url.hostname === "[::]" ? "localhost" : url.hostname;
        const fakePort = url.port || (isSecure ? "443" : "80"); // Don't change to ??, port can be empty string!
        const fakeAuthority = `${fakeHostname}:${fakePort}`;
        const uriToMap = uri.with({ scheme: fakeScheme, authority: fakeAuthority });
        logger.info(`Mapping URI: ${uriToMap.toString()}`);
        const mappedUri = await vscode_1.env.asExternalUri(uriToMap);
        logger.info(`Mapped URI: ${mappedUri.toString()}`);
        // Now we need to map the scheme back to WS if that's what was originally asked for, however
        // we need to take into account whether asExternalUri pushed is up to secure, so use
        // the http/https to decide which to go back to.
        let newScheme = mappedUri.scheme;
        if (isWebSocket)
            // Note: We use mappedUri.scheme here and not isSecure because we
            // care if the *exposed* URI is secure.
            newScheme = mappedUri.scheme === "https" ? "wss" : "ws";
        const mappedUrl = new url_1.URL(uriToString(mappedUri));
        logger.info(`Mapped URL: ${mappedUrl}`);
        // Copy the important (mapped) parts back onto the original URL, preserving
        // the path/querystring that was not messed with by VS Code's Uri class.
        url.protocol = newScheme;
        url.host = mappedUrl.host;
        url.port = mappedUrl.port;
        logger.info(`Final URL: ${url}`);
        return url.toString();
    }
}
function uriToString(uri) {
    return uri.toString()
        .replace(/%24/g, "$")
        .replace(/%5B/g, "[");
}
function treeLabel(item) {
    if (!item.label || typeof item.label === "string")
        return item.label;
    return item.label.label;
}
exports.envUtils = new EnvUtils();
function usedEditorColumns() {
    return new Set(vs.window.visibleTextEditors.map((e) => e.viewColumn).filter(utils_1.notUndefined));
}
function firstNonEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (!usedColumns.has(i))
            return i;
    }
}
function firstEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (usedColumns.has(i))
            return i;
    }
}
function createWatcher(pattern, emitter) {
    const watcher = vs.workspace.createFileSystemWatcher(pattern);
    watcher.onDidChange((uri) => emitter.fire(uri));
    watcher.onDidCreate((uri) => emitter.fire(uri));
    watcher.onDidDelete((uri) => emitter.fire(uri));
    return watcher;
}
function getHostKind() {
    return buildHostKind(vs.env);
}
/// Builds a string for analytics/logging purposes that describes the environment that the extension is running in.
///
/// appName is passed only to detect cloud IDEs and is not part of the string, since that is reported separately.
///
/// The returned string is essentially `$appHost-$remoteName` but with some cleanup to avoid redundant or duplicated values, and to
/// shorten domains to top-levels.
function buildHostKind({ appName, appHost, remoteName }) {
    const topLevelDomainRegex = new RegExp(".*\\.(.*\\..*)$");
    const withoutNumbersRegex = new RegExp("(.*?)[\\d.\\-:]*$");
    const regexes = [topLevelDomainRegex, withoutNumbersRegex];
    // Fix any known cloud IDEs incorrectly using the default "desktop" value.
    if ((0, utils_cloud_1.isKnownCloudIde)(appName) && appHost === "desktop")
        appHost = "web";
    // Assume desktop by default.
    if (appHost === "desktop")
        appHost = undefined;
    /// Clean up domains to only top level domains without ports and no
    /// local domains.
    function cleanString(input) {
        if (!input)
            return input;
        for (const regex of regexes) {
            const match = regex.exec(input);
            if (match)
                input = match[1];
        }
        if (input.endsWith(".local") || input.endsWith("localhost")) {
            input = undefined;
        }
        return input;
    }
    remoteName = cleanString(remoteName);
    appHost = cleanString(appHost);
    // There are a lot of uses of "server-distro" that have domains suffixed.
    // We don't care too much about the specific domains for these, we should
    // just group them all as "server-distro".
    if (appHost?.startsWith("server-distro") || remoteName?.startsWith("server-distro"))
        return "server-distro";
    if (appHost && remoteName && appHost !== remoteName)
        return `${appHost}-${remoteName}`;
    else if (appHost)
        return appHost;
    else if (remoteName)
        return remoteName;
    else
        return undefined;
}


/***/ }),

/***/ 2056:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTheia = isTheia;
exports.isCloudShell = isCloudShell;
exports.isProjectIdx = isProjectIdx;
exports.isKnownCloudIde = isKnownCloudIde;
function isTheia(appName) {
    return appName?.includes("Theia");
}
function isCloudShell(appName) {
    return appName?.includes("Cloud Shell");
}
function isProjectIdx(appName) {
    return appName?.includes("IDX");
}
function isKnownCloudIde(appName) {
    return isTheia(appName) || isCloudShell(appName) || isProjectIdx(appName);
}


/***/ }),

/***/ 7946:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
class Context {
    context;
    workspaceContext;
    constructor(context, workspaceContext) {
        this.context = context;
        this.workspaceContext = workspaceContext;
    }
    // Helper we can manually call in the constructor when testing.
    async clear() {
        for (const clearableKey of this.context.globalState.keys())
            await this.context.globalState.update(clearableKey, undefined);
        for (const clearableKey of this.context.workspaceState.keys())
            await this.context.workspaceState.update(clearableKey, undefined);
    }
    static for(context, workspaceContext) {
        return new Context(context, workspaceContext);
    }
    get extensionStorageUri() {
        return this.context.globalStorageUri;
    }
    get devToolsNotificationLastShown() { return this.context.globalState.get("devToolsNotificationLastShown"); }
    set devToolsNotificationLastShown(value) { void this.context.globalState.update("devToolsNotificationLastShown", value); }
    get devToolsNotificationDoNotShow() { return !!this.context.globalState.get("devToolsNotificationDoNotShowAgain"); }
    set devToolsNotificationDoNotShow(value) { void this.context.globalState.update("devToolsNotificationDoNotShowAgain", value); }
    get breakpointInNonDebuggableFileDoNotShowAgain() { return !!this.context.globalState.get("breakpointInNonDebuggableFileDoNotShowAgain"); }
    set breakpointInNonDebuggableFileDoNotShowAgain(value) { void this.context.globalState.update("breakpointInNonDebuggableFileDoNotShowAgain", value); }
    getFlutterSurveyNotificationLastShown(id) { return this.context.globalState.get(`flutterSurvey${id}NotificationLastShown`); }
    setFlutterSurveyNotificationLastShown(id, value) { void this.context.globalState.update(`flutterSurvey${id}NotificationLastShown`, value); }
    getFlutterSurveyNotificationDoNotShow(id) { return !!this.context.globalState.get(`flutterSurvey${id}NotificationDoNotShowAgain`); }
    setFlutterSurveyNotificationDoNotShow(id, value) { void this.context.globalState.update(`flutterSurvey${id}NotificationDoNotShowAgain`, value); }
    getSdkDeprecationNoticeDoNotShow(dartSdkVersion) { return !!this.context.globalState.get(`dartSdk${dartSdkVersion}DeprecationNotificationDoNotShowAgain`); }
    setSdkDeprecationNoticeDoNotShow(dartSdkVersion, value) { void this.context.globalState.update(`dartSdk${dartSdkVersion}DeprecationNotificationDoNotShowAgain`, value); }
    get hasWarnedAboutFormatterSyntaxLimitation() { return !!this.context.globalState.get("hasWarnedAboutFormatterSyntaxLimitation"); }
    set hasWarnedAboutFormatterSyntaxLimitation(value) { void this.context.globalState.update("hasWarnedAboutFormatterSyntaxLimitation", value); }
    get hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation() { return !!this.context.globalState.get("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation"); }
    set hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation(value) { void this.context.globalState.update("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation", value); }
    get hasNotifiedAboutProfileModeDefaultConfiguration() { return !!this.context.globalState.get("hasNotifiedAboutProfileModeDefaultConfiguration"); }
    set hasNotifiedAboutProfileModeDefaultConfiguration(value) { void this.context.globalState.update("hasNotifiedAboutProfileModeDefaultConfiguration", value); }
    get lastSeenVersion() { return this.context.globalState.get("lastSeenVersion"); }
    set lastSeenVersion(value) { void this.context.globalState.update("lastSeenVersion", value); }
    get lastUsedNewProjectPath() { return this.context.globalState.get("lastUsedNewProjectPath"); }
    set lastUsedNewProjectPath(value) { void this.context.globalState.update("lastUsedNewProjectPath", value); }
    getPackageLastCheckedForUpdates(packageID) { return this.context.globalState.get(`packageLastCheckedForUpdates:${packageID}`); }
    setPackageLastCheckedForUpdates(packageID, value) { void this.context.globalState.update(`packageLastCheckedForUpdates:${packageID}`, value); }
    getIgnoredExtensionRecommendationIdentifiers() { return this.context.globalState.get(`ignoredExtensionRecommendations`) ?? []; }
    ignoreExtensionRecommendation(extension) { void this.context.globalState.update(`ignoredExtensionRecommendations`, [...this.getIgnoredExtensionRecommendationIdentifiers(), extension]); }
    update(key, value) {
        return this.context.globalState.update(key, value);
    }
    get(key) {
        return this.context.globalState.get(key);
    }
    asAbsolutePath(relativePath) {
        return this.context.asAbsolutePath(relativePath);
    }
    // Workspace-specific.
    get workspaceLastFlutterDeviceId() { return this.context.workspaceState.get("workspaceLastFlutterDeviceId"); }
    set workspaceLastFlutterDeviceId(value) { void this.context.workspaceState.update("workspaceLastFlutterDeviceId", value); }
}
exports.Context = Context;


/***/ }),

/***/ 9329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceContext = void 0;
const events_1 = __webpack_require__(9495);
class WorkspaceContext {
    sdks;
    config;
    hasAnyFlutterProjects;
    hasAnyWebProjects;
    hasAnyStandardDartProjects;
    hasProjectsInFuchsiaTree;
    workspaceTypeDescription;
    events = new WorkspaceEvents();
    // TODO: Move things from Sdks to this class that aren't related to the SDKs.
    constructor(sdks, config, hasAnyFlutterProjects, hasAnyWebProjects, hasAnyStandardDartProjects, hasProjectsInFuchsiaTree) {
        this.sdks = sdks;
        this.config = config;
        this.hasAnyFlutterProjects = hasAnyFlutterProjects;
        this.hasAnyWebProjects = hasAnyWebProjects;
        this.hasAnyStandardDartProjects = hasAnyStandardDartProjects;
        this.hasProjectsInFuchsiaTree = hasProjectsInFuchsiaTree;
        this.workspaceTypeDescription = this.buildWorkspaceTypeDescription();
    }
    get shouldLoadFlutterExtension() { return this.hasAnyFlutterProjects; }
    /// Used only for display (for ex stats), not behaviour.
    buildWorkspaceTypeDescription() {
        const types = [];
        // Don't re-order these, else stats won't easily combine as we could have
        // Dart, Flutter and also Flutter, Dart.
        if (this.hasAnyStandardDartProjects)
            types.push("Dart");
        if (this.hasAnyFlutterProjects)
            types.push("Flutter");
        if (this.hasProjectsInFuchsiaTree)
            types.push("Fuchsia");
        // If we didn't detect any projects, record as unknown, but include info
        // on the type of SDK we had found.
        if (types.length === 0) {
            if (this.sdks && this.sdks.dartSdkIsFromFlutter)
                types.push("Unknown (Flutter SDK)");
            else if (this.sdks && this.sdks.dart)
                types.push("Unknown (Dart SDK)");
            else
                types.push("Unknown (No SDK)");
        }
        return types.join(", ");
    }
    dispose() {
        this.events.dispose();
    }
}
exports.WorkspaceContext = WorkspaceContext;
class WorkspaceEvents {
    onPackageMapChange = new events_1.EventEmitter();
    dispose() {
        this.onPackageMapChange.dispose();
    }
}


/***/ }),

/***/ 3281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
const messages_1 = __webpack_require__(6177);
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(3352);
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(4019);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(2676);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(9850);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const sharedArrayCancellation_1 = __webpack_require__(4996);
Object.defineProperty(exports, "SharedArraySenderStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } }));
Object.defineProperty(exports, "SharedArrayReceiverStrategy", ({ enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } }));
const messageReader_1 = __webpack_require__(9085);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(3193);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const messageBuffer_1 = __webpack_require__(9244);
Object.defineProperty(exports, "AbstractMessageBuffer", ({ enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } }));
const connection_1 = __webpack_require__(577);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
Object.defineProperty(exports, "MessageStrategy", ({ enumerable: true, get: function () { return connection_1.MessageStrategy; } }));
const ral_1 = __webpack_require__(9590);
exports.RAL = ral_1.default;


/***/ }),

/***/ 9850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(9590);
const Is = __webpack_require__(8585);
const events_1 = __webpack_require__(2676);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ 577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(9590);
const Is = __webpack_require__(8585);
const messages_1 = __webpack_require__(6177);
const linkedMap_1 = __webpack_require__(3352);
const events_1 = __webpack_require__(2676);
const cancellation_1 = __webpack_require__(9850);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues = exports.TraceValues || (exports.TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var IdCancellationReceiverStrategy;
(function (IdCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    IdCancellationReceiverStrategy.is = is;
})(IdCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = {}));
var RequestCancellationReceiverStrategy;
(function (RequestCancellationReceiverStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
    }
    RequestCancellationReceiverStrategy.is = is;
})(RequestCancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var MessageStrategy;
(function (MessageStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
    }
    MessageStrategy.is = is;
})(MessageStrategy = exports.MessageStrategy || (exports.MessageStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
        }
        else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
        }
        else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
        }
        else {
            handleInvalidMessage(message);
        }
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            const messageStrategy = options?.messageStrategy;
            if (MessageStrategy.is(messageStrategy)) {
                messageStrategy.handleMessage(message, handleMessage);
            }
            else {
                handleMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)
                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)
                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch((error) => {
                logger.error(`Sending notification failed.`);
                throw error;
            });
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            // This should not await but simple return to ensure that we don't have another
            // async scheduling. Otherwise one send could overtake another send.
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const requestMessage = {
                jsonrpc: version,
                id: id,
                method: method,
                params: messageParams
            };
            traceSendingRequest(requestMessage);
            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                cancellationStrategy.sender.enableCancellation(requestMessage);
            }
            return new Promise(async (resolve, reject) => {
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                try {
                    await messageWriter.write(requestMessage);
                    responsePromises.set(id, responsePromise);
                }
                catch (error) {
                    logger.error(`Sending request failed.`);
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                    throw error;
                }
            });
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ 4019:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));


/***/ }),

/***/ 2676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(9590);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ 8585:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ 3352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;


/***/ }),

/***/ 9244:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;


/***/ }),

/***/ 9085:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(9590);
const Is = __webpack_require__(8585);
const events_1 = __webpack_require__(2676);
const semaphore_1 = __webpack_require__(4323);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders(true);
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('content-length');
                if (!contentLength) {
                    this.fireError(new Error('Header must provide a Content-Length property.'));
                    return;
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    this.fireError(new Error('Content-Length value must be a number.'));
                    return;
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            // Make sure that we convert one received message after the
            // other. Otherwise it could happen that a decoding of a second
            // smaller message finished before the decoding of a first larger
            // message and then we would deliver the second message first.
            this.readSemaphore.lock(async () => {
                const bytes = this.options.contentDecoder !== undefined
                    ? await this.options.contentDecoder.decode(body)
                    : body;
                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                this.callback(message);
            }).catch((error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;


/***/ }),

/***/ 3193:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(9590);
const Is = __webpack_require__(8585);
const semaphore_1 = __webpack_require__(4323);
const events_1 = __webpack_require__(2676);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;


/***/ }),

/***/ 6177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(8585);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message = exports.Message || (exports.Message = {}));


/***/ }),

/***/ 9590:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;


/***/ }),

/***/ 4323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(9590);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;


/***/ }),

/***/ 4996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
const cancellation_1 = __webpack_require__(9850);
var CancellationState;
(function (CancellationState) {
    CancellationState.Continue = 0;
    CancellationState.Cancelled = 1;
})(CancellationState || (CancellationState = {}));
class SharedArraySenderStrategy {
    constructor() {
        this.buffers = new Map();
    }
    enableCancellation(request) {
        if (request.id === null) {
            return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
    }
    async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === undefined) {
            return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
    }
    cleanup(id) {
        this.buffers.delete(id);
    }
    dispose() {
        this.buffers.clear();
    }
}
exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
class SharedArrayBufferCancellationToken {
    constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
    }
    get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
    }
    get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
    }
}
class SharedArrayBufferCancellationTokenSource {
    constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
    }
    cancel() {
    }
    dispose() {
    }
}
class SharedArrayReceiverStrategy {
    constructor() {
        this.kind = 'request';
    }
    createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === undefined) {
            return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
    }
}
exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;


/***/ }),

/***/ 7123:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(9571);
// Install the node runtime abstract.
ril_1.default.install();
const path = __webpack_require__(6928);
const os = __webpack_require__(857);
const crypto_1 = __webpack_require__(6982);
const net_1 = __webpack_require__(9278);
const api_1 = __webpack_require__(3281);
__exportStar(__webpack_require__(3281), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class PortMessageReader extends api_1.AbstractMessageReader {
    constructor(port) {
        super();
        this.onData = new api_1.Emitter;
        port.on('close', () => this.fireClose);
        port.on('error', (error) => this.fireError(error));
        port.on('message', (message) => {
            this.onData.fire(message);
        });
    }
    listen(callback) {
        return this.onData.event(callback);
    }
}
exports.PortMessageReader = PortMessageReader;
class PortMessageWriter extends api_1.AbstractMessageWriter {
    constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on('close', () => this.fireClose());
        port.on('error', (error) => this.fireError(error));
    }
    write(msg) {
        try {
            this.port.postMessage(msg);
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.PortMessageWriter = PortMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;


/***/ }),

/***/ 9571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const util_1 = __webpack_require__(9023);
const api_1 = __webpack_require__(3281);
class MessageBuffer extends api_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return api_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return api_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return api_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return api_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        api_1.RAL.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;


/***/ }),

/***/ 2067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(7123);

/***/ }),

/***/ 6353:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticPullMode = exports.vsdiag = void 0;
__exportStar(__webpack_require__(7354), exports);
__exportStar(__webpack_require__(4294), exports);
var diagnostic_1 = __webpack_require__(9214);
Object.defineProperty(exports, "vsdiag", ({ enumerable: true, get: function () { return diagnostic_1.vsdiag; } }));
Object.defineProperty(exports, "DiagnosticPullMode", ({ enumerable: true, get: function () { return diagnostic_1.DiagnosticPullMode; } }));
__exportStar(__webpack_require__(9538), exports);


/***/ }),

/***/ 490:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyOutgoingCalls
            ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;


/***/ }),

/***/ 9538:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const c2p = __webpack_require__(1798);
const p2c = __webpack_require__(7605);
const Is = __webpack_require__(8319);
const async_1 = __webpack_require__(5721);
const UUID = __webpack_require__(9032);
const progressPart_1 = __webpack_require__(9403);
const features_1 = __webpack_require__(4294);
const diagnostic_1 = __webpack_require__(9214);
const notebook_1 = __webpack_require__(1872);
const configuration_1 = __webpack_require__(5199);
const textSynchronization_1 = __webpack_require__(1596);
const completion_1 = __webpack_require__(6535);
const hover_1 = __webpack_require__(1507);
const definition_1 = __webpack_require__(600);
const signatureHelp_1 = __webpack_require__(1400);
const documentHighlight_1 = __webpack_require__(9014);
const documentSymbol_1 = __webpack_require__(9228);
const workspaceSymbol_1 = __webpack_require__(8312);
const reference_1 = __webpack_require__(420);
const codeAction_1 = __webpack_require__(8430);
const codeLens_1 = __webpack_require__(8140);
const formatting_1 = __webpack_require__(7298);
const rename_1 = __webpack_require__(875);
const documentLink_1 = __webpack_require__(7656);
const executeCommand_1 = __webpack_require__(9073);
const fileSystemWatcher_1 = __webpack_require__(9084);
const colorProvider_1 = __webpack_require__(3515);
const implementation_1 = __webpack_require__(191);
const typeDefinition_1 = __webpack_require__(5432);
const workspaceFolder_1 = __webpack_require__(6804);
const foldingRange_1 = __webpack_require__(3963);
const declaration_1 = __webpack_require__(7061);
const selectionRange_1 = __webpack_require__(6258);
const progress_1 = __webpack_require__(9870);
const callHierarchy_1 = __webpack_require__(490);
const semanticTokens_1 = __webpack_require__(7691);
const fileOperations_1 = __webpack_require__(2485);
const linkedEditingRange_1 = __webpack_require__(4913);
const typeHierarchy_1 = __webpack_require__(4622);
const inlineValue_1 = __webpack_require__(3131);
const inlayHint_1 = __webpack_require__(2767);
/**
 * Controls when the output channel is revealed.
 */
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
/**
 * Signals in which state the language client is in.
 */
var State;
(function (State) {
    /**
     * The client is stopped or got never started.
     */
    State[State["Stopped"] = 1] = "Stopped";
    /**
     * The client is starting but not ready yet.
     */
    State[State["Starting"] = 3] = "Starting";
    /**
     * The client is running and ready.
     */
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var SuspendMode;
(function (SuspendMode) {
    /**
     * Don't allow suspend mode.
     */
    SuspendMode["off"] = "off";
    /**
     * Support suspend mode even if not all
     * registered providers have a corresponding
     * activation listener.
     */
    SuspendMode["on"] = "on";
})(SuspendMode = exports.SuspendMode || (exports.SuspendMode = {}));
class DefaultErrorHandler {
    constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
            return { action: CloseAction.Restart };
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
            }
            else {
                this.restarts.shift();
                return { action: CloseAction.Restart };
            }
        }
    }
}
var ClientState;
(function (ClientState) {
    ClientState["Initial"] = "initial";
    ClientState["Starting"] = "starting";
    ClientState["StartFailed"] = "startFailed";
    ClientState["Running"] = "running";
    ClientState["Stopping"] = "stopping";
    ClientState["Stopped"] = "stopped";
})(ClientState || (ClientState = {}));
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = new Map();
        this._diagnosticQueueState = { state: 'idle' };
        this._features = [];
        this._dynamicFeatures = new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== undefined) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        // const defaultInterval = (clientOptions as TestOptions).$testMode ? 50 : 60000;
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector ?? [],
            synchronize: clientOptions.synchronize ?? {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName ?? this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding ?? 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
            middleware: clientOptions.middleware ?? {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            // suspend: {
            // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
            // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
            // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
            // },
            diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
            notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = new Set();
        this._listeners = [];
        this._notificationHandlers = new Map();
        this._pendingNotificationHandlers = new Map();
        this._notificationDisposables = new Map();
        this._requestHandlers = new Map();
        this._pendingRequestHandlers = new Map();
        this._requestDisposables = new Map();
        this._progressHandlers = new Map();
        this._pendingProgressHandlers = new Map();
        this._progressDisposables = new Map();
        this._connection = undefined;
        // this._idleStart = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = undefined;
        this._pendingOpenNotifications = new Set();
        this._pendingChangeSemaphore = new async_1.Semaphore(1);
        this._pendingChangeDelayer = new async_1.Delayer(250);
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get name() {
        return this._name;
    }
    get middleware() {
        return this._clientOptions.middleware ?? Object.create(null);
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    get state() {
        return this.getPublicState();
    }
    get $state() {
        return this._state;
    }
    set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        switch (this.$state) {
            case ClientState.Starting:
                return State.Starting;
            case ClientState.Running:
                return State.Running;
            default:
                return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        // Ensure we have a connection before we force the document sync.
        const connection = await this.$start();
        // If any document is synced in full mode make sure we flush any pending
        // full document syncs.
        if (this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
            await this.sendPendingFullTextDocumentChanges(connection);
        }
        return connection.sendRequest(type, ...params);
    }
    onRequest(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingRequestHandlers.delete(method);
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._requestHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        const needsPendingFullTextDocumentSync = this._didChangeTextDocumentFeature.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        let openNotification;
        if (needsPendingFullTextDocumentSync && typeof type !== 'string' && type.method === vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method) {
            openNotification = params?.textDocument.uri;
            this._pendingOpenNotifications.add(openNotification);
        }
        // Ensure we have a connection before we force the document sync.
        const connection = await this.$start();
        // If any document is synced in full mode make sure we flush any pending
        // full document syncs.
        if (needsPendingFullTextDocumentSync) {
            await this.sendPendingFullTextDocumentChanges(connection);
        }
        // We need to remove the pending open notification before we actually
        // send the notification over the connection. Otherwise there could be
        // a request coming in that although the open notification got already put
        // onto the wire will ignore pending document changes.
        //
        // Since the code path of connection.sendNotification is actually sync
        // until the message is handed of to the writer and the writer as a semaphore
        // lock with a capacity of 1 no additional async scheduling can happen until
        // the message is actually handed of.
        if (openNotification !== undefined) {
            this._pendingOpenNotifications.delete(openNotification);
        }
        return connection.sendNotification(type, params);
    }
    onNotification(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingNotificationHandlers.delete(method);
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._notificationHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            return connection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== undefined
            ? (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
            }
            : handler;
        if (connection !== undefined) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
                dispose: () => {
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
                dispose: () => {
                    this._pendingProgressHandlers.delete(token);
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._progressHandlers.delete(token);
                disposable.dispose();
            }
        };
    }
    createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== undefined && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
    }
    async setTrace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== undefined) {
            await connection.trace(this._trace, this._tracer, {
                sendNotification: false,
                traceFormat: this._traceFormat
            });
        }
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === 'force' || (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error)) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
    }
    showNotificationMessage(type, message) {
        message = message ?? 'A request has failed. See the output for more information.';
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error
            ? vscode_1.window.showErrorMessage
            : type === vscode_languageserver_protocol_1.MessageType.Warning
                ? vscode_1.window.showWarningMessage
                : vscode_1.window.showInformationMessage;
        void messageFunc(message, 'Go to output').then((selection) => {
            if (selection !== undefined) {
                this.outputChannel.show(true);
            }
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
    }
    needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
    }
    activeConnection() {
        return this.$state === ClientState.Running && this._connection !== undefined ? this._connection : undefined;
    }
    isRunning() {
        return this.$state === ClientState.Running;
    }
    async start() {
        if (this._disposed === 'disposing' || this._disposed === 'disposed') {
            throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
            throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        // We are already running or are in the process of getting up
        // to speed.
        if (this._onStart !== undefined) {
            return this._onStart;
        }
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        // If we restart then the diagnostics collection is reused.
        if (this._diagnostics === undefined) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        // When we start make all buffer handlers pending so that they
        // get added.
        for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
                this._pendingNotificationHandlers.set(method, handler);
            }
        }
        for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
                this._pendingRequestHandlers.set(method, handler);
            }
        }
        for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
                this._pendingProgressHandlers.set(token, data);
            }
        }
        this.$state = ClientState.Starting;
        try {
            const connection = await this.createConnection();
            connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        void vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        void vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        void vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        void vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
                const showDocument = async (params) => {
                    const uri = this.protocol2CodeConverter.asUri(params.uri);
                    try {
                        if (params.external === true) {
                            const success = await vscode_1.env.openExternal(uri);
                            return { success };
                        }
                        else {
                            const options = {};
                            if (params.selection !== undefined) {
                                options.selection = this.protocol2CodeConverter.asRange(params.selection);
                            }
                            if (params.takeFocus === undefined || params.takeFocus === false) {
                                options.preserveFocus = true;
                            }
                            else if (params.takeFocus === true) {
                                options.preserveFocus = false;
                            }
                            await vscode_1.window.showTextDocument(uri, options);
                            return { success: true };
                        }
                    }
                    catch (error) {
                        return { success: false };
                    }
                };
                const middleware = this._clientOptions.middleware.window?.showDocument;
                if (middleware !== undefined) {
                    return middleware(params, showDocument);
                }
                else {
                    return showDocument(params);
                }
            });
            connection.listen();
            await this.initialize(connection);
            resolve();
        }
        catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, 'force');
            reject(error);
        }
        return this._onStart;
    }
    createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        return [promise, resolve, reject];
    }
    async initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        // If the client is locked to a workspace folder use it. In this case the workspace folder
        // feature is not registered and we need to initialize the value here.
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== undefined
            ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]]
            : [this._clientGetRootPath(), null];
        const initParams = {
            processId: null,
            clientInfo: {
                name: vscode_1.env.appName,
                version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            try {
                const result = await this.doInitialize(connection, initParams);
                part.done();
                return result;
            }
            catch (error) {
                part.cancel();
                throw error;
            }
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    async doInitialize(connection, initParams) {
        try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== undefined && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
                throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            // Add pending notification, request and progress handlers.
            for (const [method, handler] of this._pendingNotificationHandlers) {
                this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
                this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
                this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            // if (this._clientOptions.suspend.mode !== SuspendMode.off) {
            // 	this._idleInterval =  RAL().timer.setInterval(() => this.checkSuspend(), this._clientOptions.suspend.interval);
            // }
            await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
        }
        catch (error) {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    void this.initialize(connection);
                }
                else {
                    void this.stop();
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                void vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        void this.initialize(connection);
                    }
                    else {
                        void this.stop();
                    }
                });
            }
            else {
                if (error && error.message) {
                    void vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                void this.stop();
            }
            throw error;
        }
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop(timeout = 2000) {
        // Wait 2 seconds on stop
        return this.shutdown('stop', timeout);
    }
    dispose(timeout = 2000) {
        try {
            this._disposed = 'disposing';
            return this.stop(timeout);
        }
        finally {
            this._disposed = 'disposed';
        }
    }
    async shutdown(mode, timeout) {
        // If the client is stopped or in its initial state return.
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
        }
        // If we are stopping the client and have a stop promise return it.
        if (this.$state === ClientState.Stopping) {
            if (this._onStop !== undefined) {
                return this._onStop;
            }
            else {
                throw new Error(`Client is stopping but no stop promise available.`);
            }
        }
        const connection = this.activeConnection();
        // We can't stop a client that is not running (e.g. has no connection). Especially not
        // on that us starting since it can't be correctly synchronized.
        if (connection === undefined || this.$state !== ClientState.Running) {
            throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = undefined;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise(c => { (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout); });
        const shutdown = (async (connection) => {
            await connection.shutdown();
            await connection.exit();
            return connection;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection) => {
            // The connection won the race with the timeout.
            if (connection !== undefined) {
                connection.end();
                connection.dispose();
            }
            else {
                this.error(`Stopping server timed out`, undefined, false);
                throw new Error(`Stopping the server timed out`);
            }
        }, (error) => {
            this.error(`Stopping server failed`, error, false);
            throw error;
        }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === 'stop' && this.cleanUpChannel();
            this._onStart = undefined;
            this._onStop = undefined;
            this._connection = undefined;
            this._ignoredRegistrations.clear();
        });
    }
    cleanUp(mode) {
        // purge outstanding file events.
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable of disposables) {
            disposable.dispose();
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        // Dispose features in reverse order;
        for (const feature of Array.from(this._features.entries()).map(entry => entry[1]).reverse()) {
            feature.dispose();
        }
        if (mode === 'stop' && this._diagnostics !== undefined) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
        if (this._idleInterval !== undefined) {
            this._idleInterval.dispose();
            this._idleInterval = undefined;
        }
        // this._idleStart = undefined;
    }
    cleanUpChannel() {
        if (this._outputChannel !== undefined && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            return client._fileEventDelayer.trigger(async () => {
                await client.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
                client._fileEvents = [];
            });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
            client.error(`Notify file events failed.`, error);
        });
    }
    async sendPendingFullTextDocumentChanges(connection) {
        return this._pendingChangeSemaphore.lock(async () => {
            try {
                const changes = this._didChangeTextDocumentFeature.getPendingDocumentChanges(this._pendingOpenNotifications);
                if (changes.length === 0) {
                    return;
                }
                for (const document of changes) {
                    const params = this.code2ProtocolConverter.asChangeTextDocumentParams(document);
                    // We await the send and not the delivery since it is more or less the same for
                    // notifications.
                    await connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    this._didChangeTextDocumentFeature.notificationSent(document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                }
            }
            catch (error) {
                this.error(`Sending pending changes failed`, error, false);
                throw error;
            }
        });
    }
    triggerPendingChangeDelivery() {
        this._pendingChangeDelayer.trigger(async () => {
            const connection = this.activeConnection();
            if (connection === undefined) {
                this.triggerPendingChangeDelivery();
                return;
            }
            await this.sendPendingFullTextDocumentChanges(connection);
        }).catch((error) => this.error(`Delivering pending changes failed`, error, false));
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === 'busy' && this._diagnosticQueueState.document === key) {
            // Cancel the active run;
            this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
    }
    triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => { this.workDiagnosticQueue(); });
    }
    workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === 'busy') {
            return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
            // Nothing in the queue
            return;
        }
        const [document, diagnostics] = next.value;
        this._diagnosticQueue.delete(document);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: 'busy', document: document, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
            if (!tokenSource.token.isCancellationRequested) {
                const uri = this._p2c.asUri(document);
                const middleware = this.clientOptions.middleware;
                if (middleware.handleDiagnostics) {
                    middleware.handleDiagnostics(uri, converted, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
                }
                else {
                    this.setDiagnostics(uri, converted);
                }
            }
        }).finally(() => {
            this._diagnosticQueueState = { state: 'idle' };
            this.triggerDiagnosticQueue();
        });
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    getLocale() {
        return vscode_1.env.language;
    }
    async $start() {
        if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection = this.activeConnection();
        if (connection === undefined) {
            throw new Error(`Starting server failed`);
        }
        return connection;
    }
    async createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count).catch((error) => this.error(`Handling connection error failed`, error));
        };
        let closeHandler = () => {
            this.handleConnectionClosed().catch((error) => this.error(`Handling connection close failed`, error));
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8');
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
    }
    async handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.$state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._connection !== undefined) {
                this._connection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
            try {
                handlerResult = await this._clientOptions.errorHandler.closed();
            }
            catch (error) {
                // Ignore errors coming from the error handler.
            }
        }
        this._connection = undefined;
        if (handlerResult.action === CloseAction.DoNotRestart) {
            this.error(handlerResult.message ?? 'Connection to server got closed. Server will not be restarted.', undefined, handlerResult.handled === true ? false : 'force');
            this.cleanUp('stop');
            if (this.$state === ClientState.Starting) {
                this.$state = ClientState.StartFailed;
            }
            else {
                this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = undefined;
        }
        else if (handlerResult.action === CloseAction.Restart) {
            this.info(handlerResult.message ?? 'Connection to server got closed. Server will restart.', !handlerResult.handled);
            this.cleanUp('restart');
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = undefined;
            this.start().catch((error) => this.error(`Restarting server failed`, error, 'force'));
        }
    }
    async handleConnectionError(error, message, count) {
        const handlerResult = await this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
            this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, undefined, handlerResult.handled === true ? false : 'force');
            this.stop().catch((error) => {
                this.error(`Stopping server failed`, error, false);
            });
        }
    }
    hookConfigurationChanged(connection) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        }));
    }
    refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        }).catch((error) => { this.error(`Updating trace failed with error`, error, false); });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === undefined || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
            return false;
        }
        return feature.handles(textDocument);
    }
    registerBuiltinFeatures() {
        const pendingFullTextDocumentChanges = new Map();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this._didChangeTextDocumentFeature = new textSynchronization_1.DidChangeTextDocumentFeature(this, pendingFullTextDocumentChanges);
        this._didChangeTextDocumentFeature.onPendingChangeAdded(() => {
            this.triggerPendingChangeDelivery();
        });
        this.registerFeature(this._didChangeTextDocumentFeature);
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments, pendingFullTextDocumentChanges));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        // We only register the workspace folder feature if the client is not locked
        // to a specific workspace folder.
        if (this.clientOptions.workspaceFolder === undefined) {
            this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, 'workspace').applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, 'window');
        const showMessage = (0, features_1.ensure)(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, 'general');
        generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = {
            parser: 'marked',
            version: '1.1.0',
        };
        generalCapabilities.positionEncodings = ['utf-16'];
        if (this._clientOptions.markdown.supportHtml) {
            generalCapabilities.markdown.allowedTags = ['ul', 'li', 'p', 'code', 'blockquote', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'em', 'pre', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'div', 'del', 'a', 'strong', 'br', 'img', 'span'];
        }
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        const documentSelector = this._clientOptions.documentSelector;
        for (const feature of this._features) {
            if (Is.func(feature.preInitialize)) {
                feature.preInitialize(this._capabilities, documentSelector);
            }
        }
        for (const feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    async handleRegistrationRequest(params) {
        // We will not receive a registration call before a client is running
        // from a server. However if we stop or shutdown we might which might
        // try to restart the server. So ignore registrations if we are not running
        if (!this.isRunning()) {
            for (const registration of params.registrations) {
                this._ignoredRegistrations.add(registration.id);
            }
            return;
        }
        for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === undefined) {
                return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
                id: registration.id,
                registerOptions: options
            };
            try {
                feature.register(data);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    async handleUnregistrationRequest(params) {
        for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) {
                continue;
            }
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
                return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
            }
            feature.unregister(unregistration.id);
        }
    }
    async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        // Make sure we convert workspace edits one after the other. Otherwise
        // we might execute a workspace edit received first after we received another
        // one since the conversion might race.
        const converted = await this.workspaceEditLock.lock(() => {
            return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        const openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    const changeUri = this._p2c.asUri(change.textDocument.uri).toString();
                    const textDocument = openTextDocuments.get(changeUri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => { return { applied: value }; }));
    }
    handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            // The connection got disposed while we were waiting for a response.
            // Simply return the default value. Is the best we can do.
            if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
                return defaultValue;
            }
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
                if (token !== undefined && token.isCancellationRequested) {
                    return defaultValue;
                }
                else {
                    if (error.data !== undefined) {
                        throw new features_1.LSPCancellationError(error.data);
                    }
                    else {
                        throw new vscode_1.CancellationError();
                    }
                }
            }
            else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
                if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method) || BaseLanguageClient.CancellableResolveCalls.has(type.method)) {
                    throw new vscode_1.CancellationError();
                }
                else {
                    return defaultValue;
                }
            }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.RequestsToCancelOnContentModified = new Set([
    vscode_languageserver_protocol_1.SemanticTokensRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
]);
BaseLanguageClient.CancellableResolveCalls = new Set([
    vscode_languageserver_protocol_1.CompletionResolveRequest.method,
    vscode_languageserver_protocol_1.CodeLensResolveRequest.method,
    vscode_languageserver_protocol_1.CodeActionResolveRequest.method,
    vscode_languageserver_protocol_1.InlayHintResolveRequest.method,
    vscode_languageserver_protocol_1.DocumentLinkResolveRequest.method,
    vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.method
]);
class ConsoleLogger {
    error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
    }
    warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
    }
    info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
    }
    log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler, options) {
    const logger = new ConsoleLogger();
    const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    const result = {
        listen: () => connection.listen(),
        sendRequest: connection.sendRequest,
        onRequest: connection.onRequest,
        hasPendingResponse: connection.hasPendingResponse,
        sendNotification: connection.sendNotification,
        onNotification: connection.onNotification,
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === undefined) {
                return connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => {
            // This needs to return and MUST not be await to avoid any async
            // scheduling. Otherwise messages might overtake each other.
            return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
            // This needs to return and MUST not be await to avoid any async
            // scheduling. Otherwise messages might overtake each other.
            return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined);
        },
        exit: () => {
            // This needs to return and MUST not be await to avoid any async
            // scheduling. Otherwise messages might overtake each other.
            return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));


/***/ }),

/***/ 8430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeActionFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
class CodeActionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        // We can only resolve the edit property.
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
        cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = async (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: await client.code2ProtocolConverter.asCodeActionContext(context, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (token.isCancellationRequested || values === null || values === undefined) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeActionResult(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCodeAction = async (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client.code2ProtocolConverter.asCodeAction(item, token), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return item;
                            }
                            return client.protocol2CodeConverter.asCodeAction(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
exports.CodeActionFeature = CodeActionFeature;


/***/ }),

/***/ 1798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(1398);
const proto = __webpack_require__(7354);
const Is = __webpack_require__(8319);
const async = __webpack_require__(5721);
const protocolCompletionItem_1 = __webpack_require__(7652);
const protocolCodeLens_1 = __webpack_require__(5588);
const protocolDocumentLink_1 = __webpack_require__(7424);
const protocolCodeAction_1 = __webpack_require__(9206);
const protocolDiagnostic_1 = __webpack_require__(7894);
const protocolCallHierarchyItem_1 = __webpack_require__(8717);
const protocolTypeHierarchyItem_1 = __webpack_require__(7321);
const protocolWorkspaceSymbol_1 = __webpack_require__(6144);
const protocolInlayHint_1 = __webpack_require__(7511);
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asTextDocumentItem(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentItem(textDocument)
        };
    }
    function isTextDocumentChangeEvent(value) {
        const candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        const candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg0, arg1, arg2) {
        if (isTextDocument(arg0)) {
            const result = {
                textDocument: {
                    uri: _uriConverter(arg0.uri),
                    version: arg0.version
                },
                contentChanges: [{ text: arg0.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg0)) {
            const uri = arg1;
            const version = arg2;
            const result = {
                textDocument: {
                    uri: _uriConverter(uri),
                    version: version
                },
                contentChanges: arg0.contentChanges.map((change) => {
                    const range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value, token) {
        return async.map(value, asPosition, token);
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items, token) {
        if (items === undefined || items === null) {
            return items;
        }
        return async.map(items, asDiagnostic, token);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is.string(item.label)) {
            label = item.label;
        }
        else {
            label = item.label.label;
            if (labelDetailsSupport && (item.label.detail !== undefined || item.label.description !== undefined)) {
                labelDetails = { detail: item.label.detail, description: item.label.description };
            }
        }
        let result = { label: label };
        if (labelDetails !== undefined) {
            result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = proto.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    async function asCodeAction(item, token) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = await asDiagnostics(item.diagnostics, token);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    async function asCodeActionContext(context, token) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
    }
    function asCodeActionTriggerKind(kind) {
        switch (kind) {
            case code.CodeActionTriggerKind.Invoke:
                return proto.CodeActionTriggerKind.Invoked;
            case code.CodeActionTriggerKind.Automatic:
                return proto.CodeActionTriggerKind.Automatic;
            default:
                return undefined;
        }
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asInlineValueContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asTypeHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange),
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default
            ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data }
            : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== '') {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asInlayHint(item) {
        const label = typeof item.label === 'string'
            ? item.label
            : item.label.map(asInlayHintLabelPart);
        const result = proto.InlayHint.create(asPosition(item.position), label);
        if (item.kind !== undefined) {
            result.kind = item.kind;
        }
        if (item.textEdits !== undefined) {
            result.textEdits = asTextEdits(item.textEdits);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        if (item.paddingLeft !== undefined) {
            result.paddingLeft = item.paddingLeft;
        }
        if (item.paddingRight !== undefined) {
            result.paddingRight = item.paddingRight;
        }
        if (item instanceof protocolInlayHint_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        return result;
    }
    function asInlayHintLabelPart(item) {
        const result = proto.InlayHintLabelPart.create(item.value);
        if (item.location !== undefined) {
            result.location = asLocation(item.location);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        const result = {
            kind: proto.MarkupKind.Markdown,
            value: value.value
        };
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asInlineValueContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asInlayHint,
        asWorkspaceSymbol
    };
}
exports.createConverter = createConverter;


/***/ }),

/***/ 8140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeLensFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
class CodeLensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeLenses(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return codeLens;
                            }
                            return client.protocol2CodeConverter.asCodeLens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token, error, codeLens);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
}
exports.CodeLensFeature = CodeLensFeature;


/***/ }),

/***/ 3515:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class ColorProviderFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorPresentations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;


/***/ }),

/***/ 6535:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompletionItemFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
class CompletionItemFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = new Map();
    }
    fillClientCapabilities(capabilities) {
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
                properties: ['documentation', 'detail', 'additionalTextEdits']
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
            itemDefaults: [
                'commitCharacters', 'editRange', 'insertTextFormat', 'insertTextMode'
            ]
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token, error, null);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item, !!this.labelDetailsSupport.get(id)), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asCompletionItem(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
    }
}
exports.CompletionItemFeature = CompletionItemFeature;


/***/ }),

/***/ 5199:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const Is = __webpack_require__(8319);
const UUID = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
/**
 * Configuration pull model. From server to client.
 */
class ConfigurationFeature {
    constructor(client) {
        this._client = client;
    }
    getState() {
        return { kind: 'static' };
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = toJSONObject(vscode_1.workspace.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = toJSONObject(config.get(section.substr(index + 1)));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = toJSONObject(config.get(key));
                }
            }
        }
        if (result === undefined) {
            result = null;
        }
        return result;
    }
    dispose() {
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[key] = toJSONObject(obj[key]);
                }
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
class SyncConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this.isDisposed = false;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize?.configurationSection;
        if (section !== undefined) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== undefined) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (const disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
        this.isDisposed = true;
    }
    onDidChangeConfiguration(configurationSection, event) {
        if (this.isDisposed) {
            return;
        }
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== undefined && event !== undefined) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        const didChangeConfiguration = async (sections) => {
            if (sections === undefined) {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            }
            else {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
            }
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(undefined, resource).get(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
            }
        }
        return result;
    }
}
exports.SyncConfigurationFeature = SyncConfigurationFeature;


/***/ }),

/***/ 7061:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class DeclarationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDeclarationResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DeclarationFeature = DeclarationFeature;


/***/ }),

/***/ 600:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class DefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DefinitionFeature = DefinitionFeature;


/***/ }),

/***/ 9214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
const minimatch = __webpack_require__(6045);
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const uuid_1 = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var vsdiag;
(function (vsdiag) {
    let DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind) {
        DocumentDiagnosticReportKind["full"] = "full";
        DocumentDiagnosticReportKind["unChanged"] = "unChanged";
    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));
})(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
var DiagnosticPullMode;
(function (DiagnosticPullMode) {
    DiagnosticPullMode["onType"] = "onType";
    DiagnosticPullMode["onSave"] = "onSave";
})(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
/**
 * Manages the open tabs. We don't directly use the tab API since for
 * diagnostics we need to de-dupe tabs that show the same resources since
 * we pull on the model not the UI.
 */
class Tabs {
    constructor() {
        this.open = new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
            if (event.closed.length === 0 && event.opened.length === 0) {
                return;
            }
            const oldTabs = this.open;
            const currentTabs = new Set();
            Tabs.fillTabResources(currentTabs);
            const closed = new Set();
            const opened = new Set(currentTabs);
            for (const tab of oldTabs.values()) {
                if (currentTabs.has(tab)) {
                    opened.delete(tab);
                }
                else {
                    closed.add(tab);
                }
            }
            this.open = currentTabs;
            if (closed.size > 0) {
                const toFire = new Set();
                for (const item of closed) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onClose.fire(toFire);
            }
            if (opened.size > 0) {
                const toFire = new Set();
                for (const item of opened) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onOpen.fire(toFire);
            }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== undefined) {
            this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        }
        else {
            this.disposable = { dispose: () => { } };
        }
    }
    get onClose() {
        return this._onClose.event;
    }
    get onOpen() {
        return this._onOpen.event;
    }
    dispose() {
        this.disposable.dispose();
    }
    isActive(document) {
        return document instanceof vscode_1.Uri
            ? vscode_1.window.activeTextEditor?.document.uri === document
            : vscode_1.window.activeTextEditor?.document === document;
    }
    isVisible(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.open.has(uri.toString());
    }
    getTabResources() {
        const result = new Set();
        Tabs.fillTabResources(new Set(), result);
        return result;
    }
    static fillTabResources(strings, uris) {
        const seen = strings ?? new Set();
        for (const group of vscode_1.window.tabGroups.all) {
            for (const tab of group.tabs) {
                const input = tab.input;
                let uri;
                if (input instanceof vscode_1.TabInputText) {
                    uri = input.uri;
                }
                else if (input instanceof vscode_1.TabInputTextDiff) {
                    uri = input.modified;
                }
                if (uri !== undefined && !seen.has(uri.toString())) {
                    seen.add(uri.toString());
                    uris !== undefined && uris.add(uri);
                }
            }
        }
    }
}
var PullState;
(function (PullState) {
    PullState[PullState["document"] = 1] = "document";
    PullState[PullState["workspace"] = 2] = "workspace";
})(PullState || (PullState = {}));
var DocumentOrUri;
(function (DocumentOrUri) {
    function asKey(document) {
        return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
    }
    DocumentOrUri.asKey = asKey;
})(DocumentOrUri || (DocumentOrUri = {}));
class DocumentPullStateTracker {
    constructor() {
        this.documentPullStates = new Map();
        this.workspacePullStates = new Map();
    }
    track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1]
            : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId: undefined };
            states.set(key, state);
        }
        return state;
    }
    update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1, arg2]
            : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
        }
        else {
            state.pulledVersion = version;
            state.resultId = resultId;
        }
    }
    unTrack(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
    }
    tracks(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
    }
    getResultId(kind, document) {
        const key = DocumentOrUri.asKey(document);
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
    }
    getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
                value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== undefined) {
                result.push({ uri, value: value.resultId });
            }
        }
        return result;
    }
}
class DiagnosticRequestor {
    constructor(client, tabs, options) {
        this.client = client;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
    }
    knows(kind, document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());
    }
    forget(kind, document) {
        this.documentStates.unTrack(kind, document);
    }
    pull(document, cb) {
        if (this.isDisposed) {
            return;
        }
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
            if (cb) {
                cb();
            }
        }, (error) => {
            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
    }
    async pullAsync(document, version) {
        if (this.isDisposed) {
            return;
        }
        const isUri = document instanceof vscode_1.Uri;
        const uri = isUri ? document : document.uri;
        const key = uri.toString();
        version = isUri ? version : document.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri
            ? this.documentStates.track(PullState.document, document, version)
            : this.documentStates.track(PullState.document, document);
        if (currentRequestState === undefined) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, document: document, version: version, tokenSource });
            let report;
            let afterState;
            try {
                report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            }
            catch (error) {
                if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, document };
                }
                if (afterState === undefined && error instanceof vscode_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, document };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState ?? this.openRequests.get(key);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
                this.diagnostics.delete(uri);
                return;
            }
            this.openRequests.delete(key);
            if (!this.tabs.isVisible(document)) {
                this.documentStates.unTrack(PullState.document, document);
                return;
            }
            if (afterState.state === RequestStateKind.outDated) {
                return;
            }
            // report is only undefined if the request has thrown.
            if (report !== undefined) {
                if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    this.diagnostics.set(uri, report.items);
                }
                documentState.pulledVersion = version;
                documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
                this.pull(document);
            }
        }
        else {
            if (currentRequestState.state === RequestStateKind.active) {
                // Cancel the current request and reschedule a new one when the old one returned.
                currentRequestState.tokenSource.cancel();
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
            else if (currentRequestState.state === RequestStateKind.outDated) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
        }
    }
    forgetDocument(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
            // If we run workspace diagnostic pull a last time for the diagnostics
            // and the rely on getting them from the workspace result.
            if (request !== undefined) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document });
            }
            else {
                this.pull(document, () => {
                    this.forget(PullState.document, document);
                });
            }
        }
        else {
            // We have normal pull or inter file dependencies. In this case we
            // clear the diagnostics (to have the same start as after startup).
            // We also cancel outstanding requests.
            if (request !== undefined) {
                if (request.state === RequestStateKind.active) {
                    request.tokenSource.cancel();
                }
                this.openRequests.set(key, { state: RequestStateKind.outDated, document: document });
            }
            this.diagnostics.delete(uri);
            this.forget(PullState.document, document);
        }
    }
    pullWorkspace() {
        if (this.isDisposed) {
            return;
        }
        this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
            }, 2000);
        }, (error) => {
            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
                this.client.error(`Workspace diagnostic pull failed.`, error, false);
                this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
                this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                    this.pullWorkspace();
                }, 2000);
            }
        });
    }
    async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
            return;
        }
        if (this.workspaceCancellation !== undefined) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = undefined;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
                uri: this.client.protocol2CodeConverter.asUri(item.uri),
                value: item.value
            };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            if (!chunk || this.isDisposed) {
                return;
            }
            for (const item of chunk.items) {
                if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    // Favour document pull result over workspace results. So skip if it is tracked
                    // as a document result.
                    if (!this.documentStates.tracks(PullState.document, item.uri)) {
                        this.diagnostics.set(item.uri, item.items);
                    }
                }
                this.documentStates.update(PullState.workspace, item.uri, item.version ?? undefined, item.resultId);
            }
        });
    }
    createProvider() {
        const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document, previousResultId, token) => {
                const provideDiagnostics = (document, previousResultId, token) => {
                    const params = {
                        identifier: this.options.identifier,
                        textDocument: { uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri) },
                        previousResultId: previousResultId
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async (result) => {
                        if (result === undefined || result === null || this.isDisposed || token.isCancellationRequested) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                        }
                        if (result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token) };
                        }
                        else {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result.resultId };
                        }
                    }, (error) => {
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics)
                    : provideDiagnostics(document, previousResultId, token);
            }
        };
        if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
                const convertReport = async (report) => {
                    if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.full,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version,
                            items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                        };
                    }
                    else {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version
                        };
                    }
                };
                const convertPreviousResultIds = (resultIds) => {
                    const converted = [];
                    for (const item of resultIds) {
                        converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                    }
                    return converted;
                };
                const provideDiagnostics = (resultIds, token) => {
                    const partialResultToken = (0, uuid_1.generateUuid)();
                    const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                        if (partialResult === undefined || partialResult === null) {
                            resultReporter(null);
                            return;
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of partialResult.items) {
                            try {
                                converted.items.push(await convertReport(item));
                            }
                            catch (error) {
                                this.client.error(`Converting workspace diagnostics failed.`, error);
                            }
                        }
                        resultReporter(converted);
                    });
                    const params = {
                        identifier: this.options.identifier,
                        previousResultIds: convertPreviousResultIds(resultIds),
                        partialResultToken: partialResultToken
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async (result) => {
                        if (token.isCancellationRequested) {
                            return { items: [] };
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of result.items) {
                            converted.items.push(await convertReport(item));
                        }
                        disposable.dispose();
                        resultReporter(converted);
                        return { items: [] };
                    }, (error) => {
                        disposable.dispose();
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideWorkspaceDiagnostics
                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics)
                    : provideDiagnostics(resultIds, token, resultReporter);
            };
        }
        return result;
    }
    dispose() {
        this.isDisposed = true;
        // Cancel and clear workspace pull if present.
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        // Cancel all request and mark open requests as outdated.
        for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        // cleanup old diagnostics
        this.diagnostics.dispose();
    }
}
class BackgroundScheduler {
    constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
    }
    add(document) {
        if (this.isDisposed === true) {
            return;
        }
        const key = DocumentOrUri.asKey(document);
        if (this.documents.has(key)) {
            return;
        }
        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
    }
    remove(document) {
        const key = DocumentOrUri.asKey(document);
        this.documents.delete(key);
        // No more documents. Stop background activity.
        if (this.documents.size === 0) {
            this.stop();
        }
        else if (key === this.endDocumentKey()) {
            // Make sure we have a correct last document. It could have
            this.endDocument = this.documents.last;
        }
    }
    trigger() {
        if (this.isDisposed === true) {
            return;
        }
        // We have a round running. So simply make sure we run up to the
        // last document
        if (this.intervalHandle !== undefined) {
            this.endDocument = this.documents.last;
            return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            const document = this.documents.first;
            if (document !== undefined) {
                const key = DocumentOrUri.asKey(document);
                this.diagnosticRequestor.pull(document);
                this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
                if (key === this.endDocumentKey()) {
                    this.stop();
                }
            }
        }, 200);
    }
    dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
    }
    stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = undefined;
        this.endDocument = undefined;
    }
    endDocumentKey() {
        return this.endDocument !== undefined ? DocumentOrUri.asKey(this.endDocument) : undefined;
    }
}
class DiagnosticFeatureProviderImpl {
    constructor(client, tabs, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
            const selector = options.documentSelector;
            if (diagnosticPullOptions.match !== undefined) {
                return diagnosticPullOptions.match(selector, resource);
            }
            for (const filter of selector) {
                if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                    continue;
                }
                // The filter is a language id. We can't determine if it matches
                // so we return false.
                if (typeof filter === 'string') {
                    return false;
                }
                if (filter.language !== undefined && filter.language !== '*') {
                    return false;
                }
                if (filter.scheme !== undefined && filter.scheme !== '*' && filter.scheme !== resource.scheme) {
                    return false;
                }
                if (filter.pattern !== undefined) {
                    const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
                    if (!matcher.makeRe()) {
                        return false;
                    }
                    if (!matcher.match(resource.fsPath)) {
                        return false;
                    }
                }
            }
            return true;
        };
        const matches = (document) => {
            return document instanceof vscode_1.Uri
                ? matchResource(document)
                : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);
        };
        const isActiveDocument = (document) => {
            return document instanceof vscode_1.Uri
                ? this.activeTextDocument?.uri.toString() === document.toString()
                : this.activeTextDocument === document;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
            if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {
                return;
            }
            this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor?.document;
            if (oldActive !== undefined) {
                addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== undefined) {
                this.backgroundScheduler.remove(this.activeTextDocument);
            }
        });
        // For pull model diagnostics we pull for documents visible in the UI.
        // From an eventing point of view we still rely on open document events
        // and filter the documents that are not visible in the UI instead of
        // listening to Tab events. Major reason is event timing since we need
        // to ensure that the pull is send after the document open has reached
        // the server.
        // We always pull on open.
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.textDocument;
            // We already know about this document. This can happen via a tab open.
            if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                return;
            }
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }));
        tabs.onOpen((opened) => {
            for (const resource of opened) {
                // We already know about this document. This can happen via a document open.
                if (this.diagnosticRequestor.knows(PullState.document, resource)) {
                    continue;
                }
                const uriStr = resource.toString();
                let textDocument;
                for (const item of vscode_1.workspace.textDocuments) {
                    if (uriStr === item.uri.toString()) {
                        textDocument = item;
                        break;
                    }
                }
                // We have an open document for the resource behind the tab.
                if (textDocument !== undefined && matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
                }
                else if (matches(resource)) {
                    // Check if the resource matches
                    this.diagnosticRequestor.pull(resource, () => { addToBackgroundIfNeeded(resource); });
                }
            }
        });
        // Pull all diagnostics for documents that are already open
        const pulledTextDocuments = new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
                pulledTextDocuments.add(textDocument.uri.toString());
            }
        }
        // Pull all tabs if not already pulled as text document
        if (diagnosticPullOptions.onTabs === true) {
            for (const resource of tabs.getTabResources()) {
                if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
                    this.diagnosticRequestor.pull(resource, () => { addToBackgroundIfNeeded(resource); });
                }
            }
        }
        // We don't need to pull on tab open since we will receive a document open as well later on
        // and that event allows us to use a document for a match check which will have a set
        // language id.
        if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
                const textDocument = event.textDocument;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
                const textDocument = event.textDocument;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                    this.diagnosticRequestor.pull(event.textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        // When the document closes clear things up
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
            this.cleanUpDocument(event.textDocument);
        }));
        // Same when a tabs closes.
        tabs.onClose((closed) => {
            for (const document of closed) {
                this.cleanUpDocument(document);
            }
        });
        // We received a did change from the server.
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
                if (matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument);
                }
            }
        });
        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.
        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {
            this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
    }
    get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
    }
    get diagnostics() {
        return this.diagnosticRequestor.provider;
    }
    cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
            this.diagnosticRequestor.forgetDocument(document);
            this.backgroundScheduler.remove(document);
        }
    }
}
class DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
        // We first need to decide how a UI will look with related documents.
        // An easy implementation would be to only show related diagnostics for
        // the active editor.
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    dispose() {
        if (this.tabs !== undefined) {
            this.tabs.dispose();
            this.tabs = undefined;
        }
        super.dispose();
    }
    registerLanguageProvider(options) {
        if (this.tabs === undefined) {
            this.tabs = new Tabs();
        }
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;


/***/ }),

/***/ 9014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentHighlightFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class DocumentHighlightFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentHighlights(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentHighlightFeature = DocumentHighlightFeature;


/***/ }),

/***/ 7656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class DocumentLinkFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentLinks(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return link;
                            }
                            return client.protocol2CodeConverter.asDocumentLink(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token, error, link);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentLinkFeature = DocumentLinkFeature;


/***/ }),

/***/ 9228:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
exports.SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
exports.SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
class DocumentSymbolFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: exports.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: exports.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = async (document, token) => {
                    try {
                        const data = await client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token);
                        if (token.isCancellationRequested || data === undefined || data === null) {
                            return null;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            const first = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                                return await client.protocol2CodeConverter.asDocumentSymbols(data, token);
                            }
                            else {
                                return await client.protocol2CodeConverter.asSymbolInformations(data, token);
                            }
                        }
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        const metaData = options.label !== undefined ? { label: options.label } : undefined;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
    }
}
exports.DocumentSymbolFeature = DocumentSymbolFeature;


/***/ }),

/***/ 9073:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteCommandFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
class ExecuteCommandFeature {
    constructor(client) {
        this._client = client;
        this._commands = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._commands.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, undefined, error, undefined);
            });
        };
        if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
exports.ExecuteCommandFeature = ExecuteCommandFeature;


/***/ }),

/***/ 4294:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const Is = __webpack_require__(8319);
const UUID = __webpack_require__(9032);
class LSPCancellationError extends vscode_1.CancellationError {
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.LSPCancellationError = LSPCancellationError;
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
exports.ensure = ensure;
var StaticFeature;
(function (StaticFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams));
    }
    StaticFeature.is = is;
})(StaticFeature = exports.StaticFeature || (exports.StaticFeature = {}));
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) &&
            Is.func(candidate.unregister) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature = exports.DynamicFeature || (exports.DynamicFeature = {}));
/**
 * An abstract dynamic feature implementation that operates on documents (e.g. text
 * documents or notebooks).
 */
class DynamicDocumentFeature {
    constructor(client) {
        this._client = client;
    }
    /**
     * Returns the state the feature is in.
     */
    getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
            count++;
            for (const document of vscode_1.workspace.textDocuments) {
                if (vscode_1.languages.match(selector, document) > 0) {
                    return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
                }
            }
        }
        const registrations = count > 0;
        return { kind: 'document', id: this.registrationType.method, registrations, matches: false };
    }
}
exports.DynamicDocumentFeature = DynamicDocumentFeature;
/**
 * An abstract base class to implement features that react to events
 * emitted from text documents.
 */
class TextDocumentEventFeature extends DynamicDocumentFeature {
    constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument) > 0) {
                return true;
            }
        }
        return false;
    }
    getStateInfo() {
        return [this._selectors.values(), false];
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event((data) => {
                this.callback(data).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed.`, error);
                });
            });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    async callback(data) {
        const doSend = async (data) => {
            const params = this._createParams(data);
            await this._client.sendNotification(this._type, params);
            this.notificationSent(this.getTextDocument(data), this._type, params);
        };
        if (this.matches(data)) {
            const middleware = this._middleware();
            return middleware ? middleware(data, (data) => doSend(data)) : doSend(data);
        }
    }
    matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
            return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document) > 0) {
                return {
                    send: (data) => {
                        return this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.TextDocumentEventFeature = TextDocumentEventFeature;
/**
 * A abstract feature implementation that registers language providers
 * for text documents using a given document selector.
 */
class TextDocumentLanguageFeature extends DynamicDocumentFeature {
    constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
                continue;
            }
            yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector ?? documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            const options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
class WorkspaceFeature {
    constructor(client, registrationType) {
        this._client = client;
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    getState() {
        const registrations = this._registrations.size > 0;
        return { kind: 'workspace', id: this._registrationType.method, registrations };
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
exports.WorkspaceFeature = WorkspaceFeature;


/***/ }),

/***/ 2485:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const code = __webpack_require__(1398);
const minimatch = __webpack_require__(6045);
const proto = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
class FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
        this._filters = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this._registrationType.method, registrations: this._filters.size > 0 };
    }
    filterSize() {
        return this._filters.size;
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if (capability?.filters !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters }
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getFileType(uri) {
        return FileOperationFeature.getFileType(uri);
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await this.getFileType(uri);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === proto.FileOperationPatternKind.folder) {
                        const fileType = await FileOperationFeature.getFileType(uri);
                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
    }
    static async getFileType(uri) {
        try {
            return (await code.workspace.fs.stat(uri)).type;
        }
        catch (e) {
            return undefined;
        }
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            return this.doSend(filteredEvent, next);
        }
    }
}
class CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {
    constructor() {
        super(...arguments);
        this._fsPathFileTypes = new Map();
    }
    async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
            return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
            this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
    }
    async cacheFileTypes(event, prop) {
        // Calling filter will force the matching logic to run. For any item
        // that requires a getFileType lookup, the overriden getFileType will
        // be called that will cache the result so that when onDidRename fires,
        // it can still be checked even though the item no longer exists on disk
        // in its original location.
        await this.filter(event, prop);
    }
    clearFileTypeCache() {
        this._fsPathFileTypes.clear();
    }
    unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
    dispose() {
        super.dispose();
        if (this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles
            ? middleware.didCreateFiles(event, next)
            : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
    }
    willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles
            ? middleware.didRenameFiles(event, next)
            : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
    }
    willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles
            ? middleware.didDeleteFiles(event, next)
            : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this._client.sendRequest(this._requestType, this._createParams(event), event.token)
                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles
            ? middleware.willCreateFiles(event, next)
            : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles
            ? middleware.willRenameFiles(event, next)
            : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles
            ? middleware.willDeleteFiles(event, next)
            : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;


/***/ }),

/***/ 9084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemWatcherFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class FileSystemWatcherFeature {
    constructor(client, notifyFileEvent) {
        this._client = client;
        this._notifyFileEvent = notifyFileEvent;
        this._watchers = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._watchers.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').relativePatternSupport = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        const disposables = [];
        for (const watcher of data.registerOptions.watchers) {
            const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
            if (globPattern === undefined) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== undefined && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
exports.FileSystemWatcherFeature = FileSystemWatcherFeature;


/***/ }),

/***/ 3963:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class FoldingRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asFoldingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;


/***/ }),

/***/ 7298:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const features_1 = __webpack_require__(4294);
var FileFormattingOptions;
(function (FileFormattingOptions) {
    function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    FileFormattingOptions.fromConfiguration = fromConfiguration;
})(FileFormattingOptions || (FileFormattingOptions = {}));
class DocumentFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentFormattingFeature = DocumentFormattingFeature;
class DocumentRangeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
class DocumentOnTypeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;


/***/ }),

/***/ 1507:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class HoverFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const hoverCapability = ((0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asHover(result);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.HoverFeature = HoverFeature;


/***/ }),

/***/ 191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class ImplementationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ImplementationFeature = ImplementationFeature;


/***/ }),

/***/ 2767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintsFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class InlayHintsFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlayHint');
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
            properties: ['tooltip', 'textEdits', 'label.tooltip', 'label.location', 'label.command']
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlayHint').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlayHints.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document, viewPort, token) => {
                const client = this._client;
                const provideInlayHints = async (document, viewPort, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort)
                    };
                    try {
                        const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlayHints(values, token);
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.provideInlayHints
                    ? middleware.provideInlayHints(document, viewPort, token, provideInlayHints)
                    : provideInlayHints(document, viewPort, token);
            }
        };
        provider.resolveInlayHint = options.resolveProvider === true
            ? (hint, token) => {
                const client = this._client;
                const resolveInlayHint = async (item, token) => {
                    try {
                        const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        const result = client.protocol2CodeConverter.asInlayHint(value, token);
                        return token.isCancellationRequested ? null : result;
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.resolveInlayHint
                    ? middleware.resolveInlayHint(hint, token, resolveInlayHint)
                    : resolveInlayHint(hint, token);
            }
            : undefined;
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlayHints: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlayHintsFeature = InlayHintsFeature;


/***/ }),

/***/ 3131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class InlineValueFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlineValue').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlineValue').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlineValues.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document, viewPort, context, token) => {
                const client = this._client;
                const provideInlineValues = (document, viewPort, context, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort),
                        context: client.code2ProtocolConverter.asInlineValueContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token).then((values) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlineValues(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideInlineValues
                    ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues)
                    : provideInlineValues(document, viewPort, context, token);
            }
        };
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlineValues: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlineValueFeature = InlineValueFeature;


/***/ }),

/***/ 4913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingFeature = void 0;
const code = __webpack_require__(1398);
const proto = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class LinkedEditingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'linkedEditingRange');
        linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideLinkedEditingRanges: (document, position, token) => {
                const client = this._client;
                const provideLinkedEditing = (document, position, token) => {
                    return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asLinkedEditingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideLinkedEditingRange
                    ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing)
                    : provideLinkedEditing(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.LinkedEditingFeature = LinkedEditingFeature;


/***/ }),

/***/ 1872:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentSyncFeature = void 0;
const vscode = __webpack_require__(1398);
const minimatch = __webpack_require__(6045);
const proto = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const Is = __webpack_require__(8319);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var Converter;
(function (Converter) {
    let c2p;
    (function (c2p) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
            return {
                version: notebookDocument.version,
                uri: base.asUri(notebookDocument.uri)
            };
        }
        c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
            if (Object.keys(notebookDocument.metadata).length > 0) {
                result.metadata = asMetadata(notebookDocument.metadata);
            }
            return result;
        }
        c2p.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
            return cells.map(cell => asNotebookCell(cell, base));
        }
        c2p.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
            const seen = new Set();
            return deepCopy(seen, metadata);
        }
        c2p.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
            if (Object.keys(cell.metadata).length > 0) {
                result.metadata = asMetadata(cell.metadata);
            }
            if (cell.executionSummary !== undefined && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
                result.executionSummary = {
                    executionOrder: cell.executionSummary.executionOrder,
                    success: cell.executionSummary.success
                };
            }
            return result;
        }
        c2p.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
            switch (kind) {
                case vscode.NotebookCellKind.Markup:
                    return proto.NotebookCellKind.Markup;
                case vscode.NotebookCellKind.Code:
                    return proto.NotebookCellKind.Code;
            }
        }
        function deepCopy(seen, value) {
            if (seen.has(value)) {
                throw new Error(`Can't deep copy cyclic structures.`);
            }
            if (Array.isArray(value)) {
                const result = [];
                for (const elem of value) {
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result.push(deepCopy(seen, elem));
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result.push(elem);
                    }
                }
                return result;
            }
            else {
                const props = Object.keys(value);
                const result = Object.create(null);
                for (const prop of props) {
                    const elem = value[prop];
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result[prop] = deepCopy(seen, elem);
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result[prop] = elem;
                    }
                }
                return result;
            }
        }
        function asTextContentChange(event, base) {
            const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);
            return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p.asTextContentChange = asTextContentChange;
        function asNotebookDocumentChangeEvent(event, base) {
            const result = Object.create(null);
            if (event.metadata) {
                result.metadata = Converter.c2p.asMetadata(event.metadata);
            }
            if (event.cells !== undefined) {
                const cells = Object.create(null);
                const changedCells = event.cells;
                if (changedCells.structure) {
                    cells.structure = {
                        array: {
                            start: changedCells.structure.array.start,
                            deleteCount: changedCells.structure.array.deleteCount,
                            cells: changedCells.structure.array.cells !== undefined ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : undefined
                        },
                        didOpen: changedCells.structure.didOpen !== undefined
                            ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument)
                            : undefined,
                        didClose: changedCells.structure.didClose !== undefined
                            ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument)
                            : undefined
                    };
                }
                if (changedCells.data !== undefined) {
                    cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base));
                }
                if (changedCells.textContent !== undefined) {
                    cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base));
                }
                if (Object.keys(cells).length > 0) {
                    result.cells = cells;
                }
            }
            return result;
        }
        c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
    })(c2p = Converter.c2p || (Converter.c2p = {}));
})(Converter || (Converter = {}));
var $NotebookCell;
(function ($NotebookCell) {
    function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            const deleteCount = (originalEndIndex + 1) - startIndex;
            const newCells = startIndex === modifiedEndIndex + 1 ? undefined : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
            return newCells !== undefined ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        }
        else if (startIndex < modifiedLength) {
            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        }
        else if (startIndex < originalLength) {
            return { start: startIndex, deleteCount: originalLength - startIndex };
        }
        else {
            // The two arrays are the same.
            return undefined;
        }
    }
    $NotebookCell.computeDiff = computeDiff;
    /**
     * We only sync kind, document, execution and metadata to the server. So we only need to compare those.
     */
    function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId ||
            !equalsExecution(one.executionSummary, other.executionSummary)) {
            return false;
        }
        return !compareMetaData || (compareMetaData && equalsMetadata(one.metadata, other.metadata));
    }
    function equalsExecution(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
    }
    function equalsTiming(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.startTime === other.startTime && one.endTime === other.endTime;
    }
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (isObjectLiteral(one) && isObjectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    function isObjectLiteral(value) {
        return value !== null && typeof value === 'object';
    }
    $NotebookCell.isObjectLiteral = isObjectLiteral;
})($NotebookCell || ($NotebookCell = {}));
var $NotebookDocumentFilter;
(function ($NotebookDocumentFilter) {
    function matchNotebook(filter, notebookDocument) {
        if (typeof filter === 'string') {
            return filter === '*' || notebookDocument.notebookType === filter;
        }
        if (filter.notebookType !== undefined && filter.notebookType !== '*' && notebookDocument.notebookType !== filter.notebookType) {
            return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== undefined && filter.scheme !== '*' && uri.scheme !== filter.scheme) {
            return false;
        }
        if (filter.pattern !== undefined) {
            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
            if (!matcher.makeRe()) {
                return false;
            }
            if (!matcher.match(uri.fsPath)) {
                return false;
            }
        }
        return true;
    }
    $NotebookDocumentFilter.matchNotebook = matchNotebook;
})($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
var $NotebookDocumentSyncOptions;
(function ($NotebookDocumentSyncOptions) {
    function asDocumentSelector(options) {
        const selector = options.notebookSelector;
        const result = [];
        for (const element of selector) {
            const notebookType = (typeof element.notebook === 'string' ? element.notebook : element.notebook?.notebookType) ?? '*';
            const scheme = (typeof element.notebook === 'string') ? undefined : element.notebook?.scheme;
            const pattern = (typeof element.notebook === 'string') ? undefined : element.notebook?.pattern;
            if (element.cells !== undefined) {
                for (const cell of element.cells) {
                    result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
                }
            }
            else {
                result.push(asDocumentFilter(notebookType, scheme, pattern, undefined));
            }
        }
        return result;
    }
    $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;
    function asDocumentFilter(notebookType, scheme, pattern, language) {
        return scheme === undefined && pattern === undefined
            ? { notebook: notebookType, language }
            : { notebook: { notebookType, scheme, pattern }, language };
    }
})($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
var SyncInfo;
(function (SyncInfo) {
    function create(cells) {
        return {
            cells,
            uris: new Set(cells.map(cell => cell.document.uri.toString()))
        };
    }
    SyncInfo.create = create;
})(SyncInfo || (SyncInfo = {}));
class NotebookDocumentSyncFeatureProvider {
    constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = new Map();
        this.notebookDidOpen = new Set();
        this.disposables = [];
        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        // open
        vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }, undefined, this.disposables);
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }
        // Notebook document changed.
        vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), undefined, this.disposables);
        //save
        if (this.options.save === true) {
            vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), undefined, this.disposables);
        }
        // close
        vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
            this.didClose(notebookDocument);
            this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, undefined, this.disposables);
    }
    getState() {
        for (const notebook of vscode.workspace.notebookDocuments) {
            const matchingCells = this.getMatchingCells(notebook);
            if (matchingCells !== undefined) {
                return { kind: 'document', id: '$internal', registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: '$internal', registrations: true, matches: false };
    }
    get mode() {
        return 'notebook';
    }
    handles(textDocument) {
        return vscode.languages.match(this.selector, textDocument) > 0;
    }
    didOpenNotebookCellTextDocument(notebookDocument, cell) {
        if (vscode.languages.match(this.selector, cell.document) === 0) {
            return;
        }
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
            // We have never received an open notification for the notebook document.
            // VS Code guarantees that we first get cell document open and then
            // notebook open. So simply wait for the notebook open.
            return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        // In VS Code we receive a notebook open before a cell document open.
        // The document and the cell is synced.
        const cellMatches = this.cellMatches(notebookDocument, cell);
        if (syncInfo !== undefined) {
            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
            if ((cellMatches && cellIsSynced) || (!cellMatches && !cellIsSynced)) {
                // The cell doesn't match and was not synced or it matches and is synced.
                // In both cases nothing to do.
                //
                // Note that if the language mode of a document changes we remove the
                // cell and add it back to update the language mode on the server side.
                return;
            }
            if (cellMatches) {
                // don't use cells from above since there might be more matching cells in the notebook
                // Since we had a matching cell above we will have matching cells now.
                const matchingCells = this.getMatchingCells(notebookDocument);
                if (matchingCells !== undefined) {
                    const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                    if (event !== undefined) {
                        this.doSendChange(event, matchingCells).catch(() => { });
                    }
                }
            }
        }
        else {
            // No sync info. But we have a open event for the notebook document
            // itself. If the cell matches then we need to send an open with
            // exactly that cell.
            if (cellMatches) {
                this.doSendOpen(notebookDocument, [cell]).catch(() => { });
            }
        }
    }
    didChangeNotebookCellTextDocument(notebookDocument, event) {
        // No match with the selector
        if (vscode.languages.match(this.selector, event.document) === 0) {
            return;
        }
        this.doSendChange({
            notebook: notebookDocument,
            cells: { textContent: [event] }
        }, undefined).catch(() => { });
    }
    didCloseNotebookCellTextDocument(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // The notebook document got never synced. So it doesn't matter if a cell
            // document closes.
            return;
        }
        const cellUri = cell.document.uri;
        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
        if (index === -1) {
            // The cell never got synced or it got deleted and we now received the document
            // close event.
            return;
        }
        if (index === 0 && syncInfo.cells.length === 1) {
            // The last cell. Close the notebook document in the server.
            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => { });
        }
        else {
            const newCells = syncInfo.cells.slice();
            const deleted = newCells.splice(index, 1);
            this.doSendChange({
                notebook: notebookDocument,
                cells: {
                    structure: {
                        array: { start: index, deleteCount: 1 },
                        didClose: deleted
                    }
                }
            }, newCells).catch(() => { });
        }
    }
    dispose() {
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
    }
    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== undefined) {
            if (matchingCells !== undefined) {
                const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                if (event !== undefined) {
                    this.doSendChange(event, matchingCells).catch(() => { });
                }
            }
            else {
                this.doSendClose(notebookDocument, []).catch(() => { });
            }
        }
        else {
            // Check if we need to sync the notebook document.
            if (matchingCells === undefined) {
                return;
            }
            this.doSendOpen(notebookDocument, matchingCells).catch(() => { });
        }
    }
    didChangeNotebookDocument(event) {
        const notebookDocument = event.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // We have no changes to the cells. Since the notebook wasn't synced
            // it will not be synced now.
            if (event.contentChanges.length === 0) {
                return;
            }
            // Check if we have new matching cells.
            const cells = this.getMatchingCells(notebookDocument);
            // No matching cells and the notebook never synced. So still no need
            // to sync it.
            if (cells === undefined) {
                return;
            }
            // Open the notebook document and ignore the rest of the changes
            // this the notebooks will be synced with the correct settings.
            this.didOpen(notebookDocument, cells, syncInfo);
        }
        else {
            // The notebook is synced. First check if we have no matching
            // cells anymore and if so close the notebook
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === undefined) {
                this.didClose(notebookDocument, syncInfo);
                return;
            }
            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
            if (newEvent !== undefined) {
                this.doSendChange(newEvent, cells).catch(() => { });
            }
        }
    }
    didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            return;
        }
        this.doSendSave(notebookDocument).catch(() => { });
    }
    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === undefined) {
            return;
        }
        const syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => { });
    }
    async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === undefined) {
            return;
        }
        return this.doSendOpen(notebookDocument, cells);
    }
    async doSendOpen(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            const nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter);
            const cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
            try {
                await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
                    notebookDocument: nb,
                    cellTextDocuments: cellDocuments
                });
            }
            catch (error) {
                this.client.error('Sending DidOpenNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
        return middleware?.didOpen !== undefined ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    async sendDidChangeNotebookDocument(event) {
        return this.doSendChange(event, undefined);
    }
    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
        const send = async (event) => {
            try {
                await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
                    notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),
                    change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)
                });
            }
            catch (error) {
                this.client.error('Sending DidChangeNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        if (event.cells?.structure !== undefined) {
            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
        }
        return middleware?.didChange !== undefined ? middleware?.didChange(event, send) : send(event);
    }
    async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
    }
    async doSendSave(notebookDocument) {
        const send = async (notebookDocument) => {
            try {
                await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) }
                });
            }
            catch (error) {
                this.client.error('Sending DidSaveNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        return middleware?.didSave !== undefined ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
    }
    async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
    }
    async doSendClose(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            try {
                await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) },
                    cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
                });
            }
            catch (error) {
                this.client.error('Sending DidCloseNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
        return middleware?.didClose !== undefined ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
        if (event !== undefined && event.notebook !== notebook) {
            throw new Error('Notebook must be identical');
        }
        const result = {
            notebook: notebook
        };
        if (event?.metadata !== undefined) {
            result.metadata = Converter.c2p.asMetadata(event.metadata);
        }
        let matchingCellsSet;
        if (event?.cellChanges !== undefined && event.cellChanges.length > 0) {
            const data = [];
            // Only consider the new matching cells.
            matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));
            for (const cellChange of event.cellChanges) {
                if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== undefined || cellChange.metadata !== undefined)) {
                    data.push(cellChange.cell);
                }
            }
            if (data.length > 0) {
                result.cells = result.cells ?? {};
                result.cells.data = data;
            }
        }
        if (((event?.contentChanges !== undefined && event.contentChanges.length > 0) || event === undefined) && syncInfo !== undefined && matchingCells !== undefined) {
            // We still have matching cells. Check if the cell changes
            // affect the notebook on the server side.
            const oldCells = syncInfo.cells;
            const newCells = matchingCells;
            // meta data changes are reported using on the cell itself. So we can ignore comparing
            // it which has a positive effect on performance.
            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
            let addedCells;
            let removedCells;
            if (diff !== undefined) {
                addedCells = diff.cells === undefined
                    ? new Map()
                    : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell]));
                removedCells = diff.deleteCount === 0
                    ? new Map()
                    : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));
                // Remove the onces that got deleted and inserted again.
                for (const key of Array.from(removedCells.keys())) {
                    if (addedCells.has(key)) {
                        removedCells.delete(key);
                        addedCells.delete(key);
                    }
                }
                result.cells = result.cells ?? {};
                const didOpen = [];
                const didClose = [];
                if (addedCells.size > 0 || removedCells.size > 0) {
                    for (const cell of addedCells.values()) {
                        didOpen.push(cell);
                    }
                    for (const cell of removedCells.values()) {
                        didClose.push(cell);
                    }
                }
                result.cells.structure = {
                    array: diff,
                    didOpen,
                    didClose
                };
            }
        }
        // The notebook is a property as well.
        return Object.keys(result).length > 1 ? result : undefined;
    }
    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookSelector === undefined) {
            return undefined;
        }
        for (const item of this.options.notebookSelector) {
            if (item.notebook === undefined || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
                const filtered = this.filterCells(notebookDocument, cells, item.cells);
                return filtered.length === 0 ? undefined : filtered;
            }
        }
        return undefined;
    }
    cellMatches(notebookDocument, cell) {
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        return cells !== undefined && cells[0] === cell;
    }
    filterCells(notebookDocument, cells, cellSelector) {
        const filtered = cellSelector !== undefined ? cells.filter((cell) => {
            const cellLanguage = cell.document.languageId;
            return cellSelector.some((filter => (filter.language === '*' || cellLanguage === filter.language)));
        }) : cells;
        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === 'function'
            ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered)
            : filtered;
    }
}
class NotebookDocumentSyncFeature {
    constructor(client) {
        this.client = client;
        this.registrations = new Map();
        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
        // We don't receive an event for cells where the document changes its language mode
        // Since we allow servers to filter on the language mode we fire such an event ourselves.
        vscode.workspace.onDidOpenTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
        vscode.workspace.onDidChangeTextDocument((event) => {
            if (event.contentChanges.length === 0) {
                return;
            }
            const textDocument = event.document;
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument,] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didChangeNotebookCellTextDocument(notebookDocument, event);
                }
            }
        });
        vscode.workspace.onDidCloseTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            // There are two cases when we receive a close for a text document
            // 1: the cell got removed. This is handled in `onDidChangeNotebookCells`
            // 2: the language mode of a cell changed. This keeps the URI stable so
            //    we will still find the cell and the notebook document.
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
    }
    getState() {
        if (this.registrations.size === 0) {
            return { kind: 'document', id: this.registrationType.method, registrations: false, matches: false };
        }
        for (const provider of this.registrations.values()) {
            const state = provider.getState();
            if (state.kind === 'document' && state.registrations === true && state.matches === true) {
                return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: this.registrationType.method, registrations: true, matches: false };
    }
    fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, 'notebookDocument'), 'synchronization');
        synchronization.dynamicRegistration = true;
        synchronization.executionSummarySupport = true;
    }
    preInitialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
    }
    initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
    }
    register(data) {
        const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider);
    }
    unregister(id) {
        const provider = this.registrations.get(id);
        provider && provider.dispose();
    }
    dispose() {
        for (const provider of this.registrations.values()) {
            provider.dispose();
        }
        this.registrations.clear();
    }
    handles(textDocument) {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return false;
        }
        if (this.dedicatedChannel !== undefined && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
            return true;
        }
        for (const provider of this.registrations.values()) {
            if (provider.handles(textDocument)) {
                return true;
            }
        }
        return false;
    }
    getProvider(notebookCell) {
        for (const provider of this.registrations.values()) {
            if (provider.handles(notebookCell.document)) {
                return provider;
            }
        }
        return undefined;
    }
    findNotebookDocumentAndCell(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            for (const cell of notebookDocument.getCells()) {
                if (cell.document.uri.toString() === uri) {
                    return [notebookDocument, cell];
                }
            }
        }
        return [undefined, undefined];
    }
}
exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
NotebookDocumentSyncFeature.CellScheme = 'vscode-notebook-cell';


/***/ }),

/***/ 9870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const progressPart_1 = __webpack_require__(9403);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
    }
    getState() {
        return { kind: 'window', id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
            this.activeParts.delete(part);
        };
        const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
        for (const part of this.activeParts) {
            part.done();
        }
        this.activeParts.clear();
    }
}
exports.ProgressFeature = ProgressFeature;


/***/ }),

/***/ 9403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressPart = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const Is = __webpack_require__(8319);
class ProgressPart {
    constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    done && done(this);
                    break;
            }
        });
    }
    begin(params) {
        this._infinite = params.percentage === undefined;
        // the progress as already been marked as done / canceled. Ignore begin call
        if (this._lspProgressDisposable === undefined) {
            return;
        }
        // Since we don't use commands this will be a silent window progress with a hidden notification.
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            // the progress as already been marked as done / canceled. Ignore begin call
            if (this._lspProgressDisposable === undefined) {
                return;
            }
            this._progress = progress;
            this._cancellationToken = cancellationToken;
            this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress !== undefined && this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            const percentage = Math.max(0, Math.min(params.percentage, 100));
            const delta = Math.max(0, percentage - this._reported);
            this._reported += delta;
            this._progress !== undefined && this._progress.report({ message: params.message, increment: delta });
        }
    }
    cancel() {
        this.cleanup();
        if (this._reject !== undefined) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        this.cleanup();
        if (this._resolve !== undefined) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    cleanup() {
        if (this._lspProgressDisposable !== undefined) {
            this._lspProgressDisposable.dispose();
            this._lspProgressDisposable = undefined;
        }
        if (this._tokenDisposable !== undefined) {
            this._tokenDisposable.dispose();
            this._tokenDisposable = undefined;
        }
        this._progress = undefined;
        this._cancellationToken = undefined;
    }
}
exports.ProgressPart = ProgressPart;


/***/ }),

/***/ 8717:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;


/***/ }),

/***/ 9206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(1398);
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;


/***/ }),

/***/ 5588:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;


/***/ }),

/***/ 7652:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;


/***/ }),

/***/ 7605:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(1398);
const ls = __webpack_require__(7354);
const Is = __webpack_require__(8319);
const async = __webpack_require__(5721);
const protocolCompletionItem_1 = __webpack_require__(7652);
const protocolCodeLens_1 = __webpack_require__(5588);
const protocolDocumentLink_1 = __webpack_require__(7424);
const protocolCodeAction_1 = __webpack_require__(9206);
const protocolDiagnostic_1 = __webpack_require__(7894);
const protocolCallHierarchyItem_1 = __webpack_require__(8717);
const protocolTypeHierarchyItem_1 = __webpack_require__(7321);
const protocolWorkspaceSymbol_1 = __webpack_require__(6144);
const protocolInlayHint_1 = __webpack_require__(7511);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown, supportHtml) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDocumentSelector(selector) {
        const result = [];
        for (const filter of selector) {
            if (typeof filter === 'string') {
                result.push(filter);
            }
            else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
                // We first need to check for the notebook cell filter since a TextDocumentFilter would
                // match both (e.g. the notebook is optional).
                if (typeof filter.notebook === 'string') {
                    result.push({ notebookType: filter.notebook, language: filter.language });
                }
                else {
                    const notebookType = filter.notebook.notebookType ?? '*';
                    result.push({ notebookType: notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
                }
            }
            else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
            }
        }
        return result;
    }
    async function asDiagnostics(diagnostics, token) {
        return async.map(diagnostics, asDiagnostic, token);
    }
    function asDiagnosticsSync(diagnostics) {
        const result = new Array(diagnostics.length);
        for (let i = 0; i < diagnostics.length; i++) {
            result[i] = asDiagnostic(diagnostics[i]);
        }
        return result;
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (typeof diagnostic.code === 'string' || typeof diagnostic.code === 'number') {
                if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                    result.code = {
                        value: diagnostic.code,
                        target: asUri(diagnostic.codeDescription.href)
                    };
                }
                else {
                    result.code = diagnostic.code;
                }
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                // This is for backwards compatibility of a proposed API.
                // We should remove this at some point.
                result.hasDiagnosticCode = true;
                const diagnosticCode = diagnostic.code;
                result.code = {
                    value: diagnosticCode.value,
                    target: asUri(diagnosticCode.target)
                };
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        const result = new Array(relatedInformation.length);
        for (let i = 0; i < relatedInformation.length; i++) {
            const info = relatedInformation[i];
            result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
        }
        return result;
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        return value ? new code.Position(value.line, value.character) : undefined;
    }
    function asRange(value) {
        return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : undefined;
    }
    async function asRanges(items, token) {
        return async.map(items, (range) => {
            return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
        }, token);
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            return asMarkdownString(value);
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        let result;
        if (value === undefined || typeof value === 'string') {
            result = new code.MarkdownString(value);
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    result = new code.MarkdownString(value.value);
                    break;
                case ls.MarkupKind.PlainText:
                    result = new code.MarkdownString();
                    result.appendText(value.value);
                    break;
                default:
                    result = new code.MarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    break;
            }
        }
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    async function asCompletionResult(value, allCommitCharacters, token) {
        if (!value) {
            return undefined;
        }
        if (Array.isArray(value)) {
            return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
        }
        const list = value;
        const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
        const converted = await async.map(list.items, (item) => {
            return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
        }, token);
        return new code.CompletionList(converted, list.isIncomplete);
    }
    function getCompletionItemDefaults(list, allCommitCharacters) {
        const rangeDefaults = list.itemDefaults?.editRange;
        const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return ls.Range.is(rangeDefaults)
            ? { defaultRange: asRange(rangeDefaults), commitCharacters }
            : rangeDefaults !== undefined
                ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters }
                : { defaultRange: undefined, commitCharacters };
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== undefined
            ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : undefined
            : defaultCommitCharacters;
        if (commitCharacters) {
            result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const data = item.data ?? defaultData;
        if (data !== undefined) {
            result.data = data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== undefined) {
            result.insertTextMode = insertTextMode;
            if (insertTextMode === ls.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionItemLabel(item) {
        if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
            return {
                label: item.label,
                detail: item.labelDetails.detail,
                description: item.labelDetails.description
            };
        }
        else {
            return item.label;
        }
    }
    function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit !== undefined || defaultRange !== undefined) {
            const [range, newText] = item.textEdit !== undefined
                ? getCompletionRangeAndText(item.textEdit)
                : [defaultRange, item.textEditText ?? item.label];
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(newText), range: range, fromEdit: true };
            }
            else {
                return { text: newText, range: range, fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function getCompletionRangeAndText(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
        }
        else {
            return [asRange(value.range), value.newText];
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    async function asTextEdits(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asTextEdit, token);
    }
    function asTextEditsSync(items) {
        if (!items) {
            return undefined;
        }
        const result = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            result[i] = asTextEdit(items[i]);
        }
        return result;
    }
    async function asSignatureHelp(item, token) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = await asSignatureInformations(item.signatures, token);
        }
        return result;
    }
    async function asSignatureInformations(items, token) {
        return async.mapAsync(items, asSignatureInformation, token);
    }
    async function asSignatureInformation(item, token) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = await asParameterInformations(item.parameters, token);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(items, token) {
        return async.map(items, asParameterInformation, token);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : undefined;
    }
    async function asDeclarationResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    async function asDefinitionResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    async function asLocationResult(item, token) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                const links = item;
                return async.map(links, asLocationLink, token);
            }
            else {
                const locations = item;
                return async.map(locations, asLocation, token);
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    async function asReferences(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asLocation, token);
    }
    async function asDocumentHighlights(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asDocumentHighlight, token);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    async function asSymbolInformations(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asSymbolInformation, token);
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item) {
        const data = item.data;
        const location = item.location;
        const result = location.range === undefined || data !== undefined
            ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? '', location.range === undefined ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data)
            : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? '', new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
        fillTags(result, item);
        return result;
    }
    async function asDocumentSymbols(values, token) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return async.map(values, asDocumentSymbol, token);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    async function asCommands(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCommand, token);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    async function asCodeAction(item, token) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = await asWorkspaceEdit(item.edit, token);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionResult(items, token) {
        return async.mapAsync(items, async (item) => {
            if (ls.Command.is(item)) {
                return asCommand(item);
            }
            else {
                return asCodeAction(item, token);
            }
        }, token);
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    async function asCodeLenses(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCodeLens, token);
    }
    async function asWorkspaceEdit(item, token) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            const changeAnnotations = item.changeAnnotations;
            await async.forEach(Object.keys(changeAnnotations), (key) => {
                const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }, token);
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            const documentChanges = item.documentChanges;
            await async.forEach(documentChanges, (change) => {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (ls.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }, token);
        }
        else if (item.changes) {
            const changes = item.changes;
            await async.forEach(Object.keys(changes), (key) => {
                result.set(_uriConverter(key), asTextEditsSync(changes[key]));
            }, token);
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    async function asDocumentLinks(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asDocumentLink, token);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    async function asColorInformations(colorInformation, token) {
        if (!colorInformation) {
            return undefined;
        }
        return async.map(colorInformation, asColorInformation, token);
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    async function asColorPresentations(colorPresentations, token) {
        if (!colorPresentations) {
            return undefined;
        }
        return async.map(colorPresentations, asColorPresentation, token);
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    async function asFoldingRanges(foldingRanges, token) {
        if (!foldingRanges) {
            return undefined;
        }
        return async.map(foldingRanges, asFoldingRange, token);
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    async function asSelectionRanges(selectionRanges, token) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        return async.map(selectionRanges, asSelectionRange, token);
    }
    function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
            return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
        }
        else if (ls.InlineValueVariableLookup.is(inlineValue)) {
            return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        }
        else {
            return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
        }
    }
    async function asInlineValues(inlineValues, token) {
        if (!Array.isArray(inlineValues)) {
            return [];
        }
        return async.map(inlineValues, asInlineValue, token);
    }
    async function asInlayHint(value, token) {
        const label = typeof value.label === 'string'
            ? value.label
            : await async.map(value.label, asInlayHintLabelPart, token);
        const result = new protocolInlayHint_1.default(asPosition(value.position), label);
        if (value.kind !== undefined) {
            result.kind = value.kind;
        }
        if (value.textEdits !== undefined) {
            result.textEdits = await asTextEdits(value.textEdits, token);
        }
        if (value.tooltip !== undefined) {
            result.tooltip = asTooltip(value.tooltip);
        }
        if (value.paddingLeft !== undefined) {
            result.paddingLeft = value.paddingLeft;
        }
        if (value.paddingRight !== undefined) {
            result.paddingRight = value.paddingRight;
        }
        if (value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asInlayHintLabelPart(part) {
        const result = new code.InlayHintLabelPart(part.value);
        if (part.location !== undefined) {
            result.location = asLocation(part.location);
        }
        if (part.tooltip !== undefined) {
            result.tooltip = asTooltip(part.tooltip);
        }
        if (part.command !== undefined) {
            result.command = asCommand(part.command);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        return asMarkdownString(value);
    }
    async function asInlayHints(values, token) {
        if (!Array.isArray(values)) {
            return undefined;
        }
        return async.mapAsync(values, asInlayHint, token);
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asCallHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asCallHierarchyItem, token);
    }
    async function asCallHierarchyIncomingCall(item, token) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyIncomingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyIncomingCall, token);
    }
    async function asCallHierarchyOutgoingCall(item, token) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyOutgoingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
    }
    async function asSemanticTokens(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    async function asSemanticTokensEdits(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    async function asLinkedEditingRanges(value, token) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    function asTypeHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asTypeHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asTypeHierarchyItem, token);
    }
    function asGlobPattern(pattern) {
        if (Is.string(pattern)) {
            return pattern;
        }
        if (ls.RelativePattern.is(pattern)) {
            if (ls.URI.is(pattern.baseUri)) {
                return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
            }
            else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
                const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
                return workspaceFolder !== undefined ? new code.RelativePattern(workspaceFolder, pattern.pattern) : undefined;
            }
        }
        return undefined;
    }
    return {
        asUri,
        asDocumentSelector,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeActionResult,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asInlayHint,
        asInlayHints,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems,
        asGlobPattern
    };
}
exports.createConverter = createConverter;


/***/ }),

/***/ 7894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(1398);
const Is = __webpack_require__(8319);
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;


/***/ }),

/***/ 7424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;


/***/ }),

/***/ 7511:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolInlayHint extends code.InlayHint {
    constructor(position, label, kind) {
        super(position, label, kind);
    }
}
exports["default"] = ProtocolInlayHint;


/***/ }),

/***/ 7321:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class ProtocolTypeHierarchyItem extends code.TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolTypeHierarchyItem;


/***/ }),

/***/ 6144:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(1398);
class WorkspaceSymbol extends code.SymbolInformation {
    constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = WorkspaceSymbol;


/***/ }),

/***/ 420:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferencesFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class ReferencesFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asReferences(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ReferencesFeature = ReferencesFeature;


/***/ }),

/***/ 875:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const UUID = __webpack_require__(9032);
const Is = __webpack_require__(8319);
const features_1 = __webpack_require__(4294);
class RenameFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asWorkspaceEdit(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token, error, null, false);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (this.isDefaultBehavior(result)) {
                                return result.defaultBehavior === true
                                    ? null
                                    : Promise.reject(new Error(`The element can't be renamed.`));
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            if (typeof error.message === 'string') {
                                throw new Error(error.message);
                            }
                            else {
                                throw new Error(`The element can't be renamed.`);
                            }
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
    isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
    }
}
exports.RenameFeature = RenameFeature;


/***/ }),

/***/ 6258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class SelectionRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = async (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: await client.code2ProtocolConverter.asPositions(positions, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSelectionRanges(ranges, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;


/***/ }),

/***/ 7691:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensFeature = void 0;
const vscode = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const Is = __webpack_require__(8319);
class SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then(async (result) => {
                                if (token.isCancellationRequested) {
                                    return null;
                                }
                                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                                    return await client.protocol2CodeConverter.asSemanticTokens(result, token);
                                }
                                else {
                                    return await client.protocol2CodeConverter.asSemanticTokensEdits(result, token);
                                }
                            }, (error) => {
                                return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token, error, null);
                            });
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
        if (documentProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;


/***/ }),

/***/ 1400:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureHelpFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class SignatureHelpFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSignatureHelp(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        return [this.registerProvider(options, provider), provider];
    }
    registerProvider(options, provider) {
        const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
        }
    }
}
exports.SignatureHelpFeature = SignatureHelpFeature;


/***/ }),

/***/ 1596:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const UUID = __webpack_require__(9032);
class DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
    }
    get openDocuments() {
        return this._syncedDocuments.values();
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            const uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                const middleware = this._client.middleware;
                const didOpen = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    getTextDocument(data) {
        return data;
    }
    notificationSent(textDocument, type, params) {
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        super.notificationSent(textDocument, type, params);
    }
}
exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
class DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments, pendingTextDocumentChanges) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    async callback(data) {
        await super.callback(data);
        this._pendingTextDocumentChanges.delete(data.uri.toString());
    }
    getTextDocument(data) {
        return data;
    }
    notificationSent(textDocument, type, params) {
        this._syncedDocuments.delete(textDocument.uri.toString());
        super.notificationSent(textDocument, type, params);
    }
    unregister(id) {
        const selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        const selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                let middleware = this._client.middleware;
                let didClose = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
            }
        });
    }
}
exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
class DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client, pendingTextDocumentChanges) {
        super(client);
        this._changeData = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
        this._onPendingChangeAdded = new vscode_1.EventEmitter();
        this._pendingTextDocumentChanges = pendingTextDocumentChanges;
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    get onPendingChangeAdded() {
        return this._onPendingChangeAdded.event;
    }
    get syncKind() {
        return this._syncKind;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== undefined && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            syncKind: data.registerOptions.syncKind,
            documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector),
        });
        this.updateSyncKind(data.registerOptions.syncKind);
    }
    *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
            yield data.documentSelector;
        }
    }
    async callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / un-dirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        // We need to capture the URI and version here since they might change on the text document
        // until we reach did `didChange` call since the middleware support async execution.
        const uri = event.document.uri;
        const version = event.document.version;
        const promises = [];
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
                const middleware = this._client.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    const didChange = async (event) => {
                        const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event, uri, version);
                        await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event.document, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    const didChange = async (event) => {
                        const eventUri = event.document.uri.toString();
                        this._pendingTextDocumentChanges.set(eventUri, event.document);
                        this._onPendingChangeAdded.fire();
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
            }
        }
        return Promise.all(promises).then(undefined, (error) => {
            this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
        });
    }
    notificationSent(textDocument, type, params) {
        this._onNotificationSent.fire({ textDocument, type, params });
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0) {
            if (this._listener) {
                this._listener.dispose();
                this._listener = undefined;
            }
            this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        }
        else {
            this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            for (const changeData of this._changeData.values()) {
                this.updateSyncKind(changeData.syncKind);
                if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    break;
                }
            }
        }
    }
    dispose() {
        this._pendingTextDocumentChanges.clear();
        this._changeData.clear();
        this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getPendingDocumentChanges(excludes) {
        if (this._pendingTextDocumentChanges.size === 0) {
            return [];
        }
        let result;
        if (excludes.size === 0) {
            result = Array.from(this._pendingTextDocumentChanges.values());
            this._pendingTextDocumentChanges.clear();
        }
        else {
            result = [];
            for (const entry of this._pendingTextDocumentChanges) {
                if (!excludes.has(entry[0])) {
                    result.push(entry[1]);
                    this._pendingTextDocumentChanges.delete(entry[0]);
                }
            }
        }
        return result;
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document) > 0) {
                return {
                    send: (event) => {
                        return this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
    updateSyncKind(syncKind) {
        if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
            return;
        }
        switch (syncKind) {
            case vscode_languageserver_protocol_1.TextDocumentSyncKind.Full:
                this._syncKind = syncKind;
                break;
            case vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental:
                if (this._syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    this._syncKind = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
                }
                break;
        }
    }
}
exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
class WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    getTextDocument(data) {
        return data.document;
    }
}
exports.WillSaveFeature = WillSaveFeature;
class WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._selectors = new Map();
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(async (edits) => {
                    let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === undefined ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
class DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
    getTextDocument(data) {
        return data;
    }
}
exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;


/***/ }),

/***/ 5432:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class TypeDefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;


/***/ }),

/***/ 4622:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
class TypeHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareTypeHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareTypeHierarchy
            ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy)
            : prepareTypeHierarchy(document, position, token);
    }
    provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySupertypes
            ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes)
            : provideTypeHierarchySupertypes(item, token);
    }
    provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySubtypes
            ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes)
            : provideTypeHierarchySubtypes(item, token);
    }
}
class TypeHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new TypeHierarchyProvider(client);
        return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.TypeHierarchyFeature = TypeHierarchyFeature;


/***/ }),

/***/ 5721:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== undefined;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== undefined) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
let $test = false;
function setTestMode() {
    $test = true;
}
exports.setTestMode = setTestMode;
function clearTestMode() {
    $test = false;
}
exports.clearTestMode = clearTestMode;
const defaultYieldTimeout = 15 /*ms*/;
class Timer {
    constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        // start with a counter interval of 1.
        this.counterInterval = 1;
    }
    start() {
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
        this.startTime = Date.now();
    }
    shouldYield() {
        if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
                // Yield also if time left <= 1 since we compute the counter
                // for max < 2 ms.
                // Start with interval 1 again. We could do some calculation
                // with using 80% of the last counter however other things (GC)
                // affect the timing heavily since we have small timings (1 - 15ms).
                this.counterInterval = 1;
                this.total = 0;
                return true;
            }
            else {
                // Only increase the counter until we have spent <= 2 ms. Increasing
                // the counter further is very fragile since timing is influenced
                // by other things and can increase the counter too much. This will result
                // that we yield in average after [14 - 16]ms.
                switch (timeTaken) {
                    case 0:
                    case 1:
                        this.counterInterval = this.total * 2;
                        break;
                }
            }
        }
        return false;
    }
}
async function map(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.map = map;
async function mapAsync(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    async function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = await func(items[i], token);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    let index = await convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.mapAsync = mapAsync;
async function forEach(items, func, token, options) {
    if (items.length === 0) {
        return;
    }
    const timer = new Timer(options?.yieldAfter);
    function runBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = runBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(runBatch(index));
            });
        });
    }
}
exports.forEach = forEach;


/***/ }),

/***/ 8319:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;


/***/ }),

/***/ 9032:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;


/***/ }),

/***/ 6804:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
const UUID = __webpack_require__(9032);
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
function access(target, key) {
    if (target === undefined || target === null) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(client) {
        this._client = client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
                const folders = vscode_1.workspace.workspaceFolders;
                if (folders === undefined) {
                    return null;
                }
                const result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            const middleware = client.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({ id: id, registerOptions: undefined });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                promise = this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== undefined) {
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                return this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;


/***/ }),

/***/ 8312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolFeature = void 0;
const vscode_1 = __webpack_require__(1398);
const vscode_languageserver_protocol_1 = __webpack_require__(7354);
const features_1 = __webpack_require__(4294);
const documentSymbol_1 = __webpack_require__(9228);
const UUID = __webpack_require__(9032);
class WorkspaceSymbolFeature extends features_1.WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: documentSymbol_1.SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: documentSymbol_1.SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ['location.range'] };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSymbolInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            },
            resolveWorkspaceSymbol: options.resolveProvider === true
                ? (item, token) => {
                    const client = this._client;
                    const resolveWorkspaceSymbol = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSymbolInformation(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token, error, null);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveWorkspaceSymbol
                        ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol)
                        : resolveWorkspaceSymbol(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
exports.WorkspaceSymbolFeature = WorkspaceSymbolFeature;


/***/ }),

/***/ 99:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const cp = __webpack_require__(5317);
const fs = __webpack_require__(9896);
const path = __webpack_require__(6928);
const vscode_1 = __webpack_require__(1398);
const Is = __webpack_require__(8319);
const client_1 = __webpack_require__(9538);
const processes_1 = __webpack_require__(6745);
const node_1 = __webpack_require__(948);
// Import SemVer functions individually to avoid circular dependencies in SemVer
const semverParse = __webpack_require__(144);
const semverSatisfies = __webpack_require__(7638);
__exportStar(__webpack_require__(948), exports);
__exportStar(__webpack_require__(6353), exports);
const REQUIRED_VSCODE_VERSION = '^1.67.0'; // do not change format, updated by `updateVSCode` script
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== undefined && candidate.reader !== undefined;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== undefined && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === undefined) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        const codeVersion = semverParse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    get isInDebugMode() {
        return this._isInDebugMode;
    }
    async restart() {
        await this.stop();
        // We are in debug mode. Wait a little before we restart
        // so that the debug port can be freed. We can safely ignore
        // the disposable returned from start since it will call
        // stop on the same client instance.
        if (this.isInDebugMode) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await this.start();
        }
        else {
            await this.start();
        }
    }
    stop(timeout = 2000) {
        return super.stop(timeout).finally(() => {
            if (this._serverProcess) {
                const toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === undefined || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === undefined) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                if (childProcess.pid !== undefined) {
                    process.kill(childProcess.pid, 0);
                    (0, processes_1.terminate)(childProcess);
                }
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        return super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
            params.processId = process.pid;
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            const result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        const server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new node_1.StreamMessageReader(cp.stdout), writer: new node_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
                this._isInDebugMode = true;
            }
            else {
                json = runDebug.run;
                this._isInDebugMode = false;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    const args = [];
                    const options = node.options ?? Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    const execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = (0, node_1.generateRandomPipeName)();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        const serverProcess = cp.spawn(runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, reject) => {
                        const args = (node.args && node.args.slice()) ?? [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = (0, node_1.generateRandomPipeName)();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        const options = node.options ?? Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            const sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                        else if (Transport.isSocket(transport)) {
                            (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                const command = json;
                const args = json.args !== undefined ? json.args.slice(0) : [];
                let pipeName = undefined;
                const transport = json.transport;
                if (transport === TransportKind.stdio) {
                    args.push('--stdio');
                }
                else if (transport === TransportKind.pipe) {
                    pipeName = (0, node_1.generateRandomPipeName)();
                    args.push(`--pipe=${pipeName}`);
                }
                else if (Transport.isSocket(transport)) {
                    args.push(`--socket=${transport.port}`);
                }
                else if (transport === TransportKind.ipc) {
                    throw new Error(`Transport kind ipc is not support for command executable`);
                }
                const options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                if (transport === undefined || transport === TransportKind.stdio) {
                    const serverProcess = cp.spawn(command.command, args, options);
                    if (!serverProcess || !serverProcess.pid) {
                        return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                    }
                    serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    this._serverProcess = serverProcess;
                    this._isDetached = !!options.detached;
                    return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
                else if (transport === TransportKind.pipe) {
                    return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
                else if (Transport.isSocket(transport)) {
                    return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
            return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== undefined) {
            const result = path.join(mainRootPath, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        if (serverWorkingDirectory !== undefined) {
            const result = path.join(serverWorkingDirectory, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        return runtime;
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                void this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start().catch((error) => this._client.error('Start failed after configuration change', error, 'force'));
        }
        else if (!enabled && this._client.needsStop()) {
            void this._client.stop().catch((error) => this._client.error('Stop failed after configuration change', error, 'force'));
        }
    }
}
exports.SettingMonitor = SettingMonitor;
function handleChildProcessStartError(process, message) {
    if (process === null) {
        return Promise.reject(message);
    }
    return new Promise((_, reject) => {
        process.on('error', (err) => {
            reject(`${message} ${err}`);
        });
        // the error event should always be run immediately,
        // but race on it just in case
        setImmediate(() => reject(message));
    });
}


/***/ }),

/***/ 6745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminate = void 0;
const cp = __webpack_require__(5317);
const path_1 = __webpack_require__(6928);
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = (0, path_1.join)(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;


/***/ }),

/***/ 2339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(99);

/***/ }),

/***/ 6998:
/***/ ((module) => {

const isWindows = typeof process === 'object' &&
  process &&
  process.platform === 'win32'
module.exports = isWindows ? { sep: '\\' } : { sep: '/' }


/***/ }),

/***/ 6045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const minimatch = module.exports = (p, pattern, options = {}) => {
  assertValidPattern(pattern)

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

module.exports = minimatch

const path = __webpack_require__(6998)
minimatch.sep = path.sep

const GLOBSTAR = Symbol('globstar **')
minimatch.GLOBSTAR = GLOBSTAR
const expand = __webpack_require__(8928)

const plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]'

// * => any number of characters
const star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// "abc" -> { a:true, b:true, c:true }
const charSet = s => s.split('').reduce((set, c) => {
  set[c] = true
  return set
}, {})

// characters that need to be escaped in RegExp.
const reSpecials = charSet('().*{}+?[]^$\\!')

// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet('[.(')

// normalizes slashes.
const slashSplit = /\/+/

minimatch.filter = (pattern, options = {}) =>
  (p, i, list) => minimatch(p, pattern, options)

const ext = (a, b = {}) => {
  const t = {}
  Object.keys(a).forEach(k => t[k] = a[k])
  Object.keys(b).forEach(k => t[k] = b[k])
  return t
}

minimatch.defaults = def => {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  const orig = minimatch

  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor (pattern, options) {
      super(pattern, ext(def, options))
    }
  }
  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch
  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))
  m.defaults = options => orig.defaults(ext(def, options))
  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))
  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))
  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))

  return m
}





// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)

const braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

const MAX_PATTERN_LENGTH = 1024 * 64
const assertValidPattern = pattern => {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol('subparse')

minimatch.makeRe = (pattern, options) =>
  new Minimatch(pattern, options || {}).makeRe()

minimatch.match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options)
  list = list.filter(f => mm.match(f))
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

// replace stuff like \* with *
const globUnescape = s => s.replace(/\\(.)/g, '$1')
const charUnescape = s => s.replace(/\\([^-\]])/g, '$1')
const regExpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
const braExpEscape = s => s.replace(/[[\]\\]/g, '\\$&')

class Minimatch {
  constructor (pattern, options) {
    assertValidPattern(pattern)

    if (!options) options = {}

    this.options = options
    this.set = []
    this.pattern = pattern
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||
      options.allowWindowsEscape === false
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, '/')
    }
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false
    this.partial = !!options.partial

    // make the set of regexps etc.
    this.make()
  }

  debug () {}

  make () {
    const pattern = this.pattern
    const options = this.options

    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

    // step 2: expand braces
    let set = this.globSet = this.braceExpand()

    if (options.debug) this.debug = (...args) => console.error(...args)

    this.debug(this.pattern, set)

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(s => s.split(slashSplit))

    this.debug(this.pattern, set)

    // glob --> regexps
    set = set.map((s, si, set) => s.map(this.parse, this))

    this.debug(this.pattern, set)

    // filter out everything that didn't compile properly.
    set = set.filter(s => s.indexOf(false) === -1)

    this.debug(this.pattern, set)

    this.set = set
  }

  parseNegate () {
    if (this.options.nonegate) return

    const pattern = this.pattern
    let negate = false
    let negateOffset = 0

    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
      negate = !negate
      negateOffset++
    }

    if (negateOffset) this.pattern = pattern.slice(negateOffset)
    this.negate = negate
  }

  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne (file, pattern, partial) {
    var options = this.options

    this.debug('matchOne',
      { 'this': this, file: file, pattern: pattern })

    this.debug('matchOne', file.length, pattern.length)

    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi < fl) && (pi < pl)
        ; fi++, pi++) {
      this.debug('matchOne loop')
      var p = pattern[pi]
      var f = file[fi]

      this.debug(pattern, p, f)

      // should be impossible.
      // some invalid regexp stuff in the set.
      /* istanbul ignore if */
      if (p === false) return false

      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f])

        // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit
        var fr = fi
        var pr = pi + 1
        if (pr === pl) {
          this.debug('** at the end')
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' ||
              (!options.dot && file[fi].charAt(0) === '.')) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        while (fr < fl) {
          var swallowee = file[fr]

          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee)
            // found a match.
            return true
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' ||
              (!options.dot && swallowee.charAt(0) === '.')) {
              this.debug('dot detected!', file, fr, pattern, pr)
              break
            }

            // ** swallows a segment, and continue.
            this.debug('globstar swallow a segment, and continue')
            fr++
          }
        }

        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        /* istanbul ignore if */
        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === 'string') {
        hit = f === p
        this.debug('string match', p, f, hit)
      } else {
        hit = f.match(p)
        this.debug('pattern match', p, f, hit)
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else /* istanbul ignore else */ if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return (fi === fl - 1) && (file[fi] === '')
    }

    // should be unreachable.
    /* istanbul ignore next */
    throw new Error('wtf?')
  }

  braceExpand () {
    return braceExpand(this.pattern, this.options)
  }

  parse (pattern, isSub) {
    assertValidPattern(pattern)

    const options = this.options

    // shortcuts
    if (pattern === '**') {
      if (!options.noglobstar)
        return GLOBSTAR
      else
        pattern = '*'
    }
    if (pattern === '') return ''

    let re = ''
    let hasMagic = false
    let escaping = false
    // ? => one single character
    const patternListStack = []
    const negativeLists = []
    let stateChar
    let inClass = false
    let reClassStart = -1
    let classStart = -1
    let cs
    let pl
    let sp
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.  However, if the pattern
    // starts with ., then traversal patterns can match.
    let dotTravAllowed = pattern.charAt(0) === '.'
    let dotFileAllowed = options.dot || dotTravAllowed
    const patternStart = () =>
      dotTravAllowed
        ? ''
        : dotFileAllowed
        ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
        : '(?!\\.)'
    const subPatternStart = (p) =>
      p.charAt(0) === '.'
        ? ''
        : options.dot
        ? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
        : '(?!\\.)'


    const clearStateChar = () => {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star
            hasMagic = true
          break
          case '?':
            re += qmark
            hasMagic = true
          break
          default:
            re += '\\' + stateChar
          break
        }
        this.debug('clearStateChar %j %j', stateChar, re)
        stateChar = false
      }
    }

    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c)

      // skip over any that are escaped.
      if (escaping) {
        /* istanbul ignore next - completely not allowed, even escaped. */
        if (c === '/') {
          return false
        }

        if (reSpecials[c]) {
          re += '\\'
        }
        re += c
        escaping = false
        continue
      }

      switch (c) {
        /* istanbul ignore next */
        case '/': {
          // Should already be path-split by now.
          return false
        }

        case '\\':
          if (inClass && pattern.charAt(i + 1) === '-') {
            re += c
            continue
          }

          clearStateChar()
          escaping = true
        continue

        // the various stateChar values
        // for the "extglob" stuff.
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug('  in class')
            if (c === '!' && i === classStart + 1) c = '^'
            re += c
            continue
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          this.debug('call clearStateChar %j', stateChar)
          clearStateChar()
          stateChar = c
          // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar()
        continue

        case '(': {
          if (inClass) {
            re += '('
            continue
          }

          if (!stateChar) {
            re += '\\('
            continue
          }

          const plEntry = {
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close,
          }
          this.debug(this.pattern, '\t', plEntry)
          patternListStack.push(plEntry)
          // negation is (?:(?!(?:js)(?:<rest>))[^/]*)
          re += plEntry.open
          // next entry starts with a dot maybe?
          if (plEntry.start === 0 && plEntry.type !== '!') {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          this.debug('plType %j %j', stateChar, re)
          stateChar = false
          continue
        }

        case ')': {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += '\\)'
            continue
          }
          patternListStack.pop()

          // closing an extglob
          clearStateChar()
          hasMagic = true
          pl = plEntry
          // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>
          re += pl.close
          if (pl.type === '!') {
            negativeLists.push(Object.assign(pl, { reEnd: re.length }))
          }
          continue
        }

        case '|': {
          const plEntry = patternListStack[patternListStack.length - 1]
          if (inClass || !plEntry) {
            re += '\\|'
            continue
          }

          clearStateChar()
          re += '|'
          // next subpattern can start with a dot?
          if (plEntry.start === 0 && plEntry.type !== '!') {
            dotTravAllowed = true
            re += subPatternStart(pattern.slice(i + 1))
          }
          continue
        }

        // these are mostly the same in regexp and glob
        case '[':
          // swallow any state-tracking char before the [
          clearStateChar()

          if (inClass) {
            re += '\\' + c
            continue
          }

          inClass = true
          classStart = i
          reClassStart = re.length
          re += c
        continue

        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c
            continue
          }

          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + braExpEscape(charUnescape(cs)) + ']')
            // looks good, finish up the class.
            re += c
          } catch (er) {
            // out of order ranges in JS are errors, but in glob syntax,
            // they're just a range that matches nothing.
            re = re.substring(0, reClassStart) + '(?:$.)' // match nothing ever
          }
          hasMagic = true
          inClass = false
        continue

        default:
          // swallow any state char that wasn't consumed
          clearStateChar()

          if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\'
          }

          re += c
          break

      } // switch
    } // for

    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.slice(classStart + 1)
      sp = this.parse(cs, SUBPARSE)
      re = re.substring(0, reClassStart) + '\\[' + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail
      tail = re.slice(pl.reStart + pl.open.length)
      this.debug('setting tail', re, pl)
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        /* istanbul ignore else - should already be done */
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\'
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + '|'
      })

      this.debug('tail=%j\n   %s', tail, tail, pl, re)
      const t = pl.type === '*' ? star
        : pl.type === '?' ? qmark
        : '\\' + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart) + t + '\\(' + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += '\\\\'
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    const addPatternStart = addPatternStartSet[re.charAt(0)]

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n]

      const nlBefore = re.slice(0, nl.reStart)
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
      let nlAfter = re.slice(nl.reEnd)
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.
      const closeParensBefore = nlBefore.split(')').length
      const openParensBefore = nlBefore.split('(').length - closeParensBefore
      let cleanAfter = nlAfter
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
      }
      nlAfter = cleanAfter

      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\/)' : ''

      re = nlBefore + nlFirst + nlAfter + dollar + nlLast
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re
    }

    if (addPatternStart) {
      re = patternStart() + re
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic]
    }

    // if it's nocase, and the lcase/uppercase don't match, it's magic
    if (options.nocase && !hasMagic) {
      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    const flags = options.nocase ? 'i' : ''
    try {
      return Object.assign(new RegExp('^' + re + '$', flags), {
        _glob: pattern,
        _src: re,
      })
    } catch (er) /* istanbul ignore next - should be impossible */ {
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.')
    }
  }

  makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    const set = this.set

    if (!set.length) {
      this.regexp = false
      return this.regexp
    }
    const options = this.options

    const twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    const flags = options.nocase ? 'i' : ''

    // coalesce globstars and regexpify non-globstar patterns
    // if it's the only item, then we just do one twoStar
    // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
    // if it's the last, append (\/twoStar|) to previous
    // if it's in the middle, append (\/|\/twoStar\/) to previous
    // then filter out GLOBSTAR symbols
    let re = set.map(pattern => {
      pattern = pattern.map(p =>
        typeof p === 'string' ? regExpEscape(p)
        : p === GLOBSTAR ? GLOBSTAR
        : p._src
      ).reduce((set, p) => {
        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
          set.push(p)
        }
        return set
      }, [])
      pattern.forEach((p, i) => {
        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {
          return
        }
        if (i === 0) {
          if (pattern.length > 1) {
            pattern[i+1] = '(?:\\\/|' + twoStar + '\\\/)?' + pattern[i+1]
          } else {
            pattern[i] = twoStar
          }
        } else if (i === pattern.length - 1) {
          pattern[i-1] += '(?:\\\/|' + twoStar + ')?'
        } else {
          pattern[i-1] += '(?:\\\/|\\\/' + twoStar + '\\\/)' + pattern[i+1]
          pattern[i+1] = GLOBSTAR
        }
      })
      return pattern.filter(p => p !== GLOBSTAR).join('/')
    }).join('|')

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$'

    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$'

    try {
      this.regexp = new RegExp(re, flags)
    } catch (ex) /* istanbul ignore next - should be impossible */ {
      this.regexp = false
    }
    return this.regexp
  }

  match (f, partial = this.partial) {
    this.debug('match', f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ''

    if (f === '/' && partial) return true

    const options = this.options

    // windows: need to use /, not \
    if (path.sep !== '/') {
      f = f.split(path.sep).join('/')
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    this.debug(this.pattern, 'split', f)

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    const set = this.set
    this.debug(this.pattern, 'set', set)

    // Find the basename of the path by looking for the last non-empty segment
    let filename
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i]
      if (filename) break
    }

    for (let i = 0; i < set.length; i++) {
      const pattern = set[i]
      let file = f
      if (options.matchBase && pattern.length === 1) {
        file = [filename]
      }
      const hit = this.matchOne(file, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

  static defaults (def) {
    return minimatch.defaults(def).Minimatch
  }
}

minimatch.Minimatch = Minimatch


/***/ }),

/***/ 8766:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(7123), exports);
__exportStar(__webpack_require__(7806), exports);
__exportStar(__webpack_require__(372), exports);
__exportStar(__webpack_require__(1560), exports);
var connection_1 = __webpack_require__(1580);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.RequestFailed = -32803;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));


/***/ }),

/***/ 1580:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7123);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ 372:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7123);
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;


/***/ }),

/***/ 8765:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));


/***/ }),

/***/ 7672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));


/***/ }),

/***/ 1660:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(372);
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));


/***/ }),

/***/ 6914:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(372);
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));


/***/ }),

/***/ 6011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7123);
const Is = __webpack_require__(8598);
const messages_1 = __webpack_require__(372);
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));


/***/ }),

/***/ 9840:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));


/***/ }),

/***/ 2874:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));


/***/ }),

/***/ 9574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(372);
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));


/***/ }),

/***/ 7752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));


/***/ }),

/***/ 3124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));


/***/ }),

/***/ 1560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
const messages_1 = __webpack_require__(372);
const vscode_languageserver_types_1 = __webpack_require__(7806);
const Is = __webpack_require__(8598);
const protocol_implementation_1 = __webpack_require__(9574);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(8461);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolder_1 = __webpack_require__(9935);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(1660);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(7672);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(2874);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(6914);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(3487);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(2687);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(8765);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(2478);
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(908);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(5316);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(9840);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(9047);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
const protocol_typeHierarchy_1 = __webpack_require__(645);
Object.defineProperty(exports, "TypeHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } }));
Object.defineProperty(exports, "TypeHierarchySubtypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } }));
Object.defineProperty(exports, "TypeHierarchySupertypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } }));
const protocol_inlineValue_1 = __webpack_require__(3124);
Object.defineProperty(exports, "InlineValueRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } }));
Object.defineProperty(exports, "InlineValueRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } }));
const protocol_inlayHint_1 = __webpack_require__(7752);
Object.defineProperty(exports, "InlayHintRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } }));
Object.defineProperty(exports, "InlayHintResolveRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } }));
Object.defineProperty(exports, "InlayHintRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } }));
const protocol_diagnostic_1 = __webpack_require__(6011);
Object.defineProperty(exports, "DiagnosticServerCancellationData", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } }));
Object.defineProperty(exports, "DocumentDiagnosticReportKind", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } }));
Object.defineProperty(exports, "DocumentDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } }));
Object.defineProperty(exports, "WorkspaceDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } }));
Object.defineProperty(exports, "DiagnosticRefreshRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } }));
const protocol_notebook_1 = __webpack_require__(3557);
Object.defineProperty(exports, "NotebookCellKind", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } }));
Object.defineProperty(exports, "ExecutionSummary", ({ enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } }));
Object.defineProperty(exports, "NotebookCell", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } }));
Object.defineProperty(exports, "NotebookDocument", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } }));
Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } }));
Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } }));
Object.defineProperty(exports, "NotebookCellArrayChange", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } }));
Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var TextDocumentFilter;
(function (TextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    TextDocumentFilter.is = is;
})(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookDocumentFilter;
(function (NotebookDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter.is = is;
})(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */
var NotebookCellTextDocumentFilter;
(function (NotebookCellTextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
            && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter.is = is;
})(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.method = 'client/registerCapability';
    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.method = 'client/unregisterCapability';
    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
var PositionEncodingKind;
(function (PositionEncodingKind) {
    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */
    PositionEncodingKind.UTF8 = 'utf-8';
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    PositionEncodingKind.UTF16 = 'utf-16';
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    PositionEncodingKind.UTF32 = 'utf-32';
})(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.method = 'initialize';
    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeErrorCodes`;
 */
var InitializeErrorCodes;
(function (InitializeErrorCodes) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeErrorCodes.unknownProtocolVersion = 1;
})(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.method = 'initialized';
    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.method = 'shutdown';
    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.method = 'exit';
    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.method = 'window/showMessage';
    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.method = 'window/showMessageRequest';
    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.method = 'window/logMessage';
    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.method = 'telemetry/event';
    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var RelativePattern;
(function (RelativePattern) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern.is = is;
})(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */
var WorkspaceSymbolResolveRequest;
(function (WorkspaceSymbolResolveRequest) {
    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
})(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.method = 'workspace/executeCommand';
    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));


/***/ }),

/***/ 5316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));


/***/ }),

/***/ 9047:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(372);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));


/***/ }),

/***/ 3557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = __webpack_require__(7806);
const Is = __webpack_require__(8598);
const messages_1 = __webpack_require__(372);
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));


/***/ }),

/***/ 2687:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7123);
const messages_1 = __webpack_require__(372);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));


/***/ }),

/***/ 3487:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));


/***/ }),

/***/ 2478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(372);
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));


/***/ }),

/***/ 908:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));


/***/ }),

/***/ 8461:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(372);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));


/***/ }),

/***/ 645:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));


/***/ }),

/***/ 9935:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(372);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));


/***/ }),

/***/ 8598:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;


/***/ }),

/***/ 7354:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(2067);
__exportStar(__webpack_require__(2067), exports);
__exportStar(__webpack_require__(8766), exports);
function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;


/***/ }),

/***/ 948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(7354);

/***/ }),

/***/ 7806:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotatedTextEdit: () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   ChangeAnnotation: () => (/* binding */ ChangeAnnotation),
/* harmony export */   ChangeAnnotationIdentifier: () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   CodeAction: () => (/* binding */ CodeAction),
/* harmony export */   CodeActionContext: () => (/* binding */ CodeActionContext),
/* harmony export */   CodeActionKind: () => (/* binding */ CodeActionKind),
/* harmony export */   CodeActionTriggerKind: () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   CodeDescription: () => (/* binding */ CodeDescription),
/* harmony export */   CodeLens: () => (/* binding */ CodeLens),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   ColorInformation: () => (/* binding */ ColorInformation),
/* harmony export */   ColorPresentation: () => (/* binding */ ColorPresentation),
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   CompletionItem: () => (/* binding */ CompletionItem),
/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),
/* harmony export */   CompletionItemLabelDetails: () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),
/* harmony export */   CompletionList: () => (/* binding */ CompletionList),
/* harmony export */   CreateFile: () => (/* binding */ CreateFile),
/* harmony export */   DeleteFile: () => (/* binding */ DeleteFile),
/* harmony export */   Diagnostic: () => (/* binding */ Diagnostic),
/* harmony export */   DiagnosticRelatedInformation: () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   DiagnosticSeverity: () => (/* binding */ DiagnosticSeverity),
/* harmony export */   DiagnosticTag: () => (/* binding */ DiagnosticTag),
/* harmony export */   DocumentHighlight: () => (/* binding */ DocumentHighlight),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   DocumentLink: () => (/* binding */ DocumentLink),
/* harmony export */   DocumentSymbol: () => (/* binding */ DocumentSymbol),
/* harmony export */   DocumentUri: () => (/* binding */ DocumentUri),
/* harmony export */   EOL: () => (/* binding */ EOL),
/* harmony export */   FoldingRange: () => (/* binding */ FoldingRange),
/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),
/* harmony export */   FormattingOptions: () => (/* binding */ FormattingOptions),
/* harmony export */   Hover: () => (/* binding */ Hover),
/* harmony export */   InlayHint: () => (/* binding */ InlayHint),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlayHintLabelPart: () => (/* binding */ InlayHintLabelPart),
/* harmony export */   InlineValueContext: () => (/* binding */ InlineValueContext),
/* harmony export */   InlineValueEvaluatableExpression: () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   InlineValueText: () => (/* binding */ InlineValueText),
/* harmony export */   InlineValueVariableLookup: () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   InsertReplaceEdit: () => (/* binding */ InsertReplaceEdit),
/* harmony export */   InsertTextFormat: () => (/* binding */ InsertTextFormat),
/* harmony export */   InsertTextMode: () => (/* binding */ InsertTextMode),
/* harmony export */   Location: () => (/* binding */ Location),
/* harmony export */   LocationLink: () => (/* binding */ LocationLink),
/* harmony export */   MarkedString: () => (/* binding */ MarkedString),
/* harmony export */   MarkupContent: () => (/* binding */ MarkupContent),
/* harmony export */   MarkupKind: () => (/* binding */ MarkupKind),
/* harmony export */   OptionalVersionedTextDocumentIdentifier: () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   ParameterInformation: () => (/* binding */ ParameterInformation),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   Range: () => (/* binding */ Range),
/* harmony export */   RenameFile: () => (/* binding */ RenameFile),
/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),
/* harmony export */   SemanticTokenModifiers: () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   SemanticTokenTypes: () => (/* binding */ SemanticTokenTypes),
/* harmony export */   SemanticTokens: () => (/* binding */ SemanticTokens),
/* harmony export */   SignatureInformation: () => (/* binding */ SignatureInformation),
/* harmony export */   SymbolInformation: () => (/* binding */ SymbolInformation),
/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),
/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),
/* harmony export */   TextDocument: () => (/* binding */ TextDocument),
/* harmony export */   TextDocumentEdit: () => (/* binding */ TextDocumentEdit),
/* harmony export */   TextDocumentIdentifier: () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   TextDocumentItem: () => (/* binding */ TextDocumentItem),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   VersionedTextDocumentIdentifier: () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   WorkspaceChange: () => (/* binding */ WorkspaceChange),
/* harmony export */   WorkspaceEdit: () => (/* binding */ WorkspaceEdit),
/* harmony export */   WorkspaceFolder: () => (/* binding */ WorkspaceFolder),
/* harmony export */   WorkspaceSymbol: () => (/* binding */ WorkspaceSymbol),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   uinteger: () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name: name, kind: kind, location: { uri: uri, range: range } }
            : { name: name, kind: kind, location: { uri: uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range: range, text: text };
    }
    InlineValueText.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range: range, expression: expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId: frameId, stoppedLocation: stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value: value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        var result = { position: position, label: label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ 8945:
/***/ (function(module) {

!function(t,e){if(true)module.exports=e();else { var n, r; }}(this,(()=>(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,a=0;a<=t.length;++a){if(a<t.length)r=t.charCodeAt(a);else{if(47===r)break;r=47}if(47===r){if(o===a-1||1===s);else if(o!==a-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var h=n.lastIndexOf("/");if(h!==n.length-1){-1===h?(n="",i=0):i=(n=n.slice(0,h)).length-1-n.lastIndexOf("/"),o=a,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=a,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2)}else n.length>0?n+="/"+t.slice(o+1,a):n=t.slice(o+1,a),i=a-o-1;o=a,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,a=1;a<r.length&&47===r.charCodeAt(a);++a);for(var h=r.length-a,c=s<h?s:h,f=-1,u=0;u<=c;++u){if(u===c){if(h>c){if(47===r.charCodeAt(a+u))return r.slice(a+u+1);if(0===u)return r.slice(a+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(a+u))break;47===l&&(f=u)}var d="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===d.length?d+="..":d+="/..");return d.length>0?d+r.slice(a+f):(a+=f,47===r.charCodeAt(a)&&++a,r.slice(a))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var a=r.length-1,h=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===h&&(s=!1,h=n+1),a>=0&&(c===r.charCodeAt(a)?-1==--a&&(o=n):(a=-1,o=h))}return i===o?o=h:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,a=t.length-1;a>=0;--a){var h=t.charCodeAt(a);if(47!==h)-1===i&&(o=!1,i=a+1),46===h?-1===r?r=a:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=a+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,a=0,h=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===h&&(c=!1,h=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){a=f+1;break}return-1===s||-1===h||0===u||1===u&&s===h-1&&s===a+1?-1!==h&&(r.base=r.name=0===a&&o?t.slice(1,h):t.slice(a,h)):(0===a&&o?(r.name=t.slice(1,s),r.base=t.slice(1,h)):(r.name=t.slice(a,s),r.base=t.slice(a,h)),r.ext=t.slice(s,h)),a>0?r.dir=t.slice(0,a-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},674:(t,e)=>{if(Object.defineProperty(e,"__esModule",{value:!0}),e.isWindows=void 0,"object"==typeof process)e.isWindows="win32"===process.platform;else if("object"==typeof navigator){let t=navigator.userAgent;e.isWindows=t.indexOf("Windows")>=0}},796:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.uriToFsPath=e.URI=void 0;const n=r(674),i=/^\w[\w\d+.-]*$/,o=/^\//,s=/^\/\//;function a(t,e){if(!t.scheme&&e)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!i.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!o.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(s.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const h="",c="/",f=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class u{static isUri(t){return t instanceof u||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==c&&(e=c+e):e=c}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,a(this,o))}get fsPath(){return v(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new d(e,r,n,i,o)}static parse(t,e=!1){const r=f.exec(t);return r?new d(r[2]||h,w(r[4]||h),w(r[5]||h),w(r[7]||h),w(r[9]||h),e):new d(h,h,h,h,h)}static file(t){let e=h;if(n.isWindows&&(t=t.replace(/\\/g,c)),t[0]===c&&t[1]===c){const r=t.indexOf(c,2);-1===r?(e=t.substring(2),t=c):(e=t.substring(2,r),t=t.substring(r)||c)}return new d("file",e,t,h,h)}static from(t){const e=new d(t.scheme,t.authority,t.path,t.query,t.fragment);return a(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof u)return t;{const e=new d(t);return e._formatted=t.external,e._fsPath=t._sep===l?t.fsPath:null,e}}return t}}e.URI=u;const l=n.isWindows?1:void 0;class d extends u{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=v(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=l),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const p={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function g(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=p[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function m(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=p[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function v(t,e){let r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?`//${t.authority}${t.path}`:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n.isWindows&&(r=r.replace(/\//g,"\\")),r}function y(t,e){const r=e?m:g;let n="",{scheme:i,authority:o,path:s,query:a,fragment:h}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=c,n+=c),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=":",n+=r(e.substr(t+1),!1,!0)),n+="@"}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return a&&(n+="?",n+=r(a,!1,!1)),h&&(n+="#",n+=e?h:g(h,!1,!1)),n}function b(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+b(t.substr(3)):t}}e.uriToFsPath=v;const C=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function w(t){return t.match(C)?t.replace(C,(t=>b(t))):t}},679:function(t,e,r){var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),o=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var r in t)"default"!==r&&Object.prototype.hasOwnProperty.call(t,r)&&n(e,t,r);return i(e,t),e};Object.defineProperty(e,"__esModule",{value:!0}),e.Utils=void 0;const s=o(r(470)),a=s.posix||s,h="/";var c;!function(t){t.joinPath=function(t,...e){return t.with({path:a.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==h&&(r=h+r,n=!0);let i=a.resolve(r,...e);return n&&i[0]===h&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===h)return t;let e=a.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return a.basename(t.path)},t.extname=function(t){return a.extname(t.path)}}(c||(e.Utils=c={}))}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n].call(o.exports,o,o.exports,r),o.exports}var n={};return(()=>{var t=n;Object.defineProperty(t,"__esModule",{value:!0}),t.Utils=t.URI=void 0;const e=r(796);Object.defineProperty(t,"URI",{enumerable:!0,get:function(){return e.URI}});const i=r(679);Object.defineProperty(t,"Utils",{enumerable:!0,get:function(){return i.Utils}})})(),n})()));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const WebSocket = __webpack_require__(1060);

WebSocket.createWebSocketStream = __webpack_require__(3719);
WebSocket.Server = __webpack_require__(1722);
WebSocket.Receiver = __webpack_require__(6286);
WebSocket.Sender = __webpack_require__(914);

WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;

module.exports = WebSocket;


/***/ }),

/***/ 3338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(2627);

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 2614:
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(2614);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ 5926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 4759:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 2971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(3106);

const bufferUtil = __webpack_require__(3338);
const Limiter = __webpack_require__(4759);
const { kStatusCode } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 6286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(2203);

const PerMessageDeflate = __webpack_require__(2971);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(2614);
const { concat, toArrayBuffer, unmask } = __webpack_require__(3338);
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(5880);

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ 914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(2203);
const { randomFillSync } = __webpack_require__(6982);

const PerMessageDeflate = __webpack_require__(2971);
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(2614);
const { isBlob, isValidStatusCode } = __webpack_require__(5880);
const { mask: applyMask, toBuffer } = __webpack_require__(3338);

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ 3719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Duplex } = __webpack_require__(2203);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 5880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(181);

const { hasBlob } = __webpack_require__(2614);

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 1722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const http = __webpack_require__(8611);
const { Duplex } = __webpack_require__(2203);
const { createHash } = __webpack_require__(6982);

const extension = __webpack_require__(5926);
const PerMessageDeflate = __webpack_require__(2971);
const subprotocol = __webpack_require__(8237);
const WebSocket = __webpack_require__(1060);
const { GUID, kWebSocket } = __webpack_require__(2614);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ 1060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const https = __webpack_require__(5692);
const http = __webpack_require__(8611);
const net = __webpack_require__(9278);
const tls = __webpack_require__(4756);
const { randomBytes, createHash } = __webpack_require__(6982);
const { Duplex, Readable } = __webpack_require__(2203);
const { URL } = __webpack_require__(7016);

const PerMessageDeflate = __webpack_require__(2971);
const Receiver = __webpack_require__(6286);
const Sender = __webpack_require__(914);
const { isBlob } = __webpack_require__(5880);

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(2614);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(597);
const { format, parse } = __webpack_require__(5926);
const { toBuffer } = __webpack_require__(3338);

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 1398:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 5317:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 4434:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 9896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 8611:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 9278:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 857:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 6928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4756:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7016:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 3106:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 9274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertValidPattern = void 0;
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};
exports.assertValidPattern = assertValidPattern;
//# sourceMappingURL=assert-valid-pattern.js.map

/***/ }),

/***/ 1674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// parse a single path portion
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AST = void 0;
const brace_expressions_js_1 = __webpack_require__(3843);
const unescape_js_1 = __webpack_require__(4116);
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                (0, unescape_js_1.unescape)(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
}
exports.AST = AST;
//# sourceMappingURL=ast.js.map

/***/ }),

/***/ 3843:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// translate the various posix character classes into unicode properties
// this works across all unicode locales
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseClass = void 0;
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};
exports.parseClass = parseClass;
//# sourceMappingURL=brace-expressions.js.map

/***/ }),

/***/ 2363:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escape = void 0;
/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};
exports.escape = escape;
//# sourceMappingURL=escape.js.map

/***/ }),

/***/ 8722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(__webpack_require__(8928));
const assert_valid_pattern_js_1 = __webpack_require__(9274);
const ast_js_1 = __webpack_require__(1674);
const escape_js_1 = __webpack_require__(2363);
const unescape_js_1 = __webpack_require__(4116);
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = __webpack_require__(1674);
Object.defineProperty(exports, "AST", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));
var escape_js_2 = __webpack_require__(2363);
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
var unescape_js_2 = __webpack_require__(4116);
Object.defineProperty(exports, "unescape", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = void 0;
/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};
exports.unescape = unescape;
//# sourceMappingURL=unescape.js.map

/***/ }),

/***/ 18:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);
var YAMLMap = __webpack_require__(1755);
var YAMLSeq = __webpack_require__(6010);
var resolveBlockMap = __webpack_require__(7434);
var resolveBlockSeq = __webpack_require__(483);
var resolveFlowCollection = __webpack_require__(2291);

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq') ||
        !expType) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt?.collection) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = identity.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),

/***/ 2206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Document = __webpack_require__(9046);
var composeNode = __webpack_require__(2782);
var resolveEnd = __webpack_require__(6845);
var resolveProps = __webpack_require__(1386);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),

/***/ 2782:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(1736);
var composeCollection = __webpack_require__(18);
var composeScalar = __webpack_require__(9094);
var resolveEnd = __webpack_require__(6845);
var utilEmptyScalarPosition = __webpack_require__(1040);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),

/***/ 9094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);
var resolveBlockScalar = __webpack_require__(4070);
var resolveFlowScalar = __webpack_require__(7571);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[identity.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[identity.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[identity.SCALAR];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),

/***/ 4927:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var directives = __webpack_require__(8673);
var Document = __webpack_require__(9046);
var errors = __webpack_require__(4355);
var identity = __webpack_require__(484);
var composeDoc = __webpack_require__(2206);
var resolveEnd = __webpack_require__(6845);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (identity.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),

/***/ 7434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Pair = __webpack_require__(7902);
var YAMLMap = __webpack_require__(1755);
var resolveProps = __webpack_require__(1386);
var utilContainsNewline = __webpack_require__(9378);
var utilFlowIndentCheck = __webpack_require__(8644);
var utilMapIncludes = __webpack_require__(8334);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),

/***/ 4070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);

function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = 'Block scalar values in collections must be indented';
                onError(offset, 'BAD_INDENT', message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),

/***/ 483:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(6010);
var resolveProps = __webpack_require__(1386);
var utilFlowIndentCheck = __webpack_require__(8644);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),

/***/ 6845:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),

/***/ 2291:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var YAMLMap = __webpack_require__(1755);
var YAMLSeq = __webpack_require__(6010);
var resolveEnd = __webpack_require__(6845);
var resolveProps = __webpack_require__(1386);
var utilContainsNewline = __webpack_require__(9378);
var utilMapIncludes = __webpack_require__(8334);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (identity.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),

/***/ 7571:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var resolveEnd = __webpack_require__(6845);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),

/***/ 1386:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
            }
            tab = null;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
                    token.source.includes('\t')) {
                    tab = token;
                }
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline =
                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    }
    if (tab &&
        ((atNewline && tab.indent <= parentIndent) ||
            next?.type === 'block-map' ||
            next?.type === 'block-seq'))
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),

/***/ 9378:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),

/***/ 1040:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),

/***/ 8644:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utilContainsNewline = __webpack_require__(9378);

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),

/***/ 8334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (identity.isScalar(a) &&
                identity.isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),

/***/ 9046:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(1736);
var Collection = __webpack_require__(1614);
var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var toJS = __webpack_require__(3732);
var Schema = __webpack_require__(625);
var stringifyDocument = __webpack_require__(1768);
var anchors = __webpack_require__(6261);
var applyReviver = __webpack_require__(6906);
var createNode = __webpack_require__(5219);
var directives = __webpack_require__(8673);

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return identity.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && identity.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return identity.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (identity.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),

/***/ 6261:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var visit = __webpack_require__(9125);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),

/***/ 6906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),

/***/ 5219:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(1736);
var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
        value = value.contents;
    if (identity.isNode(value))
        return value;
    if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[identity.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[identity.SEQ]
                    : schema[identity.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),

/***/ 8673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var visit = __webpack_require__(9125);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (identity.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),

/***/ 4355:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),

/***/ 1198:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(4927);
var Document = __webpack_require__(9046);
var Schema = __webpack_require__(625);
var errors = __webpack_require__(4355);
var Alias = __webpack_require__(1736);
var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var Scalar = __webpack_require__(9714);
var YAMLMap = __webpack_require__(1755);
var YAMLSeq = __webpack_require__(6010);
var cst = __webpack_require__(9112);
var lexer = __webpack_require__(5752);
var lineCounter = __webpack_require__(2864);
var parser = __webpack_require__(6247);
var publicApi = __webpack_require__(1332);
var visit = __webpack_require__(9125);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = identity.isAlias;
exports.isCollection = identity.isCollection;
exports.isDocument = identity.isDocument;
exports.isMap = identity.isMap;
exports.isNode = identity.isNode;
exports.isPair = identity.isPair;
exports.isScalar = identity.isScalar;
exports.isSeq = identity.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),

/***/ 7444:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),

/***/ 1736:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(6261);
var visit = __webpack_require__(9125);
var identity = __webpack_require__(484);
var Node = __webpack_require__(8898);
var toJS = __webpack_require__(3732);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),

/***/ 1614:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(5219);
var identity = __webpack_require__(484);
var Node = __webpack_require__(8898);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!identity.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    identity.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),

/***/ 8898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var applyReviver = __webpack_require__(6906);
var identity = __webpack_require__(484);
var toJS = __webpack_require__(3732);

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

exports.NodeBase = NodeBase;


/***/ }),

/***/ 7902:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(5219);
var stringifyPair = __webpack_require__(8017);
var addPairToJSMap = __webpack_require__(5139);
var identity = __webpack_require__(484);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
            key = key.clone(schema);
        if (identity.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),

/***/ 9714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Node = __webpack_require__(8898);
var toJS = __webpack_require__(3732);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(identity.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),

/***/ 1755:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(81);
var addPairToJSMap = __webpack_require__(5139);
var Collection = __webpack_require__(1614);
var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var Scalar = __webpack_require__(9714);

function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (identity.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (identity.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!identity.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),

/***/ 6010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(5219);
var stringifyCollection = __webpack_require__(81);
var Collection = __webpack_require__(1614);
var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);
var toJS = __webpack_require__(3732);

class YAMLSeq extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),

/***/ 5139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(7444);
var stringify = __webpack_require__(3793);
var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);
var toJS = __webpack_require__(3732);

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = identity.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (identity.isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (identity.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),

/***/ 484:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),

/***/ 3732:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),

/***/ 5141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var resolveBlockScalar = __webpack_require__(4070);
var resolveFlowScalar = __webpack_require__(7571);
var errors = __webpack_require__(4355);
var stringifyString = __webpack_require__(7180);

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),

/***/ 7808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),

/***/ 5970:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),

/***/ 9112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cstScalar = __webpack_require__(5141);
var cstStringify = __webpack_require__(7808);
var cstVisit = __webpack_require__(5970);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),

/***/ 5752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(9112);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
                    cs = line.indexOf('#', cs + 1);
                }
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),

/***/ 2864:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),

/***/ 6247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(9112);
var lexer = __webpack_require__(5752);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atMapIndent && bv.type !== 'block-seq') {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, explicitKey: true }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),

/***/ 1332:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(4927);
var Document = __webpack_require__(9046);
var errors = __webpack_require__(4355);
var log = __webpack_require__(7444);
var lineCounter = __webpack_require__(2864);
var parser = __webpack_require__(6247);

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),

/***/ 625:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var map = __webpack_require__(3334);
var seq = __webpack_require__(1919);
var string = __webpack_require__(8531);
var tags = __webpack_require__(975);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),

/***/ 3334:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var YAMLMap = __webpack_require__(1755);

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!identity.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
};

exports.map = map;


/***/ }),

/***/ 6055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),

/***/ 1919:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var YAMLSeq = __webpack_require__(6010);

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!identity.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
};

exports.seq = seq;


/***/ }),

/***/ 8531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyString = __webpack_require__(7180);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),

/***/ 5132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),

/***/ 988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var stringifyNumber = __webpack_require__(3144);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 2891:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(3144);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 8523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(3334);
var _null = __webpack_require__(6055);
var seq = __webpack_require__(1919);
var string = __webpack_require__(8531);
var bool = __webpack_require__(5132);
var float = __webpack_require__(988);
var int = __webpack_require__(2891);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),

/***/ 4988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var map = __webpack_require__(3334);
var seq = __webpack_require__(1919);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),

/***/ 975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(3334);
var _null = __webpack_require__(6055);
var seq = __webpack_require__(1919);
var string = __webpack_require__(8531);
var bool = __webpack_require__(5132);
var float = __webpack_require__(988);
var int = __webpack_require__(2891);
var schema = __webpack_require__(8523);
var schema$1 = __webpack_require__(4988);
var binary = __webpack_require__(8080);
var omap = __webpack_require__(692);
var pairs = __webpack_require__(8416);
var schema$2 = __webpack_require__(5822);
var set = __webpack_require__(2557);
var timestamp = __webpack_require__(5437);

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),

/***/ 8080:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var stringifyString = __webpack_require__(7180);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),

/***/ 7969:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),

/***/ 7191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var stringifyNumber = __webpack_require__(3144);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 6936:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(3144);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var toJS = __webpack_require__(3732);
var YAMLMap = __webpack_require__(1755);
var YAMLSeq = __webpack_require__(6010);
var pairs = __webpack_require__(8416);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (identity.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (identity.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),

/***/ 8416:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var Scalar = __webpack_require__(9714);
var YAMLSeq = __webpack_require__(6010);

function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (identity.isPair(item))
                continue;
            else if (identity.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),

/***/ 5822:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(3334);
var _null = __webpack_require__(6055);
var seq = __webpack_require__(1919);
var string = __webpack_require__(8531);
var binary = __webpack_require__(8080);
var bool = __webpack_require__(7969);
var float = __webpack_require__(7191);
var int = __webpack_require__(6936);
var omap = __webpack_require__(692);
var pairs = __webpack_require__(8416);
var set = __webpack_require__(2557);
var timestamp = __webpack_require__(5437);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),

/***/ 2557:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Pair = __webpack_require__(7902);
var YAMLMap = __webpack_require__(1755);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (identity.isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair)
            ? identity.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (identity.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),

/***/ 5437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(3144);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),

/***/ 3789:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),

/***/ 3793:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(6261);
var identity = __webpack_require__(484);
var stringifyComment = __webpack_require__(248);
var stringifyString = __webpack_require__(7180);

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),

/***/ 81:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var stringify = __webpack_require__(3793);
var stringifyComment = __webpack_require__(248);

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = identity.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),

/***/ 248:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),

/***/ 1768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var stringify = __webpack_require__(3793);
var stringifyComment = __webpack_require__(248);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (identity.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),

/***/ 3144:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),

/***/ 8017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);
var Scalar = __webpack_require__(9714);
var stringify = __webpack_require__(3793);
var stringifyComment = __webpack_require__(248);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (identity.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            identity.isCollection(key) ||
            (identity.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),

/***/ 7180:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(9714);
var foldFlowLines = __webpack_require__(3789);

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),

/***/ 9125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(484);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (identity.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (identity.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(291);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map